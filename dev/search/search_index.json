{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Argilla","text":"<p>Argilla is a collaboration platform for AI engineers and domain experts that require high-quality outputs, full data ownership, and overall efficiency.</p> <ul> <li> <p>Get started in 5 minutes!</p> <p>Install <code>argilla</code> with <code>pip</code> and deploy a <code>Docker</code> locally or for free on Hugging Face to get up and running in minutes.</p> <p> Quickstart</p> </li> <li> <p>Educational guides</p> <p>Get familiar with basic and complex workflows for Argilla. From managing <code>Users</code>, <code>Workspaces</code>. <code>Datasets</code> and <code>Records</code> to fine-tuning a model.</p> <p> Learn more</p> </li> </ul>"},{"location":"#why-use-argilla","title":"Why use Argilla?","text":"<p>Whether you are working on monitoring and improving complex generative tasks involving LLM pipelines with RAG, or you are working on a predictive task for things like AB-testing of span- and text-classification models. Our versatile platform helps you ensure your data work pays off.</p> <p>Improve your AI output quality through data quality</p> <p>Compute is expensive and output quality is important. We help you focus on data, which tackles the root cause of both of these problems at once. Argilla helps you to achieve and keep high-quality standards for your data. This means you can improve the quality of your AI output.</p> <p>Take control of your data and models</p> <p>Most AI platforms are black boxes. Argilla is different. We believe that you should be the owner of both your data and your models. That's why we provide you with all the tools your team needs to manage your data and models in a way that suits you best.</p> <p>Improve efficiency by quickly iterating on the right data and models</p> <p>Gathering data is a time-consuming process. Argilla helps by providing a platform that allows you to interact with your data in a more engaging way. This means you can quickly and easily label your data with filters, AI feedback suggestions and semantic search. So you can focus on training your models and monitoring their performance.</p>"},{"location":"#what-do-people-build-with-argilla","title":"What do people build with Argilla?","text":"<p>Datasets and models</p> <p>Argilla is a tool that can be used to achieve and keep high-quality data standards with a focus on NLP and LLMs. Our community uses Argilla to create amazing open-source datasets and models, and we love contributions to open-source ourselves too.</p> <ul> <li>Our cleaned UltraFeedback dataset and the Notus and Notux models, where we improved benchmark and empirical human judgment for the Mistral and Mixtral models with cleaner data using human feedback.</li> <li>Our distilabeled Intel Orca DPO dataset and the improved OpenHermes model, show how we improve model performance by filtering out 50% of the original dataset through human and AI feedback.</li> </ul> <p>Projects and pipelines</p> <p>AI teams from companies like the Red Cross, Loris.ai and Prolific use Argilla to improve the quality and efficiency of AI projects. They shared their experiences in our AI community meetup.</p> <ul> <li>AI for good: the Red Cross presentation showcases how their experts and AI team collaborate by classifying and redirecting requests from refugees of the Ukrainian crisis to streamline the support processes of the Red Cross.</li> <li>Customer support: during the Loris meetup they showed how their AI team uses unsupervised and few-shot contrastive learning to help them quickly validate and gain labelled samples for a huge amount of multi-label classifiers.</li> <li>Research studies: the showcase from Prolific announced their integration with our platform. They use it to actively distribute data collection projects among their annotating workforce. This allows them to quickly and efficiently collect high-quality data for their research studies.</li> </ul>"},{"location":"community/","title":"Community","text":"<p>We are an open-source community-driven project not only focused on building a great product but also on building a great community, where you can get support, share your experiences, and contribute to the project! We would love to hear from you and help you get started with Argilla.</p> <ul> <li> <p>Slack</p> <p>In our Slack you can get direct support from the community.</p> <p> Slack \u2197</p> </li> <li> <p>Community Meetup</p> <p>We host bi-weekly community meetups where you can listen in or present your work.</p> <p> Community Meetup \u2197</p> </li> <li> <p>Changelog</p> <p>The changelog is where you can find the latest updates and changes to the Argilla project.</p> <p> Changelog \u2197</p> </li> <li> <p>Roadmap</p> <p>We love to discuss our plans with the community. Feel encouraged to participate in our roadmap discussions.</p> <p> Roadmap \u2197</p> </li> </ul>"},{"location":"community/contributor/","title":"How to contribute?","text":"<p>Thank you for investing your time in contributing to the project! Any contribution you make will be reflected in the most recent version of Argilla \ud83e\udd29.</p> New to contributing in general? <p>If you're a new contributor, read the README to get an overview of the project. In addition, here are some resources to help you get started with open-source contributions:</p> <ul> <li>Slack: You are welcome to join the Argilla Slack community, where you can keep in touch with other users, contributors and the Argilla team. In the following section, you can find more information on how to get started in Slack.</li> <li>Git: This is a very useful tool to keep track of the changes in your files. Using the command-line interface (CLI), you can make your contributions easily. For that, you need to have it installed and updated on your computer.</li> <li>GitHub: It is a platform and cloud-based service that uses git and allows developers to collaborate on projects. To contribute to Argilla, you'll need to create an account. Check the Contributor Workflow with Git and Github for more info.</li> <li>Developer Documentation: To collaborate, you'll need to set up an efficient environment. Check the developer documentation to know how to do it.</li> <li>Schedule a meeting with our developer advocate: If you have more questions, do not hesitate to contact to our developer advocate and schedule a meeting.</li> </ul>"},{"location":"community/contributor/#first-contact-in-slack","title":"First Contact in Slack","text":"<p>Slack is a very useful tool for more casual conversations and to answer day-to-day questions. Click here to join our Slack community effortlessly.</p> <p>The following screens will be displayed, choose how you wish to join and enter the code sent to you via email.</p> <p></p> <p>Once you have joined the community, you'll be added to some channels by default, but below we show you all the community channels you can join:</p> <ul> <li>00-announcements: \ud83d\udce3 Stay up-to-date on official Argilla</li> <li>01-introductions:  \ud83d\udc4b Say hi! to the community Fun facts are appreciated.</li> <li>02-support-and-questions: \ud83d\ude4b\u200d\u2640\ufe0f Need help with Argilla or NLP? We are always here.</li> <li>03-discoveries-and-news: \ud83d\udcda Looking for resources and news related to everything NLP?</li> <li>04-contributors: \ud83c\udfd7\ufe0f A channel for contributions and contributors.</li> <li>05-beta-testing: \ud83d\udea7 For access to the latest features and help us with testing the newest features.</li> <li>06-general: \ud83d\udc12 This channel is for... well, everything else.</li> <li>07-distilabel: \u2697\ufe0f For all of you questions about our Distilabel project.</li> </ul> <p>So now there is only one thing left to do, introduce yourself and talk to the community. You'll be always welcome! \ud83e\udd17\ud83d\udc4b</p>"},{"location":"community/contributor/#contributor-workflow-with-git-and-github","title":"Contributor Workflow with Git and GitHub","text":"<p>If you're working with Argilla and suddenly a new idea comes to your mind or you find an issue that can be improved, it's time to actively participate and contribute to the project!</p>"},{"location":"community/contributor/#report-an-issue","title":"Report an issue","text":"<p>If you spot a problem, search if an issue already exists. You can use the <code>Label</code> filter. If that is the case, participate in the conversation. If it does not exist, create an issue by clicking on <code>New Issue</code>.</p> <p></p> <p>This will show various templates, choose the one that best suits your issue.</p> <p></p> <p>Below, you can see an example of the <code>Feature request</code> template. Once you choose one, you will need to fill in it following the guidelines. Try to be as clear as possible. In addition, you can assign yourself to the issue and add or choose the right labels. Finally, click on <code>Submit new issue</code>.</p> <p></p>"},{"location":"community/contributor/#work-with-a-fork","title":"Work with a fork","text":""},{"location":"community/contributor/#fork-the-argilla-repository","title":"Fork the Argilla repository","text":"<p>After having reported the issue, you can start working on it. For that, you will need to create a fork of the project. To do that, click on the <code>Fork</code> button.</p> <p></p> <p>Now, fill in the information. Remember to uncheck the <code>Copy develop branch only</code> if you are going to work in or from another branch (for instance, to fix documentation the <code>main</code> branch is used). Then, click on <code>Create fork</code>.</p> <p></p> <p>Now, you will be redirected to your fork. You can see that you are in your fork because the name of the repository will be your <code>username/argilla</code>, and it will indicate <code>forked from argilla-io/argilla</code>.</p>"},{"location":"community/contributor/#clone-your-forked-repository","title":"Clone your forked repository","text":"<p>In order to make the required adjustments, clone the forked repository to your local machine. Choose the destination folder and run the following command:</p> <pre><code>git clone https://github.com/[your-github-username]/argilla.git\ncd argilla\n</code></pre> <p>To keep your fork\u2019s main/develop branch up to date with our repo, add it as an upstream remote branch. For more info, check the documentation.</p> <pre><code>git remote add upstream https://github.com/argilla-io/argilla.git\n</code></pre>"},{"location":"community/contributor/#create-a-new-branch","title":"Create a new branch","text":"<p>For each issue you're addressing, it's advisable to create a new branch. GitHub offers a straightforward method to streamline this process.</p> <p>\u26a0\ufe0f Never work directly on the <code>main</code> or <code>develop</code> branch. Always create a new branch for your changes.</p> <p>Navigate to your issue and on the right column, select <code>Create a branch</code>.</p> <p></p> <p>After the new window pops up, the branch will be named after the issue, include a prefix such as feature/, bug/, or docs/ to facilitate quick recognition of the issue type. In the <code>Repository destination</code>, pick your fork ( [your-github-username]/argilla), and then select <code>Change branch source</code> to specify the source branch for creating the new one. Complete the process by clicking <code>Create branch</code>.</p> <p>\ud83e\udd14 Remember that the <code>main</code> branch is only used to work with the documentation. For any other changes, use the <code>develop</code> branch.</p> <p></p> <p>Now, locally change to the new branch you just created.</p> <pre><code>git fetch origin\ngit checkout [branch-name]\n</code></pre>"},{"location":"community/contributor/#use-changelogmd","title":"Use CHANGELOG.md","text":"<p>If you are working on a new feature, it is a good practice to make note of it for others to keep up with the changes. For that, we utilize the <code>CHANGELOG.md</code> file in the root directory. This file is used to list changes made in each version of the project and there are headers that we use to denote each type of change. - Added: for new features. - Changed: for changes in existing functionality. - Deprecated: for soon-to-be removed features. - Removed: for now removed features. - Fixed: for any bug fixes. - Security: in case of vulnerabilities.</p> <p>A sample addition would be:</p> <pre><code>- Fixed the key errors for the `init` method ([#NUMBER_OF_PR](LINK_TO_PR)). Contributed by @github_handle.\n</code></pre> <p>You can have a look at the CHANGELOG.md file to see more cases and examples.</p>"},{"location":"community/contributor/#make-changes-and-push-them","title":"Make changes and push them","text":"<p>Make the changes you want in your local repository, and test that everything works and you are following the guidelines. Check the documentation for more information about the development.</p> <p>Once you have finished, you can check the status of your repository and synchronize with the upstreaming repo with the following command:</p> <pre><code># Check the status of your repository\ngit status\n\n# Synchronize with the upstreaming repo\ngit checkout [branch-name]\ngit rebase [default-branch]\n</code></pre> <p>If everything is right, we need to commit and push the changes to your fork. For that, run the following commands:</p> <pre><code># Add the changes to the staging area\ngit add filename\n\n# Commit the changes by writing a proper message\ngit commit -m \"commit-message\"\n\n# Push the changes to your fork\ngit push origin [branch-name]\n</code></pre> <p>When pushing, you will be asked to enter your GitHub login credentials. Once the push is complete, all local commits will be on your GitHub repository.</p>"},{"location":"community/contributor/#create-a-pull-request","title":"Create a pull request","text":"<p>Come back to GitHub, navigate to the original repository where you created your fork, and click on <code>Compare &amp; pull request</code>.</p> <p></p> <p>First, click on <code>compare across forks</code> and select the right repositories and branches.</p> <p>In the base repository, keep in mind to select either <code>main</code> or <code>develop</code> based on the modifications made. In the head repository, indicate your forked repository and the branch corresponding to the issue.</p> <p></p> <p>Then, fill in the pull request template. In the title, add the feat, bug or docs prefix depending on the type of modification. A general template will be shown, please click on <code>Preview</code> and choose the corresponding pull request template. In addition, on the right side, you can select a reviewer (for instance, if you discussed the issue with a member of the Argilla team) and assign the pull request to yourself.</p> <p>It is highly advisable to add labels to PR as well. You can do this again by the labels section right to the screen. For instance, if you are addressing a bug, add the <code>bug</code> label or if the PR is related to the documentation, add the <code>documentation</code> label. This way, PRs can be easily filtered.</p> <p>Additionally, you should add a prefix to the PR name as we did with the branch above. If you are working on a new feature, you can name your PR as <code>feat: TITLE</code>. If your PR consists of a solution for a bug, you can name your PR as <code>bug: TITLE</code> And, if your work is for improving the documentation, you can name your PR as <code>docs: TITLE</code>.</p> <p>Finally, click on <code>Create pull request</code>.</p> <p></p> <p>Below, we chose the feature template. Now, fill in it carefully and follow the guidelines. Remember to link the original issue. Finally, enable the checkbox to allow maintainer edits so the branch can be updated for a merge and click on <code>Create pull request</code>.</p> <p></p>"},{"location":"community/contributor/#review-your-pull-request","title":"Review your pull request","text":"<p>Once you submit your PR, a team member will review your proposal. We may ask questions, request additional information or ask for changes to be made before a PR can be merged, either using suggested changes or pull request comments.</p> <p>You can apply the changes directly through the UI (check the files changed and click on the right-corner three dots, see image below) or from your fork, and then commit them to your branch. The PR will be updated automatically and the suggestions will appear as outdated.</p> <p></p> <p>If you run into any merge issues, check out this git tutorial to help you resolve merge conflicts and other issues.</p>"},{"location":"community/contributor/#your-pr-is-merged","title":"Your PR is merged!","text":"<p>Congratulations \ud83c\udf89\ud83c\udf8a We thank you \ud83e\udd29</p> <p>Once your PR is merged, your contributions will be publicly visible on the Argilla GitHub.</p> <p>Additionally, we will include your changes in the next release based on our development branch.</p> <p>We will probably contact you, but if you would like to send your personal information (LinkedIn, profile picture, GitHub) to David, he can set everything up for receiving your JustDiggit bunds and a LinkedIn shoutout.</p>"},{"location":"community/contributor/#additional-resources","title":"Additional resources","text":"<p>Here are some helpful resources for your reference.</p> <ul> <li>Configuring Slack, a guide to learn how to configure Slack.</li> <li>Pro Git, a book to learn Git.</li> <li>Git in VSCode, a guide to learn how to easily use Git in VSCode.</li> <li>GitHub Skills, an interactive course to learn GitHub.</li> </ul>"},{"location":"getting_started/faq/","title":"FAQs","text":"What is Argilla? <p>Argilla is a collaboration platform for AI engineers and domain experts that require high-quality outputs, full data ownership, and overall efficiency. It is designed to help you achieve and keep high-quality data standards, store your training data, store the results of your models, evaluate their performance, and improve the data through human and AI feedback.</p> Does Argilla cost money? <p>No. Argilla is an open-source project and is free to use. You can deploy Argilla on your own infrastructure or use our cloud offering.</p> What data types does Argilla support? <p>Text data, mostly. Argilla natively supports textual data, however, we do support rich text, which means you can represent different types of data in Argilla as long as you can convert it to text. For example, you can store images, audio, video, and any other type of data as long as you can convert it to their base64 representation or render them as HTML in for example an IFrame.</p> Does Argilla train models? <p>No. Argilla is a collaboration platform to achieve and keep high-quality data standards. You can use Argilla to store your training data, store the results of your models, evaluate their performance and improve the data. For training models, you can use any machine learning framework or library that you prefer even though we recommend starting with Hugging Face Transformers.</p> Does Argilla provide annotation workforces? <p>Yes, kind of. We don't provide annotation workforce in-house but we do have partnerships with workforce providers that ensure ethical practices and secure work environments. Feel free to schedule a meeting here or contact us via email.</p> How does Argilla differ from competitors like Lilac, Snorkel, Prodigy and Scale? <p>Argilla distinguishes itself for its focus on specific use cases and human-in-the-loop approaches. While it does offer programmatic features, Argilla\u2019s core value lies in actively involving human experts in the tool-building process, setting it apart from other competitors.</p> <p>Furthermore, Argilla places particular emphasis on smooth integration with other tools in the community, particularly within the realms of MLOps and NLP. So, its compatibility with popular frameworks like spaCy and Hugging Face makes it exceptionally user-friendly and accessible.</p> <p>Finally, platforms like Snorkel, Prodigy or Scale, while more comprehensive, often require a significant commitment. Argilla, on the other hand, works more as a component within the MLOps ecosystem, allowing users to begin with specific use cases and then scale up as needed. This flexibility is particularly beneficial for users and customers who prefer to start small and expand their applications over time, as opposed to committing to an all-encompassing platform from the outset.</p> What is the difference between Argilla 2.0 and the legacy datasets in 1.0? <p>Argilla 1.0 relied on 3 main task datasets: <code>DatasetForTextClassification</code>, <code>DatasetForTokenClassification</code>, and <code>DatasetForText2Text</code>. These tasks were designed to be simple, easy to use and high in functionality but they were limited in adaptability. With the introduction of Large Language Models (LLMs) and the increasing complexity of NLP tasks, we realized that we needed to expand the capabilities of Argilla to support more advanced feedback mechanisms which led to the introduction of the <code>FeedbackDataset</code>. Compared to its predecessor it was high in adaptability but still limited in functionality. After having ported all of the functionality of the legacy tasks to the new <code>FeedbackDataset</code>, we decided to deprecate the legacy tasks in favor of a brand new SDK with the <code>FeedbackDataset</code> at its core.</p>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#install-the-sdk-with-pip","title":"Install the SDK with pip","text":"<p>Since this package is not yet published on PyPi, you can install it directly from the repository:</p> <pre><code>pip install git+https://github.com/argilla-io/argilla-python.git\n</code></pre>"},{"location":"getting_started/installation/#run-the-argilla-server","title":"Run the Argilla server","text":"<p>If you have already deployed Argilla Server, you can skip this step. Otherwise, you can quickly deploy it in two different ways:</p> <p>Note</p> <p>You can use this SDK with any stable release of argilla server &gt;= 1.27.</p> <ul> <li>Using a HF Space.</li> <li>Locally with Docker.</li> </ul> <pre><code>docker run -d --name quickstart -p 6900:6900 argilla/argilla-quickstart:latest\n</code></pre>"},{"location":"getting_started/installation/#connect-to-the-argilla-server","title":"Connect to the Argilla server","text":"<p>Get your <code>&lt;api_url&gt;</code>:</p> <ul> <li>If you are using HF Spaces, it should be constructed as follows: <code>https://[your-owner-name]-[your_space_name].hf.space</code></li> <li>If you are using Docker, it is the URL shown in your browser (by default <code>http://localhost:6900</code>)</li> </ul> <p>Get your <code>&lt;api_key&gt;</code> in <code>My Settings</code> in the Argilla UI (by default owner.apikey).</p> <p>Note</p> <p>Make sure to replace <code>&lt;api_url&gt;</code> and <code>&lt;api_key&gt;</code> with your actual values. If you are using a private HF Space, you need to specify your <code>HF_TOKEN</code> which can be found here.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(\n    api_url=\"&lt;api_url&gt;\",\n    api_key=\"&lt;api_key&gt;\",\n    # extra_headers={\"Authorization\": f\"Bearer {HF_TOKEN}\"}\n)\n</code></pre>"},{"location":"getting_started/installation/#developer-documentation","title":"Developer documentation","text":"<p>If you want to contribute to the development of the SDK, you can follow the instructions below.</p>"},{"location":"getting_started/installation/#installation_1","title":"Installation","text":"<p>To install the development dependencies, run the following commands:</p> <pre><code># Install pdm (https://github.com/pdm-project/pdm)\npip install pdm\n\n# Install the package in editable mode\npip install -e .\n\n# Install the development dependencies with pdm\npdm install --dev\n</code></pre>"},{"location":"getting_started/installation/#generating-documentation","title":"Generating documentation","text":"<p>To generate the docs you will need to install the development dependencies, and run the following command to create the development server with <code>mkdocs</code>:</p> <pre><code>mkdocs serve\n</code></pre> <p>You will find the built documentation in <code>http://localhost:8000/argilla-python/</code>.</p>"},{"location":"getting_started/quickstart/","title":"Quickstart","text":"<p>This guide provides a quick overview of the Argilla SDK and how to create your first dataset.</p>"},{"location":"getting_started/quickstart/#setting-up-your-argilla-project","title":"Setting up your Argilla project","text":""},{"location":"getting_started/quickstart/#install-the-sdk-with-pip","title":"Install the SDK with pip","text":"<p>To work with Argilla datasets, you need to use the Argilla SDK. You can install the SDK with pip as follows:</p> <p>Note</p> <p>The package is not yet available on PyPi. You'll need to install it directly from the GitHub repository.</p> <pre><code>pip install git+https://github.com/argilla-io/argilla-python.git\n</code></pre>"},{"location":"getting_started/quickstart/#run-the-argilla-server","title":"Run the Argilla server","text":"<p>If you have already deployed Argilla Server, you can skip this step. Otherwise, you can quickly deploy it in two different ways:</p> <ul> <li>Remotely using a HF Space.</li> <li>Locally using Docker.</li> </ul> <pre><code>docker run -d --name quickstart -p 6900:6900 argilla/argilla-quickstart:latest\n</code></pre>"},{"location":"getting_started/quickstart/#connect-to-the-argilla-server","title":"Connect to the Argilla server","text":"<p>Get your <code>&lt;api_url&gt;</code>:</p> <ul> <li>If you are using Hugging Face Spaces, the URL should be constructed as follows: <code>https://[your-owner-name]-[your_space_name].hf.space</code></li> <li>If you are using Docker, the URL is the URL shown in your browser (by default <code>http://localhost:6900</code>)</li> </ul> <p>Get your <code>&lt;api_key&gt;</code> in <code>My Settings</code> in the Argilla UI (by default <code>owner.apikey</code>).</p> <p>Note</p> <p>Make sure to replace <code>&lt;api_url&gt;</code> and <code>&lt;api_key&gt;</code> with your actual values. If you are using a private Hugging Face Space, you need to specify your <code>HF_TOKEN</code> which can be found here.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(\n    api_url=\"&lt;api_url&gt;\",\n    api_key=\"&lt;api_key&gt;\"\n    # extra_headers={\"Authorization\": f\"Bearer {HF_TOKEN}\"}\n)\n</code></pre>"},{"location":"getting_started/quickstart/#create-your-first-dataset","title":"Create your first dataset","text":"<p>To create a dataset with a simple text classification task, first, you need to define the dataset settings.</p> <pre><code>settings = rg.Settings(\n    guidelines=\"Classify the reviews as positive or negative.\",\n    fields=[\n        rg.TextField(\n            name=\"review\",\n            title=\"Text from the review\",\n            use_markdown=False,\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(\n            name=\"my_label\",\n            title=\"In which category does this article fit?\",\n            labels=[\"positive\", \"negative\"],\n        )\n    ],\n)\n</code></pre> <p>Now you can create the dataset with the settings you defined. Publish the dataset to make it available in the UI and add the records.</p> <p>Note</p> <p>The <code>workspace</code> parameter is optional. If you don't specify it, the dataset will be created in the default workspace <code>admin</code>.</p> <pre><code>dataset = rg.Dataset(\n    name=f\"my_first_dataset\",\n    settings=settings,\n    client=client,\n)\ndataset.create()\n</code></pre>"},{"location":"getting_started/quickstart/#add-records-to-your-dataset","title":"Add records to your dataset","text":"<p>Retrieve the data to be added to the dataset. We will use the IMDB dataset from the Hugging Face Datasets library.</p> <pre><code>pip install -qqq datasets\n</code></pre> <pre><code>from datasets import load_dataset\n\ndata = load_dataset(\"imdb\", split=\"train[:100]\").to_list()\n</code></pre> <p>Now you can add the data to your dataset. Use <code>mapping</code> to indicate which keys in the source data correspond to the dataset fields.</p> <pre><code># Add records to the dataset\ndataset.records.add(records=data, mapping={\"text\": \"review\"})\n</code></pre> <p>\ud83c\udf89 You have successfully created your first dataset with Argilla. You can now access it in the Argilla UI and start annotating the records.</p>"},{"location":"getting_started/quickstart/#more-references","title":"More references","text":"<ul> <li>Installation guide</li> <li>How-to guides</li> <li>API reference</li> </ul>"},{"location":"guides/how_to_guides/","title":"How-to guides","text":"<p>These are the how-to guides for the Argilla-python SDK. They provide step-by-step instructions for common scenarios, including detailed explanations and code samples.</p> <ul> <li> <p>Manage users and credentials</p> <p>Learn what they are and how to manage (create, read and delete) <code>Users</code> in Argilla.</p> <p> How-to guide</p> </li> <li> <p>Manage workspaces</p> <p>Learn what they are and how to manage (create, read and delete) <code>Workspaces</code> in Argilla.</p> <p> How-to guide</p> </li> <li> <p>Manage and create datasets</p> <p>Learn what they are and how to manage (create, read and delete) <code>Datasets</code> and customize them using the <code>Settings</code> for <code>Fields</code>, <code>Questions</code>,  <code>Metadata</code> and <code>Vectors</code>.</p> <p> How-to guide</p> </li> <li> <p>Add, update, and delete records</p> <p>Learn what they are and how to add, update and delete the values for a <code>Record</code>, which are made up of <code>Metadata</code>, <code>Vectors</code>, <code>Suggestions</code> and <code>Responses</code>.</p> <p> How-to guide</p> </li> <li> <p>Query, filter and export records</p> <p>Learn how to query and filter a <code>Dataset</code> and export their <code>Records</code>.</p> <p> How-to guide</p> </li> </ul>"},{"location":"guides/how_to_guides/dataset/","title":"Dataset management","text":"<p>This guide provides an overview of datasets, explaining the basics of how to set them up and manage them in Argilla.</p> <p>A dataset is a collection of records that you can configure for labelers to provide feedback using the UI. Depending on the specific requirements of your task, you may need various types of feedback. You can customize the dataset to include different kinds of questions, so the first step will be to define the aim of your project and the kind of data and feedback you will need. With this information, you can start configuring a dataset by defining fields, questions, metadata, vectors, and guidelines through settings.</p> Question: Who can manage datasets? <p>Only users with the <code>owner</code> role can manage (create, retrieve, update and delete) all the datasets.</p> <p>The users with the <code>admin</code> role can manage (create, retrieve, update and delete) the datasets in the workspaces they have access to.</p> <p>Main Classes</p> <code>rg.Dataset</code><code>rg.Settings</code> <pre><code>rg.Dataset(\n    name=\"name\",\n    workspace=\"workspace\",\n    settings=settings,\n    client=client\n)\n</code></pre> <p>Check the Dataset - Python Reference to see the attributes, arguments, and methods of the <code>Dataset</code> class in detail.</p> <pre><code>rg.Settings(\n    fields=[rg.TextField(name=\"text\")],\n    questions=[\n        rg.LabelQuestion(\n            name=\"label\",\n            labels=[\"label_1\", \"label_2\", \"label_3\"]\n        )\n    ],\n    metadata=[rg.TermsMetadataProperty(name=\"metadata\")],\n    vectors=[rg.VectorField(name=\"vector\", dimensions=10)],\n    guidelines=\"guidelines\",\n    allow_extra_metadata=True,\n)\n</code></pre> <p>Check the Settings - Python Reference to see the attributes, arguments, and methods of the <code>Settings</code> class in detail.</p>"},{"location":"guides/how_to_guides/dataset/#create-a-dataset","title":"Create a dataset","text":"<p>To create a dataset, you can define it in the <code>Dataset</code> class and then call the <code>create</code> method that will send the dataset to the server so that it can be visualized in the UI. If the dataset does not appear in the UI, you may need to click the refresh button to update the view. For further configuration of the dataset, you can refer to the settings section.</p> <p>The created dataset will be empty, to add the records refer to this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nsettings = rg.Settings(\n    guidelines=\"These are some guidelines.\",\n    fields=[\n        rg.TextField(\n            name=\"text\",\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion\n            name=\"label\",\n            labels=[\"label_1\", \"label_2\", \"label_3\"]\n        ),\n    ],\n)\n\ndataset = rg.Dataset(\n    name=\"my_dataset\",\n    workspace=\"my_workspace\",\n    settings=settings,\n    client=client,\n)\n\ndataset.create()\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a dataset by calling them directly on the <code>dataset</code> object. For example, <code>dataset.id</code>, <code>dataset.name</code> or <code>dataset.settings</code>. You can similarly access the fields, questions, metadata, vectors and guidelines. For instance, <code>dataset.fields</code> or <code>dataset.questions</code>.</p>"},{"location":"guides/how_to_guides/dataset/#create-multiple-datasets-with-the-same-settings","title":"Create multiple datasets with the same settings","text":"<p>To create multiple datasets with the same settings, define the settings once and pass it to each dataset.</p> <pre><code>import argilla_sdk as rg\n\nsettings = rg.Settings(\n    guidelines=\"Select the sentiment of the prompt.\",\n    fields=[rg.TextField(name=\"prompt\", use_markdown=True)],\n    questions=[rg.LabelQuestion(name=\"sentiment\", labels=[\"positive\", \"negative\"])],\n)\n\ndataset1 = rg.Dataset(name=\"sentiment_analysis_1\", settings=settings)\ndataset2 = rg.Dataset(name=\"sentiment_analysis_2\", settings=settings)\n\n# Create the datasets on the server\ndataset1.create()\ndataset2.create()\n</code></pre>"},{"location":"guides/how_to_guides/dataset/#create-a-dataset-with-settings-from-an-existing-dataset","title":"Create a dataset with settings from an existing dataset","text":"<p>To create a new dataset with settings from an existing dataset, get the settings from the existing dataset and pass it to the new dataset.</p> <pre><code>import argilla_sdk as rg\n\n# Get the settings from an existing dataset\nexisting_dataset = client.datasets(\"sentiment_analysis\")\n\n# Create a new dataset with the same settings\ndataset = rg.Dataset(name=\"sentiment_analysis_copy\", settings=existing_dataset.settings)\n\n# Create the dataset on the server\ndataset.create()\n</code></pre>"},{"location":"guides/how_to_guides/dataset/#define-dataset-settings","title":"Define dataset settings","text":""},{"location":"guides/how_to_guides/dataset/#fields","title":"Fields","text":"<p>The fields in a dataset consist of one or more data items requiring annotation. Currently, Argilla only supports plain text and markdown through the <code>TextField</code>, though we plan to introduce additional field types in future updates.</p> <p>A field is defined in the <code>TextField</code> class that has the following arguments:</p> <ul> <li><code>name</code>: The name of the field.</li> <li><code>title</code> (optional): The name of the field, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>required</code> (optional): Whether the field is required or not. Defaults to <code>True</code>. At least one field must be required.</li> <li><code>use_markdown</code> (optional): Specify whether you want markdown rendered in the UI. Defaults to <code>False</code>. If you set it to True, you will be able to use all the Markdown features for text formatting, as well as embed multimedia content and PDFs.</li> </ul> <p>Note</p> <p>The order of the fields in the UI follows the order in which these are added to the fields attribute in the Python SDK.</p> <p><pre><code>rg.TextField(\n    name=\"text\",\n    title=\"Text\",\n    required=True,\n    use_markdown=False\n)\n</code></pre> </p>"},{"location":"guides/how_to_guides/dataset/#questions","title":"Questions","text":"<p>To collect feedback for your dataset, you need to formulate questions that annotators will be asked to answer. Currently, Argilla supports the following types of questions: <code>LabelQuestion</code>, <code>MultiLabelQuestion</code>, <code>RankingQuestion</code>, <code>RatingQuestion</code>, <code>SpanQuestion</code>, and <code>TextQuestion</code>.</p> LabelMulti-labelRankingRatingSpanText <p>A <code>LabelQuestion</code> asks annotators to choose a unique label from a list of options. This type is useful for text classification tasks. In the UI, they will have a rounded shape. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text displayed in the UI.</li> </ul> <p><pre><code>rg.LabelQuestion(\n    name=\"label\",\n    title=\"Is the response relevant for the given prompt?\",\n    description=\"Select the one that applies.\",\n    required=True,\n    labels={\"YES\": \"Yes\", \"NO\": \"No\"}, # or [\"YES\", \"NO\"]\n)\n</code></pre> </p> <p>A <code>MultiLabelQuestion</code> asks annotators to choose all applicable labels from a list of options. This type is useful for multi-label text classification tasks. In the UI, they will have a squared shape. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text displayed in the UI.</li> <li><code>visible_labels</code> (optional): The number of labels that will be visible at first sight in the UI. By default, the UI will show 20 labels and collapse the rest. Set your preferred number to change this limit or set <code>visible_labels=None</code> to show all options.</li> </ul> <p><pre><code>rg.MultiLabelQuestion(\n    name=\"multi_label\",\n    title=\"Does the response include any of the following?\",\n    description=\"Select all that apply.\",\n    required=True,\n    labels={\n        \"hate\": \"Hate Speech\",\n        \"sexual\": \"Sexual content\",\n        \"violent\": \"Violent content\",\n        \"pii\": \"Personal information\",\n        \"untruthful\": \"Untruthful info\",\n        \"not_english\": \"Not English\",\n        \"inappropriate\": \"Inappropriate content\"\n    }, # or [\"hate\", \"sexual\", \"violent\", \"pii\", \"untruthful\", \"not_english\", \"inappropriate\"]\n    visible_labels=4\n)\n</code></pre> </p> <p>A <code>RankingQuestion</code> asks annotators to order a list of options. It is useful to gather information on the preference or relevance of a set of options. Ties are allowed and all options will need to be ranked. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>values</code>: A list of strings with the options they will need to rank. If you'd like the text of the options to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value is the text to display in the UI.</li> </ul> <pre><code>rg.RankingQuestion(\n    name=\"ranking\",\n    title=\"Order replies based on your preference\",\n    description=\"1 = best, 3 = worst. Ties are allowed.\",\n    required=True,\n    values={\n        \"reply-1\": \"Reply 1\",\n        \"reply-2\": \"Reply 2\",\n        \"reply-3\": \"Reply 3\"\n    } # or [\"reply-1\", \"reply-2\", \"reply-3\"]\n)\n</code></pre> <p></p> <p>A <code>RatingQuestion</code> asks annotators to select one option from a list of integer values. This type is useful for collecting numerical scores. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>values</code>: A list of unique integers representing the scores that annotators can select from should be defined within the range [1, 10].</li> </ul> <pre><code>rg.RatingQuestion(\n    name=\"rating\",\n    title=\"How satisfied are you with the response?\",\n    description=\"1 = very unsatisfied, 10 = very satisfied\",\n    required=True,\n    values=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n)\n</code></pre> <p></p> <p>A <code>SpanQuestion</code> asks annotators to select a portion of the text of a specific field and apply a label to it. This type of question is useful for named entity recognition or information extraction tasks. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text to display in the UI.</li> <li><code>field</code>: This question is always attached to a specific field. You should pass a string with the name of the field where the labels of the <code>SpanQuestion</code> should be used.</li> <li><code>allow_overlapping</code>: This value specifies whether overlapped spans are allowed or not. Defaults to <code>False</code>.</li> <li><code>visible_labels</code> (optional): The number of labels that will be visible at first sight in the UI. By default, the UI will show 20 labels and collapse the rest. Set your preferred number to change this limit or set <code>visible_labels=None</code> to show all options.</li> </ul> <pre><code>rg.SpanQuestion(\n    name=\"span\",\n    title=\"Select the entities in the text\",\n    description=\"Select the entities in the text\",\n    required=True,\n    labels={\n        \"PERSON\": \"Person\",\n        \"ORG\": \"Organization\",\n        \"LOC\": \"Location\",\n        \"MISC\": \"Miscellaneous\"\n    },\n    field=\"text\",\n    allow_overlapping=False,\n    visible_labels=None\n)\n</code></pre> <p></p> <p>A <code>TextQuestion</code> offers to annotators a free-text area where they can enter any text. This type is useful for collecting natural language data, such as corrections or explanations. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>use_markdown</code> (optional): Define whether the field should render markdown text. Defaults to <code>False</code>. If you set it to <code>True</code>, you will be able to use all the Markdown features for text formatting, as well as embed multimedia content and PDFs.</li> </ul> <pre><code>rg.TextQuestion(\n    name=\"text\",\n    title=\"Please provide feedback on the response\",\n    description=\"Please provide feedback on the response\",\n    required=True,\n    use_markdown=True\n)\n</code></pre> <p></p>"},{"location":"guides/how_to_guides/dataset/#metadata","title":"Metadata","text":"<p>Metadata properties allow you to configure the use of metadata information for the filtering and sorting features available in the UI and Python SDK. There exist three types of metadata you can add: <code>TermsMetadataProperty</code>, <code>IntegerMetadataProperty</code> and <code>FloatMetadataProperty</code>.</p> TermsIntegerFloat <p>A <code>TermsMetadataProperty</code> allows to add a list of strings as metadata options. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>options</code> (optional): You can pass a list of valid values for this metadata property, in case you want to run any validation.</li> </ul> <p><pre><code>rg.TermsMetadataProperty(\n    name=\"terms\",\n    title=\"Annotation groups\",\n    options=[\"group-a\", \"group-b\", \"group-c\"]\n)\n</code></pre> </p> <p>An <code>IntegerMetadataProperty</code> allows to add integer values as metadata. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>min</code> (optional): You can pass a minimum valid value. If none is provided, the minimum value will be computed from the values provided in the records.</li> <li><code>max</code> (optional): You can pass a maximum valid value. If none is provided, the maximum value will be computed from the values provided in the records.</li> </ul> <p><pre><code>rg.IntegerMetadataProperty(\n    name=\"integer\",\n    title=\"length-input\",\n    min=42,\n    max=1984,\n)\n</code></pre> </p> <p>A <code>FloatMetadataProperty</code> allows to add float values as metadata. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>min</code> (optional): You can pass a minimum valid value. If none is provided, the minimum value will be computed from the values provided in the records.</li> <li><code>max</code> (optional): You can pass a maximum valid value. If none is provided, the maximum value will be computed from the values provided in the records.</li> </ul> <p><pre><code>rg.FloatMetadataProperty(\n    name=\"float\",\n    title=\"Reading ease\",\n    min=-92.29914,\n    max=119.6975,\n)\n</code></pre> </p>"},{"location":"guides/how_to_guides/dataset/#vectors","title":"Vectors","text":"<p>To use the similarity search in the UI and the Python SDK, you will need to configure vectors using the <code>VectorField</code> class. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the vector.</li> <li><code>title</code> (optional): A name for the vector to display in the UI for better readability.</li> <li><code>dimensions</code>: The dimensions of the vectors used in this setting.</li> </ul> <p><pre><code>rg.VectorField(\n    name=\"my_vector\",\n    title=\"My Vector\",\n    dimensions=768\n),\n</code></pre> </p>"},{"location":"guides/how_to_guides/dataset/#guidelines","title":"Guidelines","text":"<p>Once you have decided on the data to show and the questions to ask, it's important to provide clear guidelines to the annotators. These guidelines help them understand the task and answer the questions consistently. You can provide guidelines in two ways:</p> <ul> <li> <p>In the dataset guidelines: this is added as an argument when you create your dataset in the Python SDK. It will appear in the dataset settings in the UI. <pre><code>guidelines = \"In this dataset, you will find a collection of records that show a category, an instruction, a context and a response to that instruction. [...]\"\n</code></pre> </p> </li> <li> <p>As question descriptions: these are added as an argument when you create questions in the Python SDK. This text will appear in a tooltip next to the question in the UI. </p> </li> </ul> <p>It is good practice to use at least the dataset guidelines if not both methods. Question descriptions should be short and provide context to a specific question. They can be a summary of the guidelines to that question, but often that is not sufficient to align the whole annotation team. In the guidelines, you can include a description of the project, details on how to answer each question with examples, instructions on when to discard a record, etc.</p> <p>Tip</p> <p>If you want further guidance on good practices for guidelines during the project development, check our blog post.</p>"},{"location":"guides/how_to_guides/dataset/#list-datasets","title":"List datasets","text":"<p>You can list all the datasets available in a workspace using the <code>datasets</code> attribute of the <code>Workspace</code> class. You can also use <code>len(workspace.datasets)</code> to get the number of datasets in a workspace.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndatasets = workspace.datasets\n\nfor dataset in datasets:\n    print(dataset)\n</code></pre>"},{"location":"guides/how_to_guides/dataset/#retrieve-a-dataset","title":"Retrieve a dataset","text":"<p>You can retrieve a dataset by calling the <code>datasets</code> method on the <code>Argilla</code> class and passing the name of the dataset as an argument. By default, this method attempts to retrieve the dataset from the first workspace. If the dataset is in a different workspace, you must specify either the workspace name or id as an argument.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\n# Retrieve the dataset from the first workspace\nretrieved_dataset = client.datasets(name=\"my_dataset\")\n\n# Retrieve the dataset from the specified workspace\nretrieved_dataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n</code></pre>"},{"location":"guides/how_to_guides/dataset/#check-dataset-existence","title":"Check dataset existence","text":"<p>You can check if a dataset exists by calling the <code>exists</code> method on the <code>Dataset</code> class. This method returns a boolean value.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset = client.datasets(name=\"my_dataset\")\n\ndataset_existed = dataset.exists()\n</code></pre>"},{"location":"guides/how_to_guides/dataset/#update-a-dataset","title":"Update a dataset","text":"<p>You can update a dataset by calling the <code>update</code> method on the <code>Dataset</code> class and passing the new settings as an argument.</p> <p>Note</p> <p>Keep in mind that once your dataset is published, only the guidelines can be updated.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset_to_update = client.datasets(name=\"my_dataset\")\n\nsettings_to_update = rg.Settings(\n    guidelines=\"These are some updated guidelines.\",\n    fields=[\n        rg.TextField(\n            name=\"text\",\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(\n            name=\"label\",\n            labels=[\"label_4\", \"label_5\", \"label_6\"]\n        ),\n    ],\n)\n\ndataset_to_update.settings = settings_to_update\n\ndataset_updated = dataset_to_update.update()\n</code></pre>"},{"location":"guides/how_to_guides/dataset/#delete-a-dataset","title":"Delete a dataset","text":"<p>You can delete an existing dataset by calling the <code>delete</code> method on the <code>Dataset</code> class.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset_to_delete = client.datasets(name=\"my_dataset\")\n\ndataset_deleted = dataset_to_delete.delete()\n</code></pre>"},{"location":"guides/how_to_guides/query_export/","title":"Query, filter, and export records","text":"<p>This guide provides an overview of how to query and filter a dataset in Argilla and export records.</p> <p>You can search for records in your dataset by querying or filtering. The query focuses on the content of the text field, while the filter is used to filter the records based on conditions. You can use them independently or combine multiple filters to create complex search queries. You can also export records from a dataset either as a single dictionary or a list of dictionaries.</p> <p>Main Classes</p> <code>rg.query</code><code>rg.Filter</code> <pre><code>rg.Query(\n    query=\"query\",\n    filter=filter\n)\n</code></pre> <p>Check the Query - Python Reference to see the attributes, arguments, and methods of the <code>Query</code> class in detail.</p> <pre><code>rg.Filter(\n    [\n        (\"field\", \"==\", \"value\"),\n    ]\n)\n</code></pre> <p>Check the Filter - Python Reference to see the attributes, arguments, and methods of the <code>Filter</code> class in detail.</p>"},{"location":"guides/how_to_guides/query_export/#query-with-search-terms","title":"Query with search terms","text":"<p>To search for records with terms, you can use the <code>Dataset.records</code> attribute with a query string. The search terms are used to search for records that contain the terms in the text field. You can search a single term or various terms, in the latter, all of them should appear in the record to be retrieved.</p> Single search termMultiple search term <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery = rg.Query(query=\"my_term\")\n\nqueried_records = list(dataset.records(query=query))\n</code></pre> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery = rg.Query(query=\"my_term1 my_term2\")\n\nqueried_records = list(dataset.records(query=query))\n</code></pre>"},{"location":"guides/how_to_guides/query_export/#filter-by-conditions","title":"Filter by conditions","text":"<p>You can use the <code>Filter</code> class to define the conditions and pass them to the <code>Dataset.records</code> attribute to fetch records based on the conditions. Conditions include \"==\", \"&gt;=\", \"&lt;=\", or \"in\". Conditions can be combined with dot notation to filter records based on metadata, suggestions, or responses. You can use a single condition or multiple conditions to filter records.</p> operator description <code>==</code> The <code>field</code> value is equal to the <code>value</code> <code>&gt;=</code> The <code>field</code> value is greater than or equal to the <code>value</code> <code>&lt;=</code> The <code>field</code> value is less than or equal to the <code>value</code> <code>in</code> TThe <code>field</code> value is included in a list of values Single conditionMultiple conditions <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nfilter_label = rg.Filter((\"label\", \"==\", \"positive\"))\n\nfiltered_records = list(dataset.records(query=rg.Query(filter=filter_label)))\n</code></pre> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nfilters = rg.Filter(\n    [\n        (\"label.suggestion\", \"==\", \"positive\"),\n        (\"metadata.count\", \"&gt;=\", 10),\n        (\"metadata.count\", \"&lt;=\", 20),\n        (\"label\", \"in\", [\"positive\", \"negative\"])\n    ]\n)\n\nfiltered_records = list(dataset.records(\n    query=rg.Query(filter=filters)),\n    with_suggestions=True\n)\n</code></pre>"},{"location":"guides/how_to_guides/query_export/#filter-by-status","title":"Filter by status","text":"<p>You can filter records based on their status. The status can be <code>pending</code>, <code>draft</code>, <code>submitted</code>, or <code>discarded</code>.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nstatus_filter = rg.Query(\n    filter = rg.Filter((\"status\", \"==\", \"submitted\"))\n)\n\nfiltered_records = list(dataset.records(status_filter))\n</code></pre>"},{"location":"guides/how_to_guides/query_export/#query-and-filter-a-dataset","title":"Query and filter a dataset","text":"<p>As mentioned, you can use a query with a search term and a filter or various filters to create complex search queries.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery_filter = rg.Query(\n    query=\"my_term\",\n    filter= rg.Filter(\n        [\n            (\"label.suggestion\", \"==\", \"positive\"),\n            (\"metadata.count\", \"&gt;=\", 10),\n        ]\n    )\n)\n\nqueried_filtered_records = list(dataset.records(\n    query=query_filter,\n    with_metadata=True,\n    with_suggestions=True\n    )\n)\n</code></pre>"},{"location":"guides/how_to_guides/query_export/#export-records-to-a-dictionary","title":"Export records to a dictionary","text":"<p>Records can be exported from <code>Dataset.records</code> as a dictionary. The <code>to_dict</code> method can be used to export records as a dictionary. You can specify the orientation of the dictionary output. You can also decide if to flatten or not the dictionary.</p> <p>=== \" <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\n# Export records as a dictionary\nexported_records = dataset.records.to_dict()\n# {'fields': [{'text': 'Hello'},{'text': 'World'}], suggestions': [{'label': {'value': 'positive'}}, {'label': {'value': 'negative'}}]\n\n# Export records as a dictionary with orient=index\nexported_records = dataset.records.to_dict(orient=\"index\")\n# {\"uuid\": {'fields': {'text': 'Hello'}, 'suggestions': {'label': {'value': 'positive'}}}, {\"uuid\": {'fields': {'text': 'World'}, 'suggestions': {'label': {'value': 'negative'}}},\n\n# Export records as a dictionary with flatten=false\nexported_records = dataset.records.to_dict(flatten=True)\n# {\"text\": [\"Hello\", \"World\"], \"label.suggestion\": [\"greeting\", \"greeting\"]}\n</code></pre></p>"},{"location":"guides/how_to_guides/query_export/#export-records-to-a-list","title":"Export records to a list","text":"<p>Records can be exported from <code>Dataset.records</code> as a list of dictionaries. The <code>to_list</code> method can be used to export records as a list of dictionaries. You can decide if to flatten it or not.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\n# Export records as a list of dictionaries\nexported_records = dataset.records.to_list()\n# [{'fields': {'text': 'Hello'}, 'suggestion': {'label': {value: 'greeting'}}}, {'fields': {'text': 'World'}, 'suggestion': {'label': {value: 'greeting'}}}]\n\n# Export records as a list of dictionaries with flatten=False\nexported_records = dataset.records.to_list(flatten=True)\n# [{\"text\": \"Hello\", \"label\": \"greeting\"}, {\"text\": \"World\", \"label\": \"greeting\"}]\n</code></pre>"},{"location":"guides/how_to_guides/record/","title":"Add, update, and delete records","text":"<p>This guide provides an overview of records, explaining the basics of how to define and manage them in Argilla.</p> <p>A record in Argilla is a data item that requires annotation, consisting of one or more fields. These are the pieces of information displayed to the user in the UI to facilitate the completion of the annotation task. Each record also includes questions that annotators are required to answer, with the option of adding suggestions and responses to assist them. Guidelines are also provided to help annotators effectively complete their tasks.</p> <p>A record is part of a dataset, so you will need to create a dataset before adding records. Check these guides to learn how to create a dataset.</p> <p>Main Class</p> <pre><code>rg.Record(\n    external_id=\"1234\",\n    fields={\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\"\n    },\n    metadata={\n        \"category\": \"A\"\n    },\n    vectors={\n        \"my_vector\": [0.1, 0.2, 0.3],\n    },\n    suggestions=[\n        rg.suggestion(\"my_label\", \"positive\", score=0.9, agent=\"model_name\")\n    ],\n    responses=[\n        rg.response(\"label\", \"positive\", user_id=user_id)\n    ],\n)\n</code></pre> <p>Check the Record - Python Reference to see the attributes, arguments, and methods of the <code>Record</code> class in detail.</p>"},{"location":"guides/how_to_guides/record/#add-records","title":"Add records","text":"<p>You can add records to a dataset in two different ways: either by using a dictionary or by directly initializing a <code>Record</code> object. You should ensure that fields, metadata and vectors match those configured in the dataset settings. In both cases, are added via the <code>Dataset.records.add</code> method. As soon as you add the records, these will be available in the Argilla UI. If they do not appear in the UI, you may need to click the refresh button to update the view.</p> <p>Tip</p> <p>Take some time to inspect the data before adding it to the dataset in case this triggers changes in the <code>questions</code> or <code>fields</code>.</p> <p>Note</p> <p>If you are planning to use public data, the Datasets page of the Hugging Face Hub is a good place to start. Remember to always check the license to make sure you can legally use it for your specific use case.</p> As a dictionaryAs a <code>Record</code> object <p>You can add the data directly as a dictionary, where the keys correspond to the names of fields, questions, metadata or vectors in the dataset and the values are the data to be added. However, you can also use a <code>mapping</code> to indicate which keys in the source data correspond to the dataset fields.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\n# Add records to the dataset with the fields 'question' and 'answer'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n    },\n]\ndataset.records.add(data)\n\n# Add records to the dataset with the a mapping of the fields 'question' and 'answer'\ndata = [\n    {\n        \"query\": \"Do you need oxygen to breathe?\",\n        \"response\": \"Yes\",\n    },\n    {\n        \"query\": \"What is the boiling point of water?\",\n        \"response\": \"100 degrees Celsius\",\n    },\n]\ndataset.records.add(data, mapping={\"query\": \"question\", \"response\": \"answer\"})\n</code></pre> <p>HF example</p> <pre><code>import datasets\nfrom datasets import load_dataset\nfrom uuid import uuid4\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\nworkspace = client.workspaces(\"my_workspace\")\nuser_id = client.users(\"my_user\").id\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nhf_dataset = load_dataset(\"imdb\", split=\"train[:100]\").to_list()\nrecords = [\n    {\n        \"text\": sample[\"text\"],\n        \"label\": \"positive\" if sample[\"label\"] == 1 else \"negative\",\n        \"external_id\": uuid4()\n    }\n    for sample in hf_dataset\n]\n\n\ndataset.records.add(records=records)\n</code></pre> <p>You can also add records to a dataset by initializing a <code>Record</code> object directly.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n    ),\n]\n\ndataset.records.add(records)\n</code></pre> <p>HF example</p> <pre><code>import datasets\nfrom datasets import load_dataset\nfrom uuid import uuid4\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\nworkspace = client.workspaces(\"my_workspace\")\nuser_id = client.users(\"my_user\").id\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nhf_dataset = load_dataset(\"imdb\", split=\"train[:100]\").to_list()\nrecords = [\n    rg.Record(\n        fields={\"text\": sample[\"text\"]}\n        responses=[\n            rg.Response(\n                \"label\",\n                \"positive\" if sample[\"label\"] == 1 else \"negative\",\n                user_id=user_id)\n            ],\n        external_id=uuid4()\n    )\n    for sample in hf_dataset\n]\n\ndataset.records.add(records)\n</code></pre>"},{"location":"guides/how_to_guides/record/#metadata","title":"Metadata","text":"<p>Record metadata can include any information about the record that is not part of the fields in the form of a dictionary. To use metadata for filtering and sorting records, make sure that the key of the dictionary corresponds with the metadata property <code>name</code>. When the key doesn't correspond, this will be considered extra metadata that will get stored with the record (as long as <code>allow_extra_metadata</code> is set to <code>True</code> for the dataset), but will not be usable for filtering and sorting.</p> <p>Note</p> <p>Remember that to use metadata within a dataset, you must define a metadata property in the dataset settings.</p> As part of a dictionaryAs part of a <code>Record</code> object <p>You can add metadata to a record directly as a dictionary, where the keys correspond to the names of metadata properties in the dataset and the values are the metadata to be added. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code># Add records to the dataset with the metadata 'category'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"category\": \"A\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"category\": \"B\",\n    },\n]\ndataset.records.add(data)\n</code></pre> <p>You can also add metadata to a record in an initialized <code>Record</code> object.</p> <pre><code># Add records to the dataset with the metadata 'category'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        metadata={\"category\": \"A\"},\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        metadata={\"category\": \"B\"},\n    ),\n]\ndataset.records.add(records)\n</code></pre>"},{"location":"guides/how_to_guides/record/#vectors","title":"Vectors","text":"<p>You can associate vectors, like text embeddings, to your records. They can be used for semantic search in the UI and the Python SDK. Make sure that the length of the list corresponds to the dimensions set in the vector settings.</p> <p>Note</p> <p>Remember that to use vectors within a dataset, you must define them in the dataset settings.</p> As part of a dictionaryAs part of a <code>Record</code> object <p>You can add vectors as a dictionary, where the keys correspond to the <code>name</code>s of the vector settings that were configured for your dataset and the value is a list of floats. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code># Add records to the dataset with the vector 'my_vector' and dimension=3\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"my_vector\": [0.1, 0.2, 0.3],\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"my_vector\": [0.2, 0.5, 0.3],\n    },\n]\ndataset.records.add(data)\n</code></pre> <p>You can also add vectors to a record in an initialized <code>Record</code> object.</p> <p>Check the Vector - Python Reference to see the attributes, arguments, and methods of the <code>Vector</code> class in detail.</p> <pre><code># Add records to the dataset with the vector 'my_vector' and dimension=3\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        vectors=[\n            rg.Vector(\"my_vector\", [0.1, 0.2, 0.3])\n        ],\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        vectors=[\n            rg.Vector(\"my_vector\", [0.2, 0.5, 0.3])\n        ],\n    ),\n]\ndataset.records.add(records)\n</code></pre>"},{"location":"guides/how_to_guides/record/#suggestions","title":"Suggestions","text":"<p>Suggestions refer to suggested responses (e.g. model predictions) that you can add to your records to make the annotation process faster. These can be added during the creation of the record or at a later stage. Only one suggestion can be provided for each question, and suggestion values must be compliant with the pre-defined questions e.g. if we have a <code>RatingQuestion</code> between 1 and 5, the suggestion should have a valid value within that range.</p> As part of a dictionaryAs part of a <code>Record</code> object <p>You can add suggestions as a dictionary, where the keys correspond to the <code>name</code>s of the labels that were configured for your dataset. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code># Add records to the dataset with the label 'my_label'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"my_label.suggestion\": \"positive\",\n        \"my_label.suggestion.score\": 0.9,\n        \"my_label.suggestion.agent\": \"model_name\"\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"my_label.suggestion\": \"negative\",\n        \"my_label.suggestion.score\": 0.9,\n        \"my_label.suggestion.agent\": \"model_name\"\n    },\n]\ndataset.records.add(data)\n</code></pre> <p>You can also add suggestions to a record in an initialized <code>Record</code> object.</p> <p>Check the Suggestions - Python Reference to see the attributes, arguments, and methods of the <code>Suggestion</code> class in detail.</p> <pre><code># Add records to the dataset with the label 'my_label'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        suggestions=[\n            rg.Suggestion(\n                \"my_label\",\n                \"positive\",\n                score=0.9,\n                agent=\"model_name\"\n            )\n        ],\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        suggestions=[\n            rg.Suggestion(\n                \"my_label\",\n                \"negative\",\n                score=0.9,\n                agent=\"model_name\"\n            )\n        ],\n    ),\n]\ndataset.records.add(records)\n</code></pre>"},{"location":"guides/how_to_guides/record/#responses","title":"Responses","text":"<p>If your dataset includes some annotations, you can add those to the records as you create them. Make sure that the responses adhere to the same format as Argilla's output and meet the schema requirements for the specific type of question being answered. Make sure to include the <code>user_id</code> in case you're planning to add more than one response for the same question, if not responses will apply to all the annotators.</p> <p>Note</p> <p>Keep in mind that records with responses will be displayed as \"Draft\" in the UI.</p> As part of a dictionaryAs part of a <code>Record</code> object <p>You can add suggestions as a dictionary, where the keys correspond to the <code>name</code>s of the labels that were configured for your dataset. Remember that you can also use the <code>mapping</code> parameter to specify the data structure. If you want to specify the user that added the response, you can use the <code>user_id</code> parameter.</p> <pre><code># Add records to the dataset with the label 'my_label'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"my_label.response\": \"positive\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"my_label.response\": \"negative\",\n    },\n]\ndataset.records.add(data, user_id=user.id)\n</code></pre> <p>You can also add suggestions to a record in an initialized <code>Record</code> object.</p> <p>Check the Responses - Python Reference to see the attributes, arguments, and methods of the <code>Suggestion</code> class in detail.</p> <pre><code># Add records to the dataset with the label 'my_label'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        responses=[\n            rg.Response(\"my_label\", \"positive\", user_id=user.id)\n        ]\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        responses=[\n            rg.Response(\"my_label\", \"negative\", user_id=user.id)\n        ]\n    ),\n]\ndataset.records.add(records)\n</code></pre>"},{"location":"guides/how_to_guides/record/#list-records","title":"List records","text":"<p>To list records in a dataset, you can use the <code>records</code> method on the <code>Dataset</code> object. This method returns a list of <code>Record</code> objects that can be iterated over to access the record properties.</p> <pre><code>for record in dataset.records(\n    with_suggestions=True,\n    with_responses=True,\n    with_vectors=True\n    ):\n\n    # Access the record properties\n    print(record.metadata)\n    print(record.vectors)\n    print(record.suggestions)\n    print(record.responses)\n\n    # Access the responses of the record\n    for response in record.responses:\n        print(record.question_name.value)\n</code></pre>"},{"location":"guides/how_to_guides/record/#update-records","title":"Update records","text":"<p>You can update records in a dataset calling the <code>update</code> method on the <code>Dataset</code> object. To update a record, you need to provide the record <code>id</code> and the new data to be updated.</p> <pre><code>data = dataset.records.to_list(flatten=True)\n\nupdated_data = [\n    {\n        \"text\": sample[\"text\"],\n        \"label\": \"positive\",\n        \"id\": sample[\"id\"],\n    }\n    for sample in data\n]\ndataset.records.update(records=updated_data)\n</code></pre> <p>Update the metadata</p> <p>To update the metadata of a record, you can iterate over the records and update the metadata dictionary by key or using <code>metadata.update</code>. After that, you should update the records in the dataset.</p> <pre><code>updated_records = []\nfor record in dataset.records():\n\n    # By key\n    record.metadata[\"my_metadata\"] = \"new_value\"\n    record.metadata[\"my_new_metadata\"] = \"new_value\"\n\n    # With metadata.update\n    record.metadata.update({\"my_metadata\": \"new_value\", \"my_new_metadata\": \"new_value\"})\n\n    updated_records.append(record)\n\ndataset.records.update(records=updated_records)\n</code></pre>"},{"location":"guides/how_to_guides/user/","title":"User Management","text":"<p>This guide provides an overview of user roles and credentials, explaining how to set up and manage users in Argilla.</p> <p>A user in Argilla is an authorized person, who depending on their role, can use the Python SDK and access the UI in a running Argilla instance. We differentiate between three types of users depending on their role, permissions and needs: <code>owner</code>, <code>admin</code> and <code>annotator</code>.</p> OverviewOwnerAdminAnnotator Owner Admin Annotator Number Unlimited Unlimited Unlimited Create and delete workspaces Yes No No Assign users to workspaces Yes No No Create, configure, update, and delete datasets Yes Only within assigned workspaces No Create, update, and delete users Yes No No Provide feedback with Argila UI Yes Yes Yes <p>The <code>owner</code> refers to the root user who created the Argilla instance. Using workspaces within Argilla proves highly beneficial for organizing tasks efficiently. So, the owner has full access to all workspaces and their functionalities:</p> <ul> <li>Workspace management: It can create, read and delete a workspace.</li> <li>User management: It can create a new user, assign it to a workspace, and delete it. It can also list them and search for a specific one.</li> <li>Dataset management: It can create, configure, retrieve, update, and delete datasets.</li> <li>Annotation: It can annotate datasets in the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> <p>An <code>admin</code> user can only access the workspaces it has been assigned to and cannot assign other users to it. An admin user has the following permissions:</p> <ul> <li>Dataset management: It can create, configure, retrieve, update, and delete datasets only on the assigned workspaces.</li> <li>Annotation: It can annotate datasets in the assigned workspaces via the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> <p>An <code>annotator</code> user is limited to accessing only the datasets assigned to it within the workspace. It has two specific permissions:</p> <ul> <li>Annotation: It can annotate the assigned datasets in the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> Question: Who can manage users? <p>Only users with the <code>owner</code> role can manage (create, retrieve, delete) other users.</p>"},{"location":"guides/how_to_guides/user/#default-users-and-credentials","title":"Default users and credentials","text":"<p>Argilla provides a default user with the <code>owner</code> role to help you get started in Python and the UI. The credentials for this user vary depending on the server configuration.</p> Environment Username Password API Key Quickstart Docker and HF Space owner 12345678 owner.apikey Server image argilla 1234 argilla.apikey <p>Main Class</p> <pre><code>rg.User(\n    username=\"username\",\n    first_name=\"first_name\",\n    last_name=\"last_name\",\n    role=\"owner\",\n    password=\"password\",\n    client=client\n)\n</code></pre> <p>Check the User - Python Reference to see the attributes, arguments, and methods of the <code>User</code> class in detail.</p>"},{"location":"guides/how_to_guides/user/#get-current-user","title":"Get current user","text":"<p>To ensure you're using the correct credentials for managing users, you can get the current user in Argilla using the <code>me</code> attribute of the <code>Argilla</code> class.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ncurrent_user = client.me\n</code></pre>"},{"location":"guides/how_to_guides/user/#create-a-user","title":"Create a user","text":"<p>To create a new user in Argilla, you can define it in the <code>User</code> class and then call the <code>create</code> method. This method is inherited from the <code>Resource</code> base class and operates without modifications.</p> <p>Info</p> <p>If you don't provide a password, a random one will be generated for you. Ensure you store this password securely by accessing it through <code>user.password</code> immediately after user creation. For security reasons, the password will not be retrievable later.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser_to_create = rg.User(\n    username=\"my_username\",\n    password=\"12345678\",\n    client=client\n)\n\ncreated_user = user_to_create.create()\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a user by calling them directly on the <code>User</code> object. For example, <code>user.id</code> or <code>user.username</code>.</p>"},{"location":"guides/how_to_guides/user/#list-users","title":"List users","text":"<p>You can list all the existing users in Argilla by accessing the <code>users</code> attribute on the <code>Argilla</code> class and iterating over them. You can also use <code>len(client.users)</code> to get the number of users.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nusers = client.users\n\nfor user in users:\n    print(user)\n</code></pre> <p>Notebooks</p> <p>When using a notebook, executing <code>client.users</code> will display a table with <code>username</code>, <code>id</code>, <code>role</code>, and the last update as <code>updated_at</code>.</p>"},{"location":"guides/how_to_guides/user/#retrieve-a-user","title":"Retrieve a user","text":"<p>You can retrieve an existing user from Argilla by accessing the <code>users</code> attribute on the <code>Argilla</code> class and passing the <code>username</code> as an argument.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nretrieved_user = client.users(\"my_username\")\n</code></pre>"},{"location":"guides/how_to_guides/user/#list-users-in-a-workspace","title":"List users in a workspace","text":"<p>You can list all the users in a workspace by accessing the <code>users</code> attribute on the <code>Workspace</code> class and iterating over them. You can also use <code>len(workspace.users)</code> to get the number of users by workspace.</p> <p>For further information on how to manage workspaces, check this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces('my_workspace')\n\nfor user in workspace.users:\n    print(user)\n</code></pre>"},{"location":"guides/how_to_guides/user/#add-a-user-to-a-workspace","title":"Add a user to a workspace","text":"<p>You can add an existing user to a workspace in Argilla by calling the <code>add_to_workspace</code> method on the <code>User</code> class.</p> <p>For further information on how to manage workspaces, check this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser = client.users('my_username')\nworkspace = client.workspaces('my_workspace')\n\nadded_user = user.add_to_workspace(workspace)\n</code></pre>"},{"location":"guides/how_to_guides/user/#remove-a-user-from-a-workspace","title":"Remove a user from a workspace","text":"<p>You can remove an existing user from a workspace in Argilla by calling the <code>remove_from_workspace</code> method on the <code>User</code> class.</p> <p>For further information on how to manage workspaces, check this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser = client.users('my_username')\nworkspace = client.workspaces('my_workspace')\n\nremoved_user = user.remove_from_workspace(workspace)\n</code></pre>"},{"location":"guides/how_to_guides/user/#delete-a-user","title":"Delete a user","text":"<p>You can delete an existing user from Argilla by calling the <code>delete</code> method on the <code>User</code> class.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser_to_delete = client.users('my_username')\n\ndeleted_user = user_to_delete.delete()\n</code></pre>"},{"location":"guides/how_to_guides/workspace/","title":"Workspace Management","text":"<p>This guide provides an overview of workspaces, explaining how to set up and manage workspaces in Argilla.</p> <p>A workspace is a space inside your Argilla instance where authorized users can collaborate on datasets. It is accessible through the Python SDK and the UI.</p> Question: Who can manage workspaces? <p>Only users with the <code>owner</code> role can manage (create, read and delete) workspaces.</p> <p>A user with the <code>admin</code> role can only read the workspace to which it belongs.</p>"},{"location":"guides/how_to_guides/workspace/#default-workspaces","title":"Default workspaces","text":"<p>Argilla provides a default workspace to help you get started in Python and the UI. The name of this workspace varies depending on the server configuration.</p> Environment Name Quickstart Docker and HF Space admin Server image argilla <p>Main Class</p> <pre><code>rg.Workspace(\n    name = \"name\",\n    client=client\n)\n</code></pre> <p>Check the Workspace - Python Reference to see the attributes, arguments, and methods of the <code>Workspace</code> class in detail.</p>"},{"location":"guides/how_to_guides/workspace/#create-a-new-workspace","title":"Create a new workspace","text":"<p>To create a new workspace in Argilla, you can define it in the <code>Workspace</code> class and then call the <code>create</code> method. This method is inherited from the <code>Resource</code> base class and operates without modifications.</p> <p>When you create a new workspace, it will be empty. To create and add a new dataset, check these guides.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace_to_create = rg.Workspace(\n    name = \"my_workspace\",\n    client=client\n)\n\ncreated_workspace = workspace_to_create.create()\ncreated_workspace\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a workspace by calling them directly on the <code>Workspace</code> object. For example, <code>workspace.id</code> or <code>workspace.name</code>.</p>"},{"location":"guides/how_to_guides/workspace/#list-workspaces","title":"List workspaces","text":"<p>You can list all the existing workspaces in Argilla by calling the <code>workspaces</code> attribute on the <code>Argilla</code> class and iterating over them. You can also use <code>len(client.workspaces)</code> to get the number of workspaces.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspaces = client.workspaces\n\nfor workspace in workspaces:\n    print(workspace)\n</code></pre> <p>Notebooks</p> <p>When using a notebook, executing <code>client.workspaces</code> will display a table with the number of <code>datasets</code> in each workspace, <code>name</code>, <code>id</code>, and the last update as <code>updated_at</code>.</p>"},{"location":"guides/how_to_guides/workspace/#retrieve-a-workspace","title":"Retrieve a workspace","text":"<p>You can retrieve a workspace by accessing the <code>workspaces</code> method on the <code>Argilla</code> class and passing the name of the workspace as an argument.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nretrieved_workspace = client.workspaces(\"my_workspace\")\n</code></pre>"},{"location":"guides/how_to_guides/workspace/#check-workspace-existence","title":"Check workspace existence","text":"<p>You can check if a workspace exists by calling the <code>exists</code> method on the <code>Workspace</code> class. This method returns a boolean value.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\nworkspace_existed = workspace.exists()\n</code></pre>"},{"location":"guides/how_to_guides/workspace/#list-users-in-a-workspace","title":"List users in a workspace","text":"<p>You can list all the users in a workspace by accessing the <code>users</code> attribute on the <code>Workspace</code> class and iterating over them. You can also use <code>len(workspace.users)</code> to get the number of users by workspace.</p> <p>For further information on how to manage users, check this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces('my_workspace')\n\nfor user in workspace.users:\n    print(user)\n</code></pre>"},{"location":"guides/how_to_guides/workspace/#add-a-user-to-a-workspace","title":"Add a user to a workspace","text":"<p>You can also add a user to a workspace by calling the <code>add_user</code> method on the <code>Workspace</code> class.</p> <p>For further information on how to manage users, check this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\nadded_user = workspace.add_user(\"my_username\")\n</code></pre>"},{"location":"guides/how_to_guides/workspace/#remove-a-user-from-workspace","title":"Remove a user from workspace","text":"<p>You can also remove a user from a workspace by calling the <code>remove_user</code> method on the <code>Workspace</code> class.</p> <p>For further information on how to manage users, check this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\nremoved_user = workspace.remove_user(\"my_username\")\n</code></pre>"},{"location":"guides/how_to_guides/workspace/#delete-a-workspace","title":"Delete a workspace","text":"<p>To delete a workspace, no dataset can be associated with it. If the workspace contains any dataset, deletion will fail. You can delete a workspace by calling the <code>delete</code> method on the <code>Workspace</code> class.</p> <p>To clear a workspace and delete all their datasets, refer to this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace_to_delete = client.workspaces(\"my_workspace\")\n\ndeleted_workspace = workspace_to_delete.delete()\n</code></pre>"},{"location":"reference/argilla_sdk/SUMMARY/","title":"SUMMARY","text":"<ul> <li>rg.Argilla</li> <li>rg.Workspace</li> <li>rg.User</li> <li>rg.Dataset<ul> <li>rg.Dataset.records</li> </ul> </li> <li>rg.Settings<ul> <li>Fields</li> <li>Questions</li> <li>Metadata</li> <li>Vectors</li> </ul> </li> <li>rg.Record<ul> <li>rg.Response</li> <li>rg.Suggestion</li> <li>rg.Vector</li> <li>rg.Metadata</li> </ul> </li> <li>rg.Query</li> </ul>"},{"location":"reference/argilla_sdk/client/","title":"<code>rg.Argilla</code>","text":"<p>To interact with the Argilla server from python you can use the <code>Argilla</code> class. The <code>Argilla</code> client is used to create, get, update, and delete all Argilla resources, such as workspaces, users, datasets, and records.</p>"},{"location":"reference/argilla_sdk/client/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/client/#connecting-to-an-argilla-server","title":"Connecting to an Argilla server","text":"<p>To connect to an Argilla server, instantiate the <code>Argilla</code> class and pass the <code>api_url</code> of the server and the <code>api_key</code> to authenticate.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(\n    api_url=\"https://argilla.example.com\",\n    api_key=\"my_token\",\n)\n</code></pre>"},{"location":"reference/argilla_sdk/client/#accessing-dataset-workspace-and-user-objects","title":"Accessing Dataset, Workspace, and User objects","text":"<p>The <code>Argilla</code> clients provides access to the <code>Dataset</code>, <code>Workspace</code>, and <code>User</code> objects of the Argilla server.</p> <pre><code>my_dataset = client.datasets(\"my_dataset\")\n\nmy_workspace = client.workspaces(\"my_workspace\")\n\nmy_user = client.users(\"my_user\")\n</code></pre> <p>These resources can then be interacted with to access their properties and methods. For example, to list all datasets in a workspace:</p> <pre><code>for dataset in my_workspace.datasets:\n    print(dataset.name)\n</code></pre>"},{"location":"reference/argilla_sdk/client/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/client/#rgargilla_1","title":"<code>rg.Argilla</code>","text":"<p>             Bases: <code>APIClient</code></p> <p>Argilla API client. This is the main entry point to interact with the API.</p> <p>Attributes:</p> Name Type Description <code>workspaces</code> <code>Workspaces</code> <p>A collection of workspaces.</p> <code>datasets</code> <code>Datasets</code> <p>A collection of datasets.</p> <code>users</code> <code>Users</code> <p>A collection of users.</p> <code>me</code> <code>User</code> <p>The current user.</p> Source code in <code>src/argilla_sdk/client.py</code> <pre><code>class Argilla(_api.APIClient):\n    \"\"\"Argilla API client. This is the main entry point to interact with the API.\n\n    Attributes:\n        workspaces: A collection of workspaces.\n        datasets: A collection of datasets.\n        users: A collection of users.\n        me: The current user.\n\n    \"\"\"\n\n    # Default instance of Argilla\n    _default_client: Optional[\"Argilla\"] = None\n\n    def __init__(\n        self,\n        api_url: Optional[str] = DEFAULT_HTTP_CONFIG.api_url,\n        api_key: Optional[str] = DEFAULT_HTTP_CONFIG.api_key,\n        timeout: int = DEFAULT_HTTP_CONFIG.timeout,\n        **http_client_args,\n    ) -&gt; None:\n        super().__init__(api_url=api_url, api_key=api_key, timeout=timeout, **http_client_args)\n\n        self._set_default(self)\n\n    @property\n    def workspaces(self) -&gt; \"Workspaces\":\n        \"\"\"A collection of workspaces on the server.\"\"\"\n        return Workspaces(client=self)\n\n    @property\n    def datasets(self) -&gt; \"Datasets\":\n        \"\"\"A collection of datasets on the server.\"\"\"\n        return Datasets(client=self)\n\n    @property\n    def users(self) -&gt; \"Users\":\n        \"\"\"A collection of users on the server.\"\"\"\n        return Users(client=self)\n\n    @property\n    def me(self) -&gt; \"User\":\n        \"\"\"The current user.\"\"\"\n        from argilla_sdk import User\n\n        return User(client=self, _model=self.api.users.get_me())\n\n    ############################\n    # Private methods\n    ############################\n\n    @classmethod\n    def _set_default(cls, client: \"Argilla\") -&gt; None:\n        \"\"\"Set the default instance of Argilla.\"\"\"\n        cls._default_client = client\n\n    @classmethod\n    def _get_default(cls) -&gt; \"Argilla\":\n        \"\"\"Get the default instance of Argilla. If it doesn't exist, create a new one.\"\"\"\n        if cls._default_client is None:\n            cls._default_client = Argilla()\n        return cls._default_client\n</code></pre>"},{"location":"reference/argilla_sdk/client/#argilla_sdk.client.Argilla.datasets","title":"<code>datasets: Datasets</code>  <code>property</code>","text":"<p>A collection of datasets on the server.</p>"},{"location":"reference/argilla_sdk/client/#argilla_sdk.client.Argilla.me","title":"<code>me: User</code>  <code>property</code>","text":"<p>The current user.</p>"},{"location":"reference/argilla_sdk/client/#argilla_sdk.client.Argilla.users","title":"<code>users: Users</code>  <code>property</code>","text":"<p>A collection of users on the server.</p>"},{"location":"reference/argilla_sdk/client/#argilla_sdk.client.Argilla.workspaces","title":"<code>workspaces: Workspaces</code>  <code>property</code>","text":"<p>A collection of workspaces on the server.</p>"},{"location":"reference/argilla_sdk/search/","title":"<code>rg.Query</code>","text":"<p>To collect records based on searching criteria, you can use the <code>Query</code> and <code>Filter</code> classes. The <code>Query</code> class is used to define the search criteria, while the <code>Filter</code> class is used to filter the search results. <code>Filter</code> is passed to a <code>Query</code> object so you can combine multiple filters to create complex search queries. A <code>Query</code> object can also be passed to <code>Dataset.records</code> to fetch records based on the search criteria.</p>"},{"location":"reference/argilla_sdk/search/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/search/#searching-for-records-with-terms","title":"Searching for records with terms","text":"<p>To search for records with terms, you can use the <code>Dataset.records</code> attribute with a query string. The search terms are used to search for records that contain the terms in the text field.</p> <pre><code>for record in dataset.records(query=\"paris\"):\n    print(record)\n</code></pre>"},{"location":"reference/argilla_sdk/search/#filtering-records-by-conditions","title":"Filtering records by conditions","text":"<p>Argilla allows you to filter records based on conditions. You can use the <code>Filter</code> class to define the conditions and pass them to the <code>Dataset.records</code> attribute to fetch records based on the conditions. Conditions include \"==\", \"&gt;=\", \"&lt;=\", or \"in\". Conditions can be combined with dot notation to filter records based on metadata, suggestions, or responses.</p> <pre><code># create a range from 10 to 20\nrange_filter = rg.Filter(\n    [\n        (\"metadata.count\", \"&gt;=\", 10),\n        (\"metadata.count\", \"&lt;=\", 20)\n    ]\n)\n\n# query records with metadata count greater than 10 and less than 20\nquery = rg.Query(filters=range_filter, query=\"paris\")\n\n# iterate over the results\nfor record in dataset.records(query=query):\n    print(record)\n</code></pre>"},{"location":"reference/argilla_sdk/search/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/search/#rgquery_1","title":"<code>rg.Query</code>","text":"<p>This class is used to map user queries to the internal query models</p> Source code in <code>src/argilla_sdk/records/_search.py</code> <pre><code>class Query:\n    \"\"\"This class is used to map user queries to the internal query models\"\"\"\n\n    query: Optional[str] = None\n\n    def __init__(self, *, query: Union[str, None] = None, filter: Union[Filter, None] = None):\n        \"\"\"Create a query object for use in Argilla search requests.add()\n\n        Parameters:\n            query (Union[str, None], optional): The query string that will be used to search.\n            filter (Union[Filter, None], optional): The filter object that will be used to filter the search results.\n        \"\"\"\n\n        self.query = query\n        self.filter = filter\n\n    @property\n    def model(self) -&gt; SearchQueryModel:\n        model = SearchQueryModel()\n\n        if self.query is not None:\n            text_query = TextQueryModel(q=self.query)\n            model.query = QueryModel(text=text_query)\n\n        if self.filter is not None:\n            model.filters = self.filter.model\n\n        return model\n</code></pre>"},{"location":"reference/argilla_sdk/search/#argilla_sdk.records._search.Query.__init__","title":"<code>__init__(*, query=None, filter=None)</code>","text":"<p>Create a query object for use in Argilla search requests.add()</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, None]</code> <p>The query string that will be used to search.</p> <code>None</code> <code>filter</code> <code>Union[Filter, None]</code> <p>The filter object that will be used to filter the search results.</p> <code>None</code> Source code in <code>src/argilla_sdk/records/_search.py</code> <pre><code>def __init__(self, *, query: Union[str, None] = None, filter: Union[Filter, None] = None):\n    \"\"\"Create a query object for use in Argilla search requests.add()\n\n    Parameters:\n        query (Union[str, None], optional): The query string that will be used to search.\n        filter (Union[Filter, None], optional): The filter object that will be used to filter the search results.\n    \"\"\"\n\n    self.query = query\n    self.filter = filter\n</code></pre>"},{"location":"reference/argilla_sdk/search/#rgfilter","title":"<code>rg.Filter</code>","text":"<p>This class is used to map user filters to the internal filter models</p> Source code in <code>src/argilla_sdk/records/_search.py</code> <pre><code>class Filter:\n    \"\"\"This class is used to map user filters to the internal filter models\"\"\"\n\n    def __init__(self, conditions: Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None] = None):\n        \"\"\" Create a filter object for use in Argilla search requests.\n\n        Parameters:\n            conditions (Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None], optional): \\\n                The conditions that will be used to filter the search results. \\\n                The conditions should be a list of tuples where each tuple contains \\\n                the field, operator, and value. For example `(\"label\", \"in\", [\"positive\",\"happy\"])`.\\\n\n        \"\"\"\n\n        if isinstance(conditions, tuple):\n            conditions = [conditions]\n        self.conditions = [Condition(condition) for condition in conditions]\n\n    @property\n    def model(self) -&gt; AndFilterModel:\n        return AndFilterModel.model_validate({\"and\": [condition.model for condition in self.conditions]})\n</code></pre>"},{"location":"reference/argilla_sdk/search/#argilla_sdk.records._search.Filter.__init__","title":"<code>__init__(conditions=None)</code>","text":"<p>Create a filter object for use in Argilla search requests.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None]</code> <p>The conditions that will be used to filter the search results.                 The conditions should be a list of tuples where each tuple contains                 the field, operator, and value. For example <code>(\"label\", \"in\", [\"positive\",\"happy\"])</code>.</p> <code>None</code> Source code in <code>src/argilla_sdk/records/_search.py</code> <pre><code>def __init__(self, conditions: Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None] = None):\n    \"\"\" Create a filter object for use in Argilla search requests.\n\n    Parameters:\n        conditions (Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None], optional): \\\n            The conditions that will be used to filter the search results. \\\n            The conditions should be a list of tuples where each tuple contains \\\n            the field, operator, and value. For example `(\"label\", \"in\", [\"positive\",\"happy\"])`.\\\n\n    \"\"\"\n\n    if isinstance(conditions, tuple):\n        conditions = [conditions]\n    self.conditions = [Condition(condition) for condition in conditions]\n</code></pre>"},{"location":"reference/argilla_sdk/users/","title":"<code>rg.User</code>","text":"<p>A user in Argilla is a profile that uses the SDK or UI. Their profile can be used to track their feedback activity and to manage their access to the Argilla server.</p>"},{"location":"reference/argilla_sdk/users/#usage-examples","title":"Usage Examples","text":"<p>To create a new user, instantiate the <code>User</code> object with the client and the username:</p> <pre><code>user = rg.User(username=\"my_username\", password=\"my_password\")\nuser.create()\n</code></pre> <p>Existing users can be retrieved by their username:</p> <pre><code>user = client.users(\"my_username\")\n</code></pre> <p>The current user of the <code>rg.Argilla</code> client can be accessed using the <code>me</code> attribute:</p> <pre><code>client.me\n</code></pre>"},{"location":"reference/argilla_sdk/users/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/users/#rguser_1","title":"<code>rg.User</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla users in the Argilla server. User profiles         are used to manage access to the Argilla server and track responses to records.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>The username of the user.</p> <code>first_name</code> <code>str</code> <p>The first name of the user.</p> <code>last_name</code> <code>str</code> <p>The last name of the user.</p> <code>role</code> <code>str</code> <p>The role of the user, either 'annotator' or 'admin'.</p> <code>password</code> <code>str</code> <p>The password of the user.</p> <code>id</code> <code>UUID</code> <p>The ID of the user.</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>class User(Resource):\n    \"\"\"Class for interacting with Argilla users in the Argilla server. User profiles \\\n        are used to manage access to the Argilla server and track responses to records.\n\n    Attributes:\n        username (str): The username of the user.\n        first_name (str): The first name of the user.\n        last_name (str): The last name of the user.\n        role (str): The role of the user, either 'annotator' or 'admin'.\n        password (str): The password of the user.\n        id (UUID): The ID of the user.\n    \"\"\"\n\n    _model: UserModel\n    _api: UsersAPI\n\n    def __init__(\n        self,\n        username: Optional[str] = None,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        role: Optional[str] = None,\n        password: Optional[str] = None,\n        client: Optional[\"Argilla\"] = None,\n        id: Optional[UUID] = None,\n        _model: Optional[UserModel] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a User object with a client and a username\n\n        Parameters:\n            username (str): The username of the user\n            first_name (str): The first name of the user\n            last_name (str): The last name of the user\n            role (str): The role of the user, either 'annotator', admin, or 'owner'\n            password (str): The password of the user. If not provided, a random password will be generated\n            client (Argilla): The client used to interact with Argilla\n\n        Returns:\n            User: The initialized user object\n        ```\n        \"\"\"\n        client = client or Argilla._get_default()\n        super().__init__(client=client, api=client.api.users)\n\n        if _model is None:\n            _model = UserModel(\n                username=username,\n                password=password or self._generate_random_password(),\n                first_name=first_name or username,\n                last_name=last_name,\n                role=role or Role.annotator,\n                id=id,\n            )\n            self.log(f\"Initialized user with username {username}\")\n        self._model = _model\n\n    def create(self) -&gt; \"User\":\n        \"\"\"Creates the user in Argilla. After creating a user, it will be able to log in to the Argilla server.\n\n        Returns:\n            User: The user that was created in Argilla.\n\n        \"\"\"\n        model_create = self.api_model()\n        model = self._api.create(model_create)\n        # The password is not returned in the response\n        model.password = model_create.password\n        self._model = model\n        return self\n\n    def delete(self) -&gt; None:\n        \"\"\"Deletes the user from Argilla. After deleting a user, it will no longer be able to log in to the Argilla server.\"\"\"\n        super().delete()\n        # exists relies on the id, so we need to set it to None\n        self._model = UserModel(username=self.username)\n\n    def exists(self) -&gt; bool:\n        \"\"\"Checks if the user exists in Argilla\n\n        Returns:\n            bool: True if the user exists, False otherwise.\n        \"\"\"\n        # TODO - Implement the exist method in the API\n        return self.id is not None\n\n    def add_to_workspace(self, workspace: \"Workspace\") -&gt; \"User\":\n        \"\"\"Adds the user to a workspace. After adding a user to a workspace, it will have access to the datasets\n        in the workspace.\n\n        Args:\n            workspace (Workspace): The workspace to add the user to.\n\n        Returns:\n            User: The user that was added to the workspace.\n        \"\"\"\n        self._model = self._api.add_to_workspace(workspace.id, self.id)\n        return self\n\n    def remove_from_workspace(self, workspace: \"Workspace\") -&gt; \"User\":\n        \"\"\"Removes the user from a workspace. After removing a user from a workspace, it will no longer have access to\n        the datasets in the workspace.\n\n        Args:\n            workspace (Workspace): The workspace to remove the user from.\n\n        Returns:\n            User: The user that was removed from the workspace.\n\n        \"\"\"\n        self._model = self._api.delete_from_workspace(workspace.id, self.id)\n        return self\n\n    ############################\n    # Properties\n    ############################\n    @property\n    def username(self) -&gt; str:\n        return self._model.username\n\n    @username.setter\n    def username(self, value: str) -&gt; None:\n        self._model.username = value\n\n    @property\n    def password(self) -&gt; str:\n        return self._model.password\n\n    @password.setter\n    def password(self, value: str) -&gt; None:\n        self._model.password = value\n\n    @property\n    def first_name(self) -&gt; str:\n        return self._model.first_name\n\n    @first_name.setter\n    def first_name(self, value: str) -&gt; None:\n        self._model.first_name = value\n\n    @property\n    def last_name(self) -&gt; str:\n        return self._model.last_name\n\n    @last_name.setter\n    def last_name(self, value: str) -&gt; None:\n        self._model.last_name = value\n\n    @property\n    def role(self) -&gt; Role:\n        return self._model.role\n\n    @role.setter\n    def role(self, value: Role) -&gt; None:\n        self._model.role = value\n\n    ############################\n    # Private methods\n    ############################\n\n    @staticmethod\n    def _generate_random_password(n: int = 12) -&gt; str:\n        \"\"\"Generates a random password for the user\"\"\"\n        import random\n        import string\n\n        return \"\".join(random.choices(string.ascii_letters + string.digits, k=n))\n</code></pre>"},{"location":"reference/argilla_sdk/users/#argilla_sdk.users.User.__init__","title":"<code>__init__(username=None, first_name=None, last_name=None, role=None, password=None, client=None, id=None, _model=None)</code>","text":"<p>Initializes a User object with a client and a username</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username of the user</p> <code>None</code> <code>first_name</code> <code>str</code> <p>The first name of the user</p> <code>None</code> <code>last_name</code> <code>str</code> <p>The last name of the user</p> <code>None</code> <code>role</code> <code>str</code> <p>The role of the user, either 'annotator', admin, or 'owner'</p> <code>None</code> <code>password</code> <code>str</code> <p>The password of the user. If not provided, a random password will be generated</p> <code>None</code> <code>client</code> <code>Argilla</code> <p>The client used to interact with Argilla</p> <code>None</code> <p>Returns:</p> Name Type Description <code>User</code> <code>None</code> <p>The initialized user object</p> <p>```</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>def __init__(\n    self,\n    username: Optional[str] = None,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    role: Optional[str] = None,\n    password: Optional[str] = None,\n    client: Optional[\"Argilla\"] = None,\n    id: Optional[UUID] = None,\n    _model: Optional[UserModel] = None,\n) -&gt; None:\n    \"\"\"Initializes a User object with a client and a username\n\n    Parameters:\n        username (str): The username of the user\n        first_name (str): The first name of the user\n        last_name (str): The last name of the user\n        role (str): The role of the user, either 'annotator', admin, or 'owner'\n        password (str): The password of the user. If not provided, a random password will be generated\n        client (Argilla): The client used to interact with Argilla\n\n    Returns:\n        User: The initialized user object\n    ```\n    \"\"\"\n    client = client or Argilla._get_default()\n    super().__init__(client=client, api=client.api.users)\n\n    if _model is None:\n        _model = UserModel(\n            username=username,\n            password=password or self._generate_random_password(),\n            first_name=first_name or username,\n            last_name=last_name,\n            role=role or Role.annotator,\n            id=id,\n        )\n        self.log(f\"Initialized user with username {username}\")\n    self._model = _model\n</code></pre>"},{"location":"reference/argilla_sdk/users/#argilla_sdk.users.User.add_to_workspace","title":"<code>add_to_workspace(workspace)</code>","text":"<p>Adds the user to a workspace. After adding a user to a workspace, it will have access to the datasets in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Workspace</code> <p>The workspace to add the user to.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was added to the workspace.</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>def add_to_workspace(self, workspace: \"Workspace\") -&gt; \"User\":\n    \"\"\"Adds the user to a workspace. After adding a user to a workspace, it will have access to the datasets\n    in the workspace.\n\n    Args:\n        workspace (Workspace): The workspace to add the user to.\n\n    Returns:\n        User: The user that was added to the workspace.\n    \"\"\"\n    self._model = self._api.add_to_workspace(workspace.id, self.id)\n    return self\n</code></pre>"},{"location":"reference/argilla_sdk/users/#argilla_sdk.users.User.create","title":"<code>create()</code>","text":"<p>Creates the user in Argilla. After creating a user, it will be able to log in to the Argilla server.</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was created in Argilla.</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>def create(self) -&gt; \"User\":\n    \"\"\"Creates the user in Argilla. After creating a user, it will be able to log in to the Argilla server.\n\n    Returns:\n        User: The user that was created in Argilla.\n\n    \"\"\"\n    model_create = self.api_model()\n    model = self._api.create(model_create)\n    # The password is not returned in the response\n    model.password = model_create.password\n    self._model = model\n    return self\n</code></pre>"},{"location":"reference/argilla_sdk/users/#argilla_sdk.users.User.delete","title":"<code>delete()</code>","text":"<p>Deletes the user from Argilla. After deleting a user, it will no longer be able to log in to the Argilla server.</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Deletes the user from Argilla. After deleting a user, it will no longer be able to log in to the Argilla server.\"\"\"\n    super().delete()\n    # exists relies on the id, so we need to set it to None\n    self._model = UserModel(username=self.username)\n</code></pre>"},{"location":"reference/argilla_sdk/users/#argilla_sdk.users.User.exists","title":"<code>exists()</code>","text":"<p>Checks if the user exists in Argilla</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user exists, False otherwise.</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Checks if the user exists in Argilla\n\n    Returns:\n        bool: True if the user exists, False otherwise.\n    \"\"\"\n    # TODO - Implement the exist method in the API\n    return self.id is not None\n</code></pre>"},{"location":"reference/argilla_sdk/users/#argilla_sdk.users.User.remove_from_workspace","title":"<code>remove_from_workspace(workspace)</code>","text":"<p>Removes the user from a workspace. After removing a user from a workspace, it will no longer have access to the datasets in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Workspace</code> <p>The workspace to remove the user from.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was removed from the workspace.</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>def remove_from_workspace(self, workspace: \"Workspace\") -&gt; \"User\":\n    \"\"\"Removes the user from a workspace. After removing a user from a workspace, it will no longer have access to\n    the datasets in the workspace.\n\n    Args:\n        workspace (Workspace): The workspace to remove the user from.\n\n    Returns:\n        User: The user that was removed from the workspace.\n\n    \"\"\"\n    self._model = self._api.delete_from_workspace(workspace.id, self.id)\n    return self\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/","title":"<code>rg.Workspace</code>","text":"<p>In Argilla, workspaces are used to organize datasets in to groups. For example, you might have a workspace for each project or team.</p>"},{"location":"reference/argilla_sdk/workspaces/#usage-examples","title":"Usage Examples","text":"<p>To create a new workspace, instantiate the <code>Workspace</code> object with the client and the name:</p> <pre><code>workspace = rg.Workspace(name=\"my_workspace\")\nworkspace.create()\n</code></pre> <p>To retrieve an existing workspace, use the <code>client.workspaces</code> attribute:</p> <pre><code>workspace = client.workspaces(\"my_workspace\")\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/workspaces/#rgworkspace_1","title":"<code>rg.Workspace</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla workspaces. Workspaces are used to organize datasets in the Argilla server.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the workspace.</p> <code>id</code> <code>UUID</code> <p>The ID of the workspace. This is a unique identifier for the workspace in the server.</p> <code>datasets</code> <code>List[Dataset]</code> <p>A list of all datasets in the workspace.</p> <code>users</code> <code>WorkspaceUsers</code> <p>A list of all users in the workspace.</p> Source code in <code>src/argilla_sdk/workspaces/_resource.py</code> <pre><code>class Workspace(Resource):\n    \"\"\"Class for interacting with Argilla workspaces. Workspaces are used to organize datasets in the Argilla server.\n\n    Attributes:\n        name (str): The name of the workspace.\n        id (UUID): The ID of the workspace. This is a unique identifier for the workspace in the server.\n        datasets (List[Dataset]): A list of all datasets in the workspace.\n        users (WorkspaceUsers): A list of all users in the workspace.\n    \"\"\"\n\n    name: Optional[str]\n\n    _api: \"WorkspacesAPI\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        id: Optional[UUID] = None,\n        client: Optional[\"Argilla\"] = None,\n        _model: Optional[WorkspaceModel] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a Workspace object with a client and a name or id\n\n        Parameters:\n            client (Argilla): The client used to interact with Argilla\n            name (str): The name of the workspace\n            id (UUID): The id of the workspace\n            _model (WorkspaceModel): The internal Pydantic model of the workspace from/to the server\n        Returns:\n            Workspace: The initialized workspace object\n        \"\"\"\n        client = client or Argilla._get_default()\n        super().__init__(client=client, api=client.api.workspaces)\n        if _model is None:\n            _model = WorkspaceModel(name=name, id=id)\n        self._model = _model\n\n    def exists(self) -&gt; bool:\n        \"\"\"\n        Checks if the workspace exists in the server\n\n        Returns:\n            bool: True if the workspace exists, False otherwise\n        \"\"\"\n        return self._api.exists(self.id)\n\n    def add_user(self, user: Union[\"User\", str]) -&gt; \"User\":\n        \"\"\"Adds a user to the workspace. After adding a user to the workspace, it will have access to the datasets\n        in the workspace.\n\n        Args:\n            user (Union[User, str]): The user to add to the workspace. Can be a User object or a username.\n\n        Returns:\n            User: The user that was added to the workspace\n        \"\"\"\n        return self.users.add(user)\n\n    def remove_user(self, user: Union[\"User\", str]) -&gt; \"User\":\n        \"\"\"Removes a user from the workspace. After removing a user from the workspace, it will no longer have access\n\n        Args:\n            user (Union[User, str]): The user to remove from the workspace. Can be a User object or a username.\n\n        Returns:\n            User: The user that was removed from the workspace.\n        \"\"\"\n        return self.users.delete(user)\n\n    # TODO: Make this method private\n    def list_datasets(self) -&gt; List[\"Dataset\"]:\n        from argilla_sdk.datasets import Dataset\n\n        datasets = self._client.api.datasets.list(self.id)\n        self.log(f\"Got {len(datasets)} datasets for workspace {self.id}\")\n        return [Dataset.from_model(model=dataset, client=self._client) for dataset in datasets]\n\n    ############################\n    # Properties\n    ############################\n\n    @property\n    def name(self) -&gt; Optional[str]:\n        return self._model.name\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        self._model.name = value\n\n    @property\n    def datasets(self) -&gt; List[\"Dataset\"]:\n        \"\"\"List all datasets in the workspace\n\n        Returns:\n            List[Dataset]: A list of all datasets in the workspace\n        \"\"\"\n        return self.list_datasets()\n\n    @property\n    def users(self) -&gt; \"WorkspaceUsers\":\n        \"\"\"List all users in the workspace\n\n        Returns:\n            WorkspaceUsers: A list of all users in the workspace\n\n        \"\"\"\n        return WorkspaceUsers(workspace=self)\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/#argilla_sdk.workspaces.Workspace.datasets","title":"<code>datasets: List[Dataset]</code>  <code>property</code>","text":"<p>List all datasets in the workspace</p> <p>Returns:</p> Type Description <code>List[Dataset]</code> <p>List[Dataset]: A list of all datasets in the workspace</p>"},{"location":"reference/argilla_sdk/workspaces/#argilla_sdk.workspaces.Workspace.users","title":"<code>users: WorkspaceUsers</code>  <code>property</code>","text":"<p>List all users in the workspace</p> <p>Returns:</p> Name Type Description <code>WorkspaceUsers</code> <code>WorkspaceUsers</code> <p>A list of all users in the workspace</p>"},{"location":"reference/argilla_sdk/workspaces/#argilla_sdk.workspaces.Workspace.__init__","title":"<code>__init__(name=None, id=None, client=None, _model=None)</code>","text":"<p>Initializes a Workspace object with a client and a name or id</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Argilla</code> <p>The client used to interact with Argilla</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the workspace</p> <code>None</code> <code>id</code> <code>UUID</code> <p>The id of the workspace</p> <code>None</code> <code>_model</code> <code>WorkspaceModel</code> <p>The internal Pydantic model of the workspace from/to the server</p> <code>None</code> <p>Returns:     Workspace: The initialized workspace object</p> Source code in <code>src/argilla_sdk/workspaces/_resource.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    id: Optional[UUID] = None,\n    client: Optional[\"Argilla\"] = None,\n    _model: Optional[WorkspaceModel] = None,\n) -&gt; None:\n    \"\"\"Initializes a Workspace object with a client and a name or id\n\n    Parameters:\n        client (Argilla): The client used to interact with Argilla\n        name (str): The name of the workspace\n        id (UUID): The id of the workspace\n        _model (WorkspaceModel): The internal Pydantic model of the workspace from/to the server\n    Returns:\n        Workspace: The initialized workspace object\n    \"\"\"\n    client = client or Argilla._get_default()\n    super().__init__(client=client, api=client.api.workspaces)\n    if _model is None:\n        _model = WorkspaceModel(name=name, id=id)\n    self._model = _model\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/#argilla_sdk.workspaces.Workspace.add_user","title":"<code>add_user(user)</code>","text":"<p>Adds a user to the workspace. After adding a user to the workspace, it will have access to the datasets in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, str]</code> <p>The user to add to the workspace. Can be a User object or a username.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was added to the workspace</p> Source code in <code>src/argilla_sdk/workspaces/_resource.py</code> <pre><code>def add_user(self, user: Union[\"User\", str]) -&gt; \"User\":\n    \"\"\"Adds a user to the workspace. After adding a user to the workspace, it will have access to the datasets\n    in the workspace.\n\n    Args:\n        user (Union[User, str]): The user to add to the workspace. Can be a User object or a username.\n\n    Returns:\n        User: The user that was added to the workspace\n    \"\"\"\n    return self.users.add(user)\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/#argilla_sdk.workspaces.Workspace.exists","title":"<code>exists()</code>","text":"<p>Checks if the workspace exists in the server</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the workspace exists, False otherwise</p> Source code in <code>src/argilla_sdk/workspaces/_resource.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"\n    Checks if the workspace exists in the server\n\n    Returns:\n        bool: True if the workspace exists, False otherwise\n    \"\"\"\n    return self._api.exists(self.id)\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/#argilla_sdk.workspaces.Workspace.remove_user","title":"<code>remove_user(user)</code>","text":"<p>Removes a user from the workspace. After removing a user from the workspace, it will no longer have access</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, str]</code> <p>The user to remove from the workspace. Can be a User object or a username.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was removed from the workspace.</p> Source code in <code>src/argilla_sdk/workspaces/_resource.py</code> <pre><code>def remove_user(self, user: Union[\"User\", str]) -&gt; \"User\":\n    \"\"\"Removes a user from the workspace. After removing a user from the workspace, it will no longer have access\n\n    Args:\n        user (Union[User, str]): The user to remove from the workspace. Can be a User object or a username.\n\n    Returns:\n        User: The user that was removed from the workspace.\n    \"\"\"\n    return self.users.delete(user)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/","title":"<code>rg.Dataset.records</code>","text":""},{"location":"reference/argilla_sdk/datasets/dataset_records/#usage-examples","title":"Usage Examples","text":"<p>In most cases, you will not need to create a <code>DatasetRecords</code> object directly. Instead, you can access it via the <code>Dataset</code> object:</p> <pre><code>dataset.records\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#adding-records-to-a-dataset","title":"Adding records to a dataset","text":"<p>To add records to a dataset, use the <code>add</code> method. Records can be added as dictionaries or as <code>Record</code> objects. Single records can also be added as a dictionary or <code>Record</code>.</p> <pre><code># Add records to a dataset\ndataset.records.add(\n    records=[\n    {\n        \"question\": \"What is the capital of France?\",  # 'question' matches the `rg.TextField` name\n        \"answer\": \"Paris\" # 'answer' matches the `rg.TextQuestion` name\n    },\n    {\n        \"question\": \"What is the capital of Germany?\",\n        \"answer\": \"Berlin\"\n    },\n])\n</code></pre> <p>When adding records from a native datasource, a mapping can be provided to map the keys in the native data structure to the fields and questions in Argilla. The dot notation is used to access suggestions and responses in the records.</p> <pre><code>dataset.records.add(\n    records=[\n        {\"input\": \"What is the capital of France?\", \"output\": \"Paris\"},\n        {\"input\": \"What is the capital of Germany?\", \"output\": \"Berlin\"},\n    ],\n    mapping={\"input\": \"question\", \"output\": \"answer\"}, # Maps 'input' to 'question' and 'output' to 'answer'\n)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#iterating-over-records-in-a-dataset","title":"Iterating over records in a dataset","text":"<p><code>Dataset.records</code> can be used to iterate over records in a dataset from the server. The records will be fetched in batches from the server::</p> <pre><code>for record in dataset.records:\n    print(record)\n\n# Fetch records with suggestions and responses\nfor record in dataset.records(with_suggestions=True, with_responses=True):\n    print(record.suggestions)\n    print(record.responses)\n\n# Filter records by a query and fetch records with vectors\nfor record in dataset.records(query=\"capital\", with_vectors=True):\n    print(record.vectors)\n</code></pre> <p>Check out the <code>rg.Record</code> class reference for more information on the properties and methods available on a record and the <code>rg.Query</code> class reference for more information on the query syntax.</p>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#updating-records-in-a-dataset","title":"Updating records in a dataset","text":"<p>Records can also be updated using the <code>id</code> to identify the records to be updated:</p> <pre><code># Add records to a dataset\ndataset.records.add(\n    records=[\n        {\n            \"id\": \"1\",\n            \"question\": \"What is the capital of France?\",\n            \"answer\": \"F\",\n        },\n        {\n            \"id\": \"2\",\n            \"question\": \"What is the capital of Germany?\",\n            \"answer\": \"Berlin\"\n        },\n    ]\n)\n\n# Update records in a dataset\ndataset.records.update(\n    records=[\n        {\n            \"id\": \"1\",  # matches id used in `Dataset.records.add`\n            \"question\": \"What is the capital of France?\",\n            \"answer\": \"Paris\",\n        }\n    ]\n)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#exporting-records-from-a-dataset","title":"Exporting records from a dataset","text":"<p>Records can also be exported from <code>Dataset.records</code>. Generic python exports include <code>to_dict</code> and <code>to_list</code> methods.</p> <pre><code>dataset.records.to_dict()\n# {\"text\": [\"Hello\", \"World\"], \"label\": [\"greeting\", \"greeting\"]}\n\ndataset.records.to_list()\n# [{\"text\": \"Hello\", \"label\": \"greeting\"}, {\"text\": \"World\", \"label\": \"greeting\"}]\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/datasets/dataset_records/#rgdatasetrecords_1","title":"<code>rg.Dataset.records</code>","text":"<p>             Bases: <code>Iterable[Record]</code>, <code>LoggingMixin</code></p> <p>This class is used to work with records from a dataset and is accessed via <code>Dataset.records</code>. The responsibility of this class is to provide an interface to interact with records in a dataset, by adding, updating, fetching, querying, deleting, and exporting records.</p> <p>Attributes:</p> Name Type Description <code>client</code> <code>Argilla</code> <p>The Argilla client object.</p> <code>dataset</code> <code>Dataset</code> <p>The dataset object.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>class DatasetRecords(Iterable[Record], LoggingMixin):\n    \"\"\"This class is used to work with records from a dataset and is accessed via `Dataset.records`.\n    The responsibility of this class is to provide an interface to interact with records in a dataset,\n    by adding, updating, fetching, querying, deleting, and exporting records.\n\n    Attributes:\n        client (Argilla): The Argilla client object.\n        dataset (Dataset): The dataset object.\n    \"\"\"\n\n    _api: RecordsAPI\n\n    DEFAULT_BATCH_SIZE = 256\n\n    def __init__(self, client: \"Argilla\", dataset: \"Dataset\"):\n        \"\"\"Initializes a DatasetRecords object with a client and a dataset.\n        Args:\n            client: An Argilla client object.\n            dataset: A Dataset object.\n        \"\"\"\n        self.__client = client\n        self.__dataset = dataset\n        self._api = self.__client.api.records\n\n    def __iter__(self):\n        return DatasetRecordsIterator(self.__dataset, self.__client)\n\n    def __call__(\n        self,\n        query: Optional[Union[str, Query]] = None,\n        batch_size: Optional[int] = DEFAULT_BATCH_SIZE,\n        start_offset: int = 0,\n        with_suggestions: bool = True,\n        with_responses: bool = True,\n        with_vectors: Optional[Union[List, bool, str]] = None,\n    ) -&gt; DatasetRecordsIterator:\n        \"\"\"Returns an iterator over the records in the dataset on the server.\n\n        Parameters:\n            query: A string or a Query object to filter the records.\n            batch_size: The number of records to fetch in each batch. The default is 256.\n            start_offset: The offset from which to start fetching records. The default is 0.\n            with_suggestions: Whether to include suggestions in the records. The default is True.\n            with_responses: Whether to include responses in the records. The default is True.\n            with_vectors: A list of vector names to include in the records. The default is None.\n                If a list is provided, only the specified vectors will be included.\n                If True is provided, all vectors will be included.\n\n        Returns:\n            An iterator over the records in the dataset on the server.\n\n        \"\"\"\n        if query and isinstance(query, str):\n            query = Query(query=query)\n\n        if with_vectors:\n            self._validate_vector_names(vector_names=with_vectors)\n\n        return DatasetRecordsIterator(\n            self.__dataset,\n            self.__client,\n            query=query,\n            batch_size=batch_size,\n            start_offset=start_offset,\n            with_suggestions=with_suggestions,\n            with_responses=with_responses,\n            with_vectors=with_vectors,\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.__dataset})\"\n\n    ############################\n    # Public methods\n    ############################\n\n    def add(\n        self,\n        records: Union[dict, List[dict], Record, List[Record], HFDataset],\n        mapping: Optional[Dict[str, str]] = None,\n        user_id: Optional[UUID] = None,\n        batch_size: int = DEFAULT_BATCH_SIZE,\n    ) -&gt; List[Record]:\n        \"\"\"\n        Add new records to a dataset on the server.\n\n        Parameters:\n            records: A dictionary or a list of dictionaries representing the records\n                     to be added to the dataset. Records are defined as dictionaries\n                     with keys corresponding to the fields in the dataset schema.\n            mapping: A dictionary that maps the keys in the records to the fields in the dataset schema.\n            user_id: The user id to be associated with the records. If not provided, the current user id is used.\n            batch_size: The number of records to send in each batch. The default is 256.\n\n        Returns:\n            A list of Record objects representing the added records.\n\n        Examples:\n\n        Add generic records to a dataset as dictionaries:\n\n        \"\"\"\n        record_models = self._ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n        batch_size = self._normalize_batch_size(\n            batch_size=batch_size,\n            records_length=len(record_models),\n            max_value=self._api.MAX_RECORDS_PER_CREATE_BULK,\n        )\n\n        created_records = []\n        for batch in range(0, len(record_models), batch_size):\n            self.log(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n            batch_records = record_models[batch : batch + batch_size]\n            models = self._api.bulk_create(dataset_id=self.__dataset.id, records=batch_records)\n            created_records.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n\n        self.log(\n            message=f\"Added {len(created_records)} records to dataset {self.__dataset.name}\",\n            level=\"info\",\n        )\n\n        return created_records\n\n    def update(\n        self,\n        records: Union[dict, List[dict], Record, List[Record], HFDataset],\n        mapping: Optional[Dict[str, str]] = None,\n        user_id: Optional[UUID] = None,\n        batch_size: int = DEFAULT_BATCH_SIZE,\n    ) -&gt; List[Record]:\n        \"\"\"Update records in a dataset on the server using the provided records\n            and matching based on the external_id or id.\n\n        Parameters:\n            records: A dictionary or a list of dictionaries representing the records\n                     to be updated in the dataset. Records are defined as dictionaries\n                     with keys corresponding to the fields in the dataset schema. Ids or\n                     external_ids should be provided to identify the records to be updated.\n            mapping: A dictionary that maps the keys in the records to the fields in the dataset schema.\n            user_id: The user id to be associated with the records. If not provided, the current user id is used.\n            batch_size: The number of records to send in each batch. The default is 256.\n\n        Returns:\n            A list of Record objects representing the updated records.\n\n        \"\"\"\n        record_models = self._ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n        batch_size = self._normalize_batch_size(\n            batch_size=batch_size,\n            records_length=len(record_models),\n            max_value=self._api.MAX_RECORDS_PER_UPSERT_BULK,\n        )\n\n        created_or_updated = []\n        records_updated = 0\n        for batch in range(0, len(records), batch_size):\n            self.log(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n            batch_records = record_models[batch : batch + batch_size]\n            models, updated = self._api.bulk_upsert(dataset_id=self.__dataset.id, records=batch_records)\n            created_or_updated.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n            records_updated += updated\n\n        records_created = len(created_or_updated) - records_updated\n        self.log(\n            message=f\"Updated {records_updated} records and added {records_created} records to dataset {self.__dataset.name}\",\n            level=\"info\",\n        )\n\n        return created_or_updated\n\n    def to_dict(self, flatten: bool = False, orient: str = \"names\") -&gt; Dict[str, Any]:\n        \"\"\"\n        Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().\n\n        Parameters:\n            flatten (bool): The structure of the exported dictionary.\n                - True: The record fields, metadata, suggestions and responses will be flattened.\n                - False: The record fields, metadata, suggestions and responses will be nested.\n            orient (str): The orientation of the exported dictionary.\n                - \"names\": The keys of the dictionary will be the names of the fields, metadata, suggestions and responses.\n                - \"index\": The keys of the dictionary will be the id of the records.\n        Returns:\n            A dictionary of records.\n\n        \"\"\"\n        records = list(self(with_suggestions=True, with_responses=True))\n        data = GenericIO.to_dict(records=records, flatten=flatten, orient=orient)\n        return data\n\n    def to_list(self, flatten: bool = False) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().\n\n        Parameters:\n            flatten (bool): Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.\n\n        Returns:\n            A list of dictionaries of records.\n        \"\"\"\n        records = list(self(with_suggestions=True, with_responses=True))\n        data = GenericIO.to_list(records=records, flatten=flatten)\n        return data\n\n    def to_json(self, path: Union[Path, str]) -&gt; Path:\n        \"\"\"\n        Export the records to a file on disk.\n\n        Parameters:\n            path (str): The path to the file to save the records.\n\n        Returns:\n            The path to the file where the records were saved.\n\n        \"\"\"\n        records = list(self(with_suggestions=True, with_responses=True))\n        return JsonIO.to_json(records=records, path=path)\n\n    def from_json(self, path: Union[Path, str]) -&gt; \"DatasetRecords\":\n        \"\"\"Creates a DatasetRecords object from a disk path to a JSON file.\n            The JSON file should be defined by `DatasetRecords.to_json`.\n\n        Args:\n            path (str): The path to the file containing the records.\n\n        Returns:\n            DatasetRecords: The DatasetRecords object created from the disk path.\n\n        \"\"\"\n        records = JsonIO._records_from_json(path=path)\n        return self.update(records=records)\n        return self\n\n    def to_datasets(self) -&gt; HFDataset:\n        \"\"\"\n        Export the records to a HFDataset.\n\n        Returns:\n            The dataset containing the records.\n\n        \"\"\"\n        records = list(self(with_suggestions=True, with_responses=True))\n        return HFDatasetsIO.to_datasets(records=records)\n\n    ############################\n    # Private methods\n    ############################\n\n    def _ingest_records(\n        self,\n        records: Union[List[Dict[str, Any]], Dict[str, Any], List[Record], Record, HFDataset],\n        mapping: Optional[Dict[str, str]] = None,\n        user_id: Optional[UUID] = None,\n    ) -&gt; List[RecordModel]:\n        if isinstance(records, (Record, dict)):\n            records = [records]\n        if HFDatasetsIO._is_hf_dataset(dataset=records):\n            records = HFDatasetsIO._record_dicts_from_datasets(dataset=records)\n        if all(map(lambda r: isinstance(r, dict), records)):\n            # Records as flat dicts of values to be matched to questions as suggestion or response\n            records = [self._infer_record_from_mapping(data=r, mapping=mapping, user_id=user_id) for r in records]  # type: ignore\n        elif all(map(lambda r: isinstance(r, Record), records)):\n            for record in records:\n                record.dataset = self.__dataset\n        else:\n            raise ValueError(\n                \"Records should be a dictionary, a list of dictionaries, a Record instance, \"\n                \"a list of Record instances, or `datasets.Dataset`.\"\n            )\n        return [record.api_model() for record in records]\n\n    def _normalize_batch_size(self, batch_size: int, records_length, max_value: int):\n        norm_batch_size = min(batch_size, records_length, max_value)\n\n        if batch_size != norm_batch_size:\n            self.log(\n                message=f\"The provided batch size {batch_size} was normalized. Using value {norm_batch_size}.\",\n                level=\"warning\",\n            )\n\n        return norm_batch_size\n\n    def _validate_vector_names(self, vector_names: Union[List[str], str]) -&gt; None:\n        if not isinstance(vector_names, list):\n            vector_names = [vector_names]\n        for vector_name in vector_names:\n            if isinstance(vector_name, bool):\n                continue\n            if vector_name not in self.__dataset.schema:\n                raise ValueError(f\"Vector field {vector_name} not found in dataset schema.\")\n\n    def _infer_record_from_mapping(\n        self,\n        data: dict,\n        mapping: Optional[Dict[str, str]] = None,\n        user_id: Optional[UUID] = None,\n    ) -&gt; \"Record\":\n        \"\"\"Converts a mapped record dictionary to a Record object for use by the add or update methods.\n        Args:\n            dataset: The dataset object to which the record belongs.\n            data: A dictionary representing the record.\n            mapping: A dictionary mapping source data keys to Argilla fields, questions, and ids.\n            user_id: The user id to associate with the record responses.\n        Returns:\n            A Record object.\n        \"\"\"\n        fields: Dict[str, str] = {}\n        responses: List[Response] = []\n        record_id: Optional[str] = None\n        suggestion_values = defaultdict(dict)\n        vectors: List[Vector] = []\n        metadata: Dict[str, MetadataValue] = {}\n\n        schema = self.__dataset.schema\n\n        for attribute, value in data.items():\n            schema_item = schema.get(attribute)\n            attribute_type = None\n            sub_attribute = None\n\n            # Map source data keys using the mapping\n            if mapping and attribute in mapping:\n                attribute_mapping = mapping.get(attribute)\n                attribute_mapping = attribute_mapping.split(\".\")\n                attribute = attribute_mapping[0]\n                schema_item = schema.get(attribute)\n                if len(attribute_mapping) &gt; 1:\n                    attribute_type = attribute_mapping[1]\n                if len(attribute_mapping) &gt; 2:\n                    sub_attribute = attribute_mapping[2]\n            elif schema_item is mapping is None and attribute != \"id\":\n                warnings.warn(\n                    message=f\"\"\"Record attribute {attribute} is not in the schema so skipping.\n                        Define a mapping to map source data fields to Argilla Fields, Questions, and ids\n                        \"\"\"\n                )\n                continue\n\n            if attribute == \"id\":\n                record_id = value\n                continue\n\n            # Add suggestion values to the suggestions\n            if attribute_type == \"suggestion\":\n                if sub_attribute in [\"score\", \"agent\"]:\n                    suggestion_values[attribute][sub_attribute] = value\n\n                elif sub_attribute is None:\n                    suggestion_values[attribute].update(\n                        {\"value\": value, \"question_name\": attribute, \"question_id\": schema_item.id}\n                    )\n                else:\n                    warnings.warn(\n                        message=f\"Record attribute {sub_attribute} is not a valid suggestion sub_attribute so skipping.\"\n                    )\n                continue\n\n            # Assign the value to question, field, or response based on schema item\n            if isinstance(schema_item, TextField):\n                fields[attribute] = value\n            elif isinstance(schema_item, QuestionPropertyBase) and attribute_type == \"response\":\n                responses.append(Response(question_name=attribute, value=value, user_id=user_id))\n            elif isinstance(schema_item, QuestionPropertyBase) and attribute_type is None:\n                suggestion_values[attribute].update(\n                    {\"value\": value, \"question_name\": attribute, \"question_id\": schema_item.id}\n                )\n            elif isinstance(schema_item, VectorField):\n                vectors.append(Vector(name=attribute, values=value))\n            elif isinstance(schema_item, MetadataPropertyBase):\n                metadata[attribute] = value\n            else:\n                warnings.warn(message=f\"Record attribute {attribute} is not in the schema or mapping so skipping.\")\n                continue\n\n        suggestions = [Suggestion(**suggestion_dict) for suggestion_dict in suggestion_values.values()]\n\n        return Record(\n            id=record_id,\n            fields=fields,\n            suggestions=suggestions,\n            responses=responses,\n            vectors=vectors,\n            metadata=metadata,\n            _dataset=self.__dataset,\n        )\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.__call__","title":"<code>__call__(query=None, batch_size=DEFAULT_BATCH_SIZE, start_offset=0, with_suggestions=True, with_responses=True, with_vectors=None)</code>","text":"<p>Returns an iterator over the records in the dataset on the server.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[Union[str, Query]]</code> <p>A string or a Query object to filter the records.</p> <code>None</code> <code>batch_size</code> <code>Optional[int]</code> <p>The number of records to fetch in each batch. The default is 256.</p> <code>DEFAULT_BATCH_SIZE</code> <code>start_offset</code> <code>int</code> <p>The offset from which to start fetching records. The default is 0.</p> <code>0</code> <code>with_suggestions</code> <code>bool</code> <p>Whether to include suggestions in the records. The default is True.</p> <code>True</code> <code>with_responses</code> <code>bool</code> <p>Whether to include responses in the records. The default is True.</p> <code>True</code> <code>with_vectors</code> <code>Optional[Union[List, bool, str]]</code> <p>A list of vector names to include in the records. The default is None. If a list is provided, only the specified vectors will be included. If True is provided, all vectors will be included.</p> <code>None</code> <p>Returns:</p> Type Description <code>DatasetRecordsIterator</code> <p>An iterator over the records in the dataset on the server.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def __call__(\n    self,\n    query: Optional[Union[str, Query]] = None,\n    batch_size: Optional[int] = DEFAULT_BATCH_SIZE,\n    start_offset: int = 0,\n    with_suggestions: bool = True,\n    with_responses: bool = True,\n    with_vectors: Optional[Union[List, bool, str]] = None,\n) -&gt; DatasetRecordsIterator:\n    \"\"\"Returns an iterator over the records in the dataset on the server.\n\n    Parameters:\n        query: A string or a Query object to filter the records.\n        batch_size: The number of records to fetch in each batch. The default is 256.\n        start_offset: The offset from which to start fetching records. The default is 0.\n        with_suggestions: Whether to include suggestions in the records. The default is True.\n        with_responses: Whether to include responses in the records. The default is True.\n        with_vectors: A list of vector names to include in the records. The default is None.\n            If a list is provided, only the specified vectors will be included.\n            If True is provided, all vectors will be included.\n\n    Returns:\n        An iterator over the records in the dataset on the server.\n\n    \"\"\"\n    if query and isinstance(query, str):\n        query = Query(query=query)\n\n    if with_vectors:\n        self._validate_vector_names(vector_names=with_vectors)\n\n    return DatasetRecordsIterator(\n        self.__dataset,\n        self.__client,\n        query=query,\n        batch_size=batch_size,\n        start_offset=start_offset,\n        with_suggestions=with_suggestions,\n        with_responses=with_responses,\n        with_vectors=with_vectors,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.__init__","title":"<code>__init__(client, dataset)</code>","text":"<p>Initializes a DatasetRecords object with a client and a dataset. Args:     client: An Argilla client object.     dataset: A Dataset object.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def __init__(self, client: \"Argilla\", dataset: \"Dataset\"):\n    \"\"\"Initializes a DatasetRecords object with a client and a dataset.\n    Args:\n        client: An Argilla client object.\n        dataset: A Dataset object.\n    \"\"\"\n    self.__client = client\n    self.__dataset = dataset\n    self._api = self.__client.api.records\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.add","title":"<code>add(records, mapping=None, user_id=None, batch_size=DEFAULT_BATCH_SIZE)</code>","text":"<p>Add new records to a dataset on the server.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Union[dict, List[dict], Record, List[Record], HFDataset]</code> <p>A dictionary or a list of dictionaries representing the records      to be added to the dataset. Records are defined as dictionaries      with keys corresponding to the fields in the dataset schema.</p> required <code>mapping</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary that maps the keys in the records to the fields in the dataset schema.</p> <code>None</code> <code>user_id</code> <code>Optional[UUID]</code> <p>The user id to be associated with the records. If not provided, the current user id is used.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of records to send in each batch. The default is 256.</p> <code>DEFAULT_BATCH_SIZE</code> <p>Returns:</p> Type Description <code>List[Record]</code> <p>A list of Record objects representing the added records.</p> <p>Examples:</p> <p>Add generic records to a dataset as dictionaries:</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def add(\n    self,\n    records: Union[dict, List[dict], Record, List[Record], HFDataset],\n    mapping: Optional[Dict[str, str]] = None,\n    user_id: Optional[UUID] = None,\n    batch_size: int = DEFAULT_BATCH_SIZE,\n) -&gt; List[Record]:\n    \"\"\"\n    Add new records to a dataset on the server.\n\n    Parameters:\n        records: A dictionary or a list of dictionaries representing the records\n                 to be added to the dataset. Records are defined as dictionaries\n                 with keys corresponding to the fields in the dataset schema.\n        mapping: A dictionary that maps the keys in the records to the fields in the dataset schema.\n        user_id: The user id to be associated with the records. If not provided, the current user id is used.\n        batch_size: The number of records to send in each batch. The default is 256.\n\n    Returns:\n        A list of Record objects representing the added records.\n\n    Examples:\n\n    Add generic records to a dataset as dictionaries:\n\n    \"\"\"\n    record_models = self._ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n    batch_size = self._normalize_batch_size(\n        batch_size=batch_size,\n        records_length=len(record_models),\n        max_value=self._api.MAX_RECORDS_PER_CREATE_BULK,\n    )\n\n    created_records = []\n    for batch in range(0, len(record_models), batch_size):\n        self.log(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n        batch_records = record_models[batch : batch + batch_size]\n        models = self._api.bulk_create(dataset_id=self.__dataset.id, records=batch_records)\n        created_records.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n\n    self.log(\n        message=f\"Added {len(created_records)} records to dataset {self.__dataset.name}\",\n        level=\"info\",\n    )\n\n    return created_records\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.from_json","title":"<code>from_json(path)</code>","text":"<p>Creates a DatasetRecords object from a disk path to a JSON file.     The JSON file should be defined by <code>DatasetRecords.to_json</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file containing the records.</p> required <p>Returns:</p> Name Type Description <code>DatasetRecords</code> <code>DatasetRecords</code> <p>The DatasetRecords object created from the disk path.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def from_json(self, path: Union[Path, str]) -&gt; \"DatasetRecords\":\n    \"\"\"Creates a DatasetRecords object from a disk path to a JSON file.\n        The JSON file should be defined by `DatasetRecords.to_json`.\n\n    Args:\n        path (str): The path to the file containing the records.\n\n    Returns:\n        DatasetRecords: The DatasetRecords object created from the disk path.\n\n    \"\"\"\n    records = JsonIO._records_from_json(path=path)\n    return self.update(records=records)\n    return self\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.to_datasets","title":"<code>to_datasets()</code>","text":"<p>Export the records to a HFDataset.</p> <p>Returns:</p> Type Description <code>HFDataset</code> <p>The dataset containing the records.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def to_datasets(self) -&gt; HFDataset:\n    \"\"\"\n    Export the records to a HFDataset.\n\n    Returns:\n        The dataset containing the records.\n\n    \"\"\"\n    records = list(self(with_suggestions=True, with_responses=True))\n    return HFDatasetsIO.to_datasets(records=records)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.to_dict","title":"<code>to_dict(flatten=False, orient='names')</code>","text":"<p>Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().</p> <p>Parameters:</p> Name Type Description Default <code>flatten</code> <code>bool</code> <p>The structure of the exported dictionary. - True: The record fields, metadata, suggestions and responses will be flattened. - False: The record fields, metadata, suggestions and responses will be nested.</p> <code>False</code> <code>orient</code> <code>str</code> <p>The orientation of the exported dictionary. - \"names\": The keys of the dictionary will be the names of the fields, metadata, suggestions and responses. - \"index\": The keys of the dictionary will be the id of the records.</p> <code>'names'</code> <p>Returns:     A dictionary of records.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def to_dict(self, flatten: bool = False, orient: str = \"names\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().\n\n    Parameters:\n        flatten (bool): The structure of the exported dictionary.\n            - True: The record fields, metadata, suggestions and responses will be flattened.\n            - False: The record fields, metadata, suggestions and responses will be nested.\n        orient (str): The orientation of the exported dictionary.\n            - \"names\": The keys of the dictionary will be the names of the fields, metadata, suggestions and responses.\n            - \"index\": The keys of the dictionary will be the id of the records.\n    Returns:\n        A dictionary of records.\n\n    \"\"\"\n    records = list(self(with_suggestions=True, with_responses=True))\n    data = GenericIO.to_dict(records=records, flatten=flatten, orient=orient)\n    return data\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.to_json","title":"<code>to_json(path)</code>","text":"<p>Export the records to a file on disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file to save the records.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the file where the records were saved.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def to_json(self, path: Union[Path, str]) -&gt; Path:\n    \"\"\"\n    Export the records to a file on disk.\n\n    Parameters:\n        path (str): The path to the file to save the records.\n\n    Returns:\n        The path to the file where the records were saved.\n\n    \"\"\"\n    records = list(self(with_suggestions=True, with_responses=True))\n    return JsonIO.to_json(records=records, path=path)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.to_list","title":"<code>to_list(flatten=False)</code>","text":"<p>Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().</p> <p>Parameters:</p> Name Type Description Default <code>flatten</code> <code>bool</code> <p>Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of dictionaries of records.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def to_list(self, flatten: bool = False) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().\n\n    Parameters:\n        flatten (bool): Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.\n\n    Returns:\n        A list of dictionaries of records.\n    \"\"\"\n    records = list(self(with_suggestions=True, with_responses=True))\n    data = GenericIO.to_list(records=records, flatten=flatten)\n    return data\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.update","title":"<code>update(records, mapping=None, user_id=None, batch_size=DEFAULT_BATCH_SIZE)</code>","text":"<p>Update records in a dataset on the server using the provided records     and matching based on the external_id or id.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Union[dict, List[dict], Record, List[Record], HFDataset]</code> <p>A dictionary or a list of dictionaries representing the records      to be updated in the dataset. Records are defined as dictionaries      with keys corresponding to the fields in the dataset schema. Ids or      external_ids should be provided to identify the records to be updated.</p> required <code>mapping</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary that maps the keys in the records to the fields in the dataset schema.</p> <code>None</code> <code>user_id</code> <code>Optional[UUID]</code> <p>The user id to be associated with the records. If not provided, the current user id is used.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of records to send in each batch. The default is 256.</p> <code>DEFAULT_BATCH_SIZE</code> <p>Returns:</p> Type Description <code>List[Record]</code> <p>A list of Record objects representing the updated records.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def update(\n    self,\n    records: Union[dict, List[dict], Record, List[Record], HFDataset],\n    mapping: Optional[Dict[str, str]] = None,\n    user_id: Optional[UUID] = None,\n    batch_size: int = DEFAULT_BATCH_SIZE,\n) -&gt; List[Record]:\n    \"\"\"Update records in a dataset on the server using the provided records\n        and matching based on the external_id or id.\n\n    Parameters:\n        records: A dictionary or a list of dictionaries representing the records\n                 to be updated in the dataset. Records are defined as dictionaries\n                 with keys corresponding to the fields in the dataset schema. Ids or\n                 external_ids should be provided to identify the records to be updated.\n        mapping: A dictionary that maps the keys in the records to the fields in the dataset schema.\n        user_id: The user id to be associated with the records. If not provided, the current user id is used.\n        batch_size: The number of records to send in each batch. The default is 256.\n\n    Returns:\n        A list of Record objects representing the updated records.\n\n    \"\"\"\n    record_models = self._ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n    batch_size = self._normalize_batch_size(\n        batch_size=batch_size,\n        records_length=len(record_models),\n        max_value=self._api.MAX_RECORDS_PER_UPSERT_BULK,\n    )\n\n    created_or_updated = []\n    records_updated = 0\n    for batch in range(0, len(records), batch_size):\n        self.log(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n        batch_records = record_models[batch : batch + batch_size]\n        models, updated = self._api.bulk_upsert(dataset_id=self.__dataset.id, records=batch_records)\n        created_or_updated.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n        records_updated += updated\n\n    records_created = len(created_or_updated) - records_updated\n    self.log(\n        message=f\"Updated {records_updated} records and added {records_created} records to dataset {self.__dataset.name}\",\n        level=\"info\",\n    )\n\n    return created_or_updated\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/","title":"<code>rg.Dataset</code>","text":"<p><code>Dataset</code> is a class that represents a collection of records. It is used to store and manage records in Argilla.</p>"},{"location":"reference/argilla_sdk/datasets/datasets/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/datasets/datasets/#creating-a-dataset","title":"Creating a Dataset","text":"<p>To create a new dataset you need to define its name and settings. Optional parameters are <code>workspace</code> and <code>client</code>, if you want to create the dataset in a specific workspace or on a specific Argilla instance.</p> <pre><code>dataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=rg.Settings(\n        fields=[\n            rg.TextField(name=\"text\"),\n        ],\n        questions=[\n            rg.TextQuestion(name=\"response\"),\n        ],\n    ),\n)\ndataset.create()\n</code></pre> <p>For a detail guide of the dataset creation and publication process, see the Dataset how to guide.</p>"},{"location":"reference/argilla_sdk/datasets/datasets/#retrieving-an-existing-dataset","title":"Retrieving an existing Dataset","text":"<p>To retrieve an existing dataset, use <code>client.datasets(\"my_dataset\")</code> instead.</p> <pre><code>dataset = client.datasets(\"my_dataset\")\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/datasets/datasets/#rgdataset_1","title":"<code>rg.Dataset</code>","text":"<p>             Bases: <code>Resource</code>, <code>DiskImportExportMixin</code></p> <p>Class for interacting with Argilla Datasets</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the dataset.</p> <code>records</code> <code>DatasetRecords</code> <p>The records object for the dataset. Used to interact with the records of the dataset by iterating, searching, etc.</p> <code>settings</code> <code>Settings</code> <p>The settings object of the dataset. Used to configure the dataset with fields, questions, guidelines, etc.</p> <code>fields</code> <code>list</code> <p>The fields of the dataset, for example the <code>rg.TextField</code> of the dataset. Defined in the settings.</p> <code>questions</code> <code>list</code> <p>The questions of the dataset defined in the settings. For example, the <code>rg.TextQuestion</code> that you want labelers to answer.</p> <code>guidelines</code> <code>str</code> <p>The guidelines of the dataset defined in the settings. Used to provide instructions to labelers.</p> <code>allow_extra_metadata</code> <code>bool</code> <p>True if extra metadata is allowed, False otherwise.</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>class Dataset(Resource, DiskImportExportMixin):\n    \"\"\"Class for interacting with Argilla Datasets\n\n    Attributes:\n        name: Name of the dataset.\n        records (DatasetRecords): The records object for the dataset. Used to interact with the records of the dataset by iterating, searching, etc.\n        settings (Settings): The settings object of the dataset. Used to configure the dataset with fields, questions, guidelines, etc.\n        fields (list): The fields of the dataset, for example the `rg.TextField` of the dataset. Defined in the settings.\n        questions (list): The questions of the dataset defined in the settings. For example, the `rg.TextQuestion` that you want labelers to answer.\n        guidelines (str): The guidelines of the dataset defined in the settings. Used to provide instructions to labelers.\n        allow_extra_metadata (bool): True if extra metadata is allowed, False otherwise.\n    \"\"\"\n\n    name: str\n    id: Optional[UUID]\n\n    _api: \"DatasetsAPI\"\n    _model: \"DatasetModel\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        workspace: Optional[Union[\"Workspace\", str]] = None,\n        settings: Optional[Settings] = None,\n        client: Optional[\"Argilla\"] = None,\n        _model: Optional[DatasetModel] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a new Argilla Dataset object with the given parameters.\n\n        Parameters:\n            name (str): Name of the dataset. Replaced by random UUID if not assigned.\n            workspace (UUID): Workspace of the dataset. Default is the first workspace found in the server.\n            settings (Settings): Settings class to be used to configure the dataset.\n            client (Argilla): Instance of Argilla to connect with the server. Default is the default client.\n            _model (DatasetModel): Model of the dataset. Used to create the dataset from an existing model.\n        \"\"\"\n        client = client or Argilla._get_default()\n        super().__init__(client=client, api=client.api.datasets)\n        if name is None:\n            name = f\"dataset_{uuid4()}\"\n            self.log(f\"Settings dataset name to unique UUID: {name}\")\n\n        self.workspace_id = (\n            _model.workspace_id\n            if _model and _model.workspace_id\n            else self.__workspace_id_from_name(workspace=workspace)\n        )\n        self._model = _model or DatasetModel(\n            name=name,\n            workspace_id=self._convert_optional_uuid(uuid=self.workspace_id),\n        )\n        self._settings = self.__configure_settings_for_dataset(settings=settings)\n        self.__records = DatasetRecords(client=self._client, dataset=self)\n\n    #####################\n    #  Properties       #\n    #####################\n\n    @property\n    def name(self) -&gt; str:\n        return self._model.name\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        self._model.name = value\n\n    @property\n    def records(self) -&gt; \"DatasetRecords\":\n        return self.__records\n\n    @property\n    def settings(self) -&gt; Settings:\n        if self.__is_published() and self._settings.is_outdated:\n            self._settings.get()\n        return self._settings\n\n    @settings.setter\n    def settings(self, value: Settings) -&gt; None:\n        self._settings = self.__configure_settings_for_dataset(settings=value)\n\n    @property\n    def fields(self) -&gt; list:\n        return self.settings.fields\n\n    @property\n    def questions(self) -&gt; list:\n        return self.settings.questions\n\n    @property\n    def guidelines(self) -&gt; str:\n        return self.settings.guidelines\n\n    @guidelines.setter\n    def guidelines(self, value: str) -&gt; None:\n        self.settings.guidelines = value\n\n    @property\n    def allow_extra_metadata(self) -&gt; bool:\n        return self.settings.allow_extra_metadata\n\n    @allow_extra_metadata.setter\n    def allow_extra_metadata(self, value: bool) -&gt; None:\n        self.settings.allow_extra_metadata = value\n\n    @property\n    def schema(self) -&gt; dict:\n        return self.settings.schema\n\n    #####################\n    #  Core methods     #\n    #####################\n\n    def exists(self) -&gt; bool:\n        \"\"\"Checks if the dataset exists on the server\n\n        Returns:\n            bool: True if the dataset exists, False otherwise\n        \"\"\"\n        return self.id and self._api.exists(self.id)\n\n    def create(self) -&gt; \"Dataset\":\n        \"\"\"Creates the dataset on the server with the `Settings` configuration.\n\n        Returns:\n            Dataset: The created dataset object.\n        \"\"\"\n        super().create()\n        try:\n            return self._publish()\n        except Exception as e:\n            self.log(message=f\"Error creating dataset: {e}\", level=\"error\")\n            self.__rollback_dataset_creation()\n            raise SettingsError from e\n\n    @classmethod\n    def from_model(cls, model: DatasetModel, client: \"Argilla\") -&gt; \"Dataset\":\n        return cls(client=client, _model=model)\n\n    #####################\n    #  Utility methods  #\n    #####################\n\n    def _publish(self) -&gt; \"Dataset\":\n        self.settings.validate()\n        self._settings.create()\n        self._api.publish(dataset_id=self._model.id)\n\n        return self.get()  # type: ignore\n\n    def __configure_settings_for_dataset(\n        self,\n        settings: Optional[Settings] = None,\n    ) -&gt; Settings:\n        if settings is None:\n            settings = Settings(_dataset=self)\n            warnings.warn(\n                message=\"Settings not provided. Using empty settings for the dataset. \\\n                    Define the settings before creating the dataset.\",\n                stacklevel=2,\n            )\n        else:\n            settings.dataset = self\n        return settings\n\n    def __workspace_id_from_name(self, workspace: Optional[Union[\"Workspace\", str]]) -&gt; UUID:\n        if workspace is None:\n            available_workspaces = self._client.workspaces\n            ws = available_workspaces[0]  # type: ignore\n            warnings.warn(f\"Workspace not provided. Using default workspace: {ws.name} id: {ws.id}\")\n        elif isinstance(workspace, str):\n            available_workspace_names = [ws.name for ws in self._client.workspaces]\n            ws = self._client.workspaces(workspace)\n            if not ws.exists():\n                self.log(\n                    message=f\"Workspace with name {workspace} not found. \\\n                        Available workspaces: {available_workspace_names}\",\n                    level=\"error\",\n                )\n                raise NotFoundError()\n        else:\n            ws = workspace\n        return ws.id\n\n    def __rollback_dataset_creation(self):\n        if self.exists() and not self.__is_published():\n            self.delete()\n\n    def __is_published(self) -&gt; bool:\n        return self.exists() and self._model.status == \"ready\"\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.__init__","title":"<code>__init__(name=None, workspace=None, settings=None, client=None, _model=None)</code>","text":"<p>Initializes a new Argilla Dataset object with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dataset. Replaced by random UUID if not assigned.</p> <code>None</code> <code>workspace</code> <code>UUID</code> <p>Workspace of the dataset. Default is the first workspace found in the server.</p> <code>None</code> <code>settings</code> <code>Settings</code> <p>Settings class to be used to configure the dataset.</p> <code>None</code> <code>client</code> <code>Argilla</code> <p>Instance of Argilla to connect with the server. Default is the default client.</p> <code>None</code> <code>_model</code> <code>DatasetModel</code> <p>Model of the dataset. Used to create the dataset from an existing model.</p> <code>None</code> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    workspace: Optional[Union[\"Workspace\", str]] = None,\n    settings: Optional[Settings] = None,\n    client: Optional[\"Argilla\"] = None,\n    _model: Optional[DatasetModel] = None,\n) -&gt; None:\n    \"\"\"Initializes a new Argilla Dataset object with the given parameters.\n\n    Parameters:\n        name (str): Name of the dataset. Replaced by random UUID if not assigned.\n        workspace (UUID): Workspace of the dataset. Default is the first workspace found in the server.\n        settings (Settings): Settings class to be used to configure the dataset.\n        client (Argilla): Instance of Argilla to connect with the server. Default is the default client.\n        _model (DatasetModel): Model of the dataset. Used to create the dataset from an existing model.\n    \"\"\"\n    client = client or Argilla._get_default()\n    super().__init__(client=client, api=client.api.datasets)\n    if name is None:\n        name = f\"dataset_{uuid4()}\"\n        self.log(f\"Settings dataset name to unique UUID: {name}\")\n\n    self.workspace_id = (\n        _model.workspace_id\n        if _model and _model.workspace_id\n        else self.__workspace_id_from_name(workspace=workspace)\n    )\n    self._model = _model or DatasetModel(\n        name=name,\n        workspace_id=self._convert_optional_uuid(uuid=self.workspace_id),\n    )\n    self._settings = self.__configure_settings_for_dataset(settings=settings)\n    self.__records = DatasetRecords(client=self._client, dataset=self)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.create","title":"<code>create()</code>","text":"<p>Creates the dataset on the server with the <code>Settings</code> configuration.</p> <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>The created dataset object.</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def create(self) -&gt; \"Dataset\":\n    \"\"\"Creates the dataset on the server with the `Settings` configuration.\n\n    Returns:\n        Dataset: The created dataset object.\n    \"\"\"\n    super().create()\n    try:\n        return self._publish()\n    except Exception as e:\n        self.log(message=f\"Error creating dataset: {e}\", level=\"error\")\n        self.__rollback_dataset_creation()\n        raise SettingsError from e\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.exists","title":"<code>exists()</code>","text":"<p>Checks if the dataset exists on the server</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the dataset exists, False otherwise</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Checks if the dataset exists on the server\n\n    Returns:\n        bool: True if the dataset exists, False otherwise\n    \"\"\"\n    return self.id and self._api.exists(self.id)\n</code></pre>"},{"location":"reference/argilla_sdk/records/metadata/","title":"<code>metadata</code>","text":"<p>Metadata in argilla is a dictionary that can be attached to a record. It is used to store additional information about the record that is not part of the record's fields or responses. For example, the source of the record, the date it was created, or any other information that is relevant to the record. Metadata can be added to a record directly or as valules within a dictionary.</p>"},{"location":"reference/argilla_sdk/records/metadata/#usage-examples","title":"Usage Examples","text":"<p>To use metadata within a dataset, you must define a metadata property in the dataset settings. The metadata property is a list of metadata properties that can be attached to a record. The following example demonstrates how to add metadata to a dataset and how to access metadata from a record object:</p> <pre><code>import argilla_sdk as rg\n\ndataset = Dataset(\n    name=\"dataset_with_metadata\",\n    settings=Settings(\n        fields=[TextField(name=\"text\")],\n        questions=[LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])],\n        metadata=[\n            rg.TermsMetadataProperty(name=\"category\", options=[\"A\", \"B\", \"C\"]),\n        ],\n    ),\n)\ndataset.create()\n</code></pre> <p>Then, you can add records to the dataset with metadata that corresponds to the metadata property defined in the dataset settings:</p> <pre><code>dataset_with_metadata.records.add(\n    [\n        {\"text\": \"text\", \"label\": \"positive\", \"category\": \"A\"},\n        {\"text\": \"text\", \"label\": \"negative\", \"category\": \"B\"},\n    ]\n)\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/","title":"<code>rg.Record</code>","text":"<p>The <code>Record</code> object is used to represent a single record in Argilla. It contains fields, suggestions, responses, metadata, and vectors.</p>"},{"location":"reference/argilla_sdk/records/records/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/records/records/#creating-a-record","title":"Creating a Record","text":"<p>To add records, you can pass dictionaries to the <code>Dataset.records.add</code> method. Argilla will instantiate the <code>Record</code> class based on the input data and <code>mapping</code> property. The input data keys must match the names in <code>rg.Settings</code> object, or be mapped via the dictionary passed to the <code>mapping</code> parameter.</p> <pre><code>dataset.records.add(\n    records=[\n    {\n        \"question\": \"What is the capital of France?\",\n        \"answer\": \"Paris\"\n    },\n])\n</code></pre> <p>You can also create <code>Record</code> objects directly and pass them to the same method.</p> <pre><code>records = [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            responses=[rg.Response(\"label\", \"positive\", user_id=user_id)],\n        ),\n    ]\ndataset.records.add(records=records)\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#accessing-record-attributes","title":"Accessing Record Attributes","text":"<p>The <code>Record</code> object has suggestions, responses, metadata, and vectors attributes that can be accessed directly whilst iterating over records in a dataset.</p> <pre><code>for record in dataset.records(\n    with_suggestions=True,\n    with_responses=True,\n    with_metadata=True,\n    with_vectors=True\n    ):\n    print(record.suggestions)\n    print(record.responses)\n    print(record.metadata)\n    print(record.vectors)\n</code></pre> <p>Record properties can also be updated whilst iterating over records in a dataset.</p> <pre><code>for record in dataset.records(with_metadata=True):\n    record.metadata = {\"department\": \"toys\"}\n</code></pre> <p>For changes to take effect, the user must call the <code>update</code> method on the <code>Dataset</code> object.</p>"},{"location":"reference/argilla_sdk/records/records/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/records/records/#rgrecord_1","title":"<code>rg.Record</code>","text":"<p>             Bases: <code>Resource</code></p> <p>The class for interacting with Argilla Records. A <code>Record</code> is a single sample in a dataset. Records receives feedback in the form of responses and suggestions. Records contain fields, metadata, and vectors.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Union[str, UUID]</code> <p>The id of the record.</p> <code>fields</code> <code>RecordFields</code> <p>The fields of the record.</p> <code>metadata</code> <code>RecordMetadata</code> <p>The metadata of the record.</p> <code>vectors</code> <code>RecordVectors</code> <p>The vectors of the record.</p> <code>responses</code> <code>RecordResponses</code> <p>The responses of the record.</p> <code>suggestions</code> <code>RecordSuggestions</code> <p>The suggestions of the record.</p> <code>dataset</code> <code>Dataset</code> <p>The dataset to which the record belongs.</p> <code>_server_id</code> <code>UUID</code> <p>An id for the record generated by the Argilla server.</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>class Record(Resource):\n    \"\"\"The class for interacting with Argilla Records. A `Record` is a single sample\n    in a dataset. Records receives feedback in the form of responses and suggestions.\n    Records contain fields, metadata, and vectors.\n\n    Attributes:\n        id (Union[str, UUID]): The id of the record.\n        fields (RecordFields): The fields of the record.\n        metadata (RecordMetadata): The metadata of the record.\n        vectors (RecordVectors): The vectors of the record.\n        responses (RecordResponses): The responses of the record.\n        suggestions (RecordSuggestions): The suggestions of the record.\n        dataset (Dataset): The dataset to which the record belongs.\n        _server_id (UUID): An id for the record generated by the Argilla server.\n    \"\"\"\n\n    _model: RecordModel\n\n    def __init__(\n        self,\n        id: Optional[Union[UUID, str]] = None,\n        fields: Dict[str, Union[str, None]] = None,\n        metadata: Optional[Dict[str, MetadataValue]] = None,\n        vectors: Optional[List[Vector]] = None,\n        responses: Optional[List[Response]] = None,\n        suggestions: Optional[List[Suggestion]] = None,\n        _server_id: Optional[UUID] = None,\n        _dataset: Optional[\"Dataset\"] = None,\n    ):\n        \"\"\"Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id.\n        Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions\n        and passed to Dataset.DatasetRecords.add() as a list of dictionaries.\n\n        Args:\n            id: An id for the record. If not provided, a UUID will be generated.\n            fields: A dictionary of fields for the record.\n            metadata: A dictionary of metadata for the record.\n            vectors: A dictionary of vectors for the record.\n            responses: A list of Response objects for the record.\n            suggestions: A list of Suggestion objects for the record.\n            _server_id: An id for the record. (Read-only and set by the server)\n            _dataset: The dataset object to which the record belongs.\n        \"\"\"\n        self._dataset = _dataset\n\n        self._model = RecordModel(\n            fields=fields,\n            external_id=id or uuid4(),\n            id=_server_id,\n        )\n        # TODO: All this code blocks could be define as property setters\n        # Initialize the fields\n        self.__fields = RecordFields(fields=self._model.fields)\n        # Initialize the vectors\n        self.__vectors = RecordVectors(vectors=vectors, record=self)\n        # Initialize the metadata\n        self.__metadata = RecordMetadata(metadata=metadata)\n        self.__responses = RecordResponses(responses=responses, record=self)\n        self.__suggestions = RecordSuggestions(suggestions=suggestions, record=self)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"Record(id={self.id},fields={self.fields},metadata={self.metadata},\"\n            f\"suggestions={self.suggestions},responses={self.responses})\"\n        )\n\n    ############################\n    # Properties\n    ############################\n\n    @property\n    def id(self) -&gt; str:\n        return self._model.external_id\n\n    @id.setter\n    def id(self, value: str) -&gt; None:\n        self._model.external_id = value\n\n    @property\n    def dataset(self) -&gt; \"Dataset\":\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, value: \"Dataset\") -&gt; None:\n        self._dataset = value\n\n    @property\n    def fields(self) -&gt; \"RecordFields\":\n        return self.__fields\n\n    @property\n    def responses(self) -&gt; \"RecordResponses\":\n        return self.__responses\n\n    @property\n    def suggestions(self) -&gt; \"RecordSuggestions\":\n        return self.__suggestions\n\n    @property\n    def metadata(self) -&gt; \"RecordMetadata\":\n        return self.__metadata\n\n    @property\n    def vectors(self) -&gt; \"RecordVectors\":\n        return self.__vectors\n\n    @property\n    def _server_id(self) -&gt; Optional[UUID]:\n        return self._model.id\n\n    ############################\n    # Public methods\n    ############################\n\n    def api_model(self) -&gt; RecordModel:\n        return RecordModel(\n            id=self._model.id,\n            external_id=self._model.external_id,\n            fields=self.fields.to_dict(),\n            metadata=self.metadata.models,\n            vectors=self.vectors.models,\n            responses=self.responses.api_models(),\n            suggestions=self.suggestions.api_models(),\n        )\n\n    def serialize(self) -&gt; Dict[str, Any]:\n        \"\"\"Serializes the Record to a dictionary for interaction with the API\"\"\"\n        serialized_model = self._model.model_dump()\n        serialized_suggestions = [suggestion.serialize() for suggestion in self.__suggestions]\n        serialized_responses = [response.serialize() for response in self.__responses]\n        serialized_model[\"responses\"] = serialized_responses\n        serialized_model[\"suggestions\"] = serialized_suggestions\n        return serialized_model\n\n    def to_dict(self) -&gt; Dict[str, Dict]:\n        \"\"\"Converts a Record object to a dictionary for export.\n        Returns:\n            A dictionary representing the record where the keys are \"fields\",\n            \"metadata\", \"suggestions\", and \"responses\". Each field and question is\n            represented as a key-value pair in the dictionary of the respective key. i.e.\n            `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},\n        \"\"\"\n        fields = self.fields.to_dict()\n        metadata = dict(self.metadata)\n        suggestions = self.suggestions.to_dict()\n        responses = self.responses.to_dict()\n        vectors = self.vectors.to_dict()\n        return {\n            \"id\": self.id,\n            \"fields\": fields,\n            \"metadata\": metadata,\n            \"suggestions\": suggestions,\n            \"responses\": responses,\n            \"vectors\": vectors,\n            \"_server_id\": str(self._model.id) if self._model.id else None,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Dict], dataset: Optional[\"Dataset\"] = None) -&gt; \"Record\":\n        \"\"\"Converts a dictionary to a Record object.\n        Args:\n            data: A dictionary representing the record.\n            dataset: The dataset object to which the record belongs.\n        Returns:\n            A Record object.\n        \"\"\"\n        fields = data.get(\"fields\", {})\n        metadata = data.get(\"metadata\", {})\n        suggestions = data.get(\"suggestions\", {})\n        responses = data.get(\"responses\", {})\n        vectors = data.get(\"vectors\", {})\n        record_id = data.get(\"id\", None)\n        _server_id = data.get(\"_server_id\", None)\n\n        suggestions = [Suggestion(question_name=question_name, **value) for question_name, value in suggestions.items()]\n        responses = [\n            Response(question_name=question_name, **value)\n            for question_name, _responses in responses.items()\n            for value in _responses\n        ]\n        vectors = [Vector(name=vector_name, values=values) for vector_name, values in vectors.items()]\n\n        return cls(\n            id=record_id,\n            fields=fields,\n            suggestions=suggestions,\n            responses=responses,\n            vectors=vectors,\n            metadata=metadata,\n            _dataset=dataset,\n            _server_id=_server_id,\n        )\n\n    @classmethod\n    def from_model(cls, model: RecordModel, dataset: \"Dataset\") -&gt; \"Record\":\n        \"\"\"Converts a RecordModel object to a Record object.\n        Args:\n            model: A RecordModel object.\n            dataset: The dataset object to which the record belongs.\n        Returns:\n            A Record object.\n        \"\"\"\n        return cls(\n            id=model.external_id,\n            fields=model.fields,\n            metadata={meta.name: meta.value for meta in model.metadata},\n            vectors=[Vector.from_model(model=vector) for vector in model.vectors],\n            # Responses and their models are not aligned 1-1.\n            responses=[\n                response\n                for response_model in model.responses\n                for response in UserResponse.from_model(response_model, dataset=dataset)\n            ],\n            suggestions=[Suggestion.from_model(model=suggestion, dataset=dataset) for suggestion in model.suggestions],\n            _dataset=dataset,\n            _server_id=model.id,\n        )\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.__init__","title":"<code>__init__(id=None, fields=None, metadata=None, vectors=None, responses=None, suggestions=None, _server_id=None, _dataset=None)</code>","text":"<p>Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id. Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions and passed to Dataset.DatasetRecords.add() as a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Optional[Union[UUID, str]]</code> <p>An id for the record. If not provided, a UUID will be generated.</p> <code>None</code> <code>fields</code> <code>Dict[str, Union[str, None]]</code> <p>A dictionary of fields for the record.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, MetadataValue]]</code> <p>A dictionary of metadata for the record.</p> <code>None</code> <code>vectors</code> <code>Optional[List[Vector]]</code> <p>A dictionary of vectors for the record.</p> <code>None</code> <code>responses</code> <code>Optional[List[Response]]</code> <p>A list of Response objects for the record.</p> <code>None</code> <code>suggestions</code> <code>Optional[List[Suggestion]]</code> <p>A list of Suggestion objects for the record.</p> <code>None</code> <code>_server_id</code> <code>Optional[UUID]</code> <p>An id for the record. (Read-only and set by the server)</p> <code>None</code> <code>_dataset</code> <code>Optional[Dataset]</code> <p>The dataset object to which the record belongs.</p> <code>None</code> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>def __init__(\n    self,\n    id: Optional[Union[UUID, str]] = None,\n    fields: Dict[str, Union[str, None]] = None,\n    metadata: Optional[Dict[str, MetadataValue]] = None,\n    vectors: Optional[List[Vector]] = None,\n    responses: Optional[List[Response]] = None,\n    suggestions: Optional[List[Suggestion]] = None,\n    _server_id: Optional[UUID] = None,\n    _dataset: Optional[\"Dataset\"] = None,\n):\n    \"\"\"Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id.\n    Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions\n    and passed to Dataset.DatasetRecords.add() as a list of dictionaries.\n\n    Args:\n        id: An id for the record. If not provided, a UUID will be generated.\n        fields: A dictionary of fields for the record.\n        metadata: A dictionary of metadata for the record.\n        vectors: A dictionary of vectors for the record.\n        responses: A list of Response objects for the record.\n        suggestions: A list of Suggestion objects for the record.\n        _server_id: An id for the record. (Read-only and set by the server)\n        _dataset: The dataset object to which the record belongs.\n    \"\"\"\n    self._dataset = _dataset\n\n    self._model = RecordModel(\n        fields=fields,\n        external_id=id or uuid4(),\n        id=_server_id,\n    )\n    # TODO: All this code blocks could be define as property setters\n    # Initialize the fields\n    self.__fields = RecordFields(fields=self._model.fields)\n    # Initialize the vectors\n    self.__vectors = RecordVectors(vectors=vectors, record=self)\n    # Initialize the metadata\n    self.__metadata = RecordMetadata(metadata=metadata)\n    self.__responses = RecordResponses(responses=responses, record=self)\n    self.__suggestions = RecordSuggestions(suggestions=suggestions, record=self)\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.from_dict","title":"<code>from_dict(data, dataset=None)</code>  <code>classmethod</code>","text":"<p>Converts a dictionary to a Record object. Args:     data: A dictionary representing the record.     dataset: The dataset object to which the record belongs. Returns:     A Record object.</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Dict], dataset: Optional[\"Dataset\"] = None) -&gt; \"Record\":\n    \"\"\"Converts a dictionary to a Record object.\n    Args:\n        data: A dictionary representing the record.\n        dataset: The dataset object to which the record belongs.\n    Returns:\n        A Record object.\n    \"\"\"\n    fields = data.get(\"fields\", {})\n    metadata = data.get(\"metadata\", {})\n    suggestions = data.get(\"suggestions\", {})\n    responses = data.get(\"responses\", {})\n    vectors = data.get(\"vectors\", {})\n    record_id = data.get(\"id\", None)\n    _server_id = data.get(\"_server_id\", None)\n\n    suggestions = [Suggestion(question_name=question_name, **value) for question_name, value in suggestions.items()]\n    responses = [\n        Response(question_name=question_name, **value)\n        for question_name, _responses in responses.items()\n        for value in _responses\n    ]\n    vectors = [Vector(name=vector_name, values=values) for vector_name, values in vectors.items()]\n\n    return cls(\n        id=record_id,\n        fields=fields,\n        suggestions=suggestions,\n        responses=responses,\n        vectors=vectors,\n        metadata=metadata,\n        _dataset=dataset,\n        _server_id=_server_id,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.from_model","title":"<code>from_model(model, dataset)</code>  <code>classmethod</code>","text":"<p>Converts a RecordModel object to a Record object. Args:     model: A RecordModel object.     dataset: The dataset object to which the record belongs. Returns:     A Record object.</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>@classmethod\ndef from_model(cls, model: RecordModel, dataset: \"Dataset\") -&gt; \"Record\":\n    \"\"\"Converts a RecordModel object to a Record object.\n    Args:\n        model: A RecordModel object.\n        dataset: The dataset object to which the record belongs.\n    Returns:\n        A Record object.\n    \"\"\"\n    return cls(\n        id=model.external_id,\n        fields=model.fields,\n        metadata={meta.name: meta.value for meta in model.metadata},\n        vectors=[Vector.from_model(model=vector) for vector in model.vectors],\n        # Responses and their models are not aligned 1-1.\n        responses=[\n            response\n            for response_model in model.responses\n            for response in UserResponse.from_model(response_model, dataset=dataset)\n        ],\n        suggestions=[Suggestion.from_model(model=suggestion, dataset=dataset) for suggestion in model.suggestions],\n        _dataset=dataset,\n        _server_id=model.id,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.serialize","title":"<code>serialize()</code>","text":"<p>Serializes the Record to a dictionary for interaction with the API</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>def serialize(self) -&gt; Dict[str, Any]:\n    \"\"\"Serializes the Record to a dictionary for interaction with the API\"\"\"\n    serialized_model = self._model.model_dump()\n    serialized_suggestions = [suggestion.serialize() for suggestion in self.__suggestions]\n    serialized_responses = [response.serialize() for response in self.__responses]\n    serialized_model[\"responses\"] = serialized_responses\n    serialized_model[\"suggestions\"] = serialized_suggestions\n    return serialized_model\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts a Record object to a dictionary for export. Returns:     A dictionary representing the record where the keys are \"fields\",     \"metadata\", \"suggestions\", and \"responses\". Each field and question is     represented as a key-value pair in the dictionary of the respective key. i.e.     `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Dict]:\n    \"\"\"Converts a Record object to a dictionary for export.\n    Returns:\n        A dictionary representing the record where the keys are \"fields\",\n        \"metadata\", \"suggestions\", and \"responses\". Each field and question is\n        represented as a key-value pair in the dictionary of the respective key. i.e.\n        `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},\n    \"\"\"\n    fields = self.fields.to_dict()\n    metadata = dict(self.metadata)\n    suggestions = self.suggestions.to_dict()\n    responses = self.responses.to_dict()\n    vectors = self.vectors.to_dict()\n    return {\n        \"id\": self.id,\n        \"fields\": fields,\n        \"metadata\": metadata,\n        \"suggestions\": suggestions,\n        \"responses\": responses,\n        \"vectors\": vectors,\n        \"_server_id\": str(self._model.id) if self._model.id else None,\n    }\n</code></pre>"},{"location":"reference/argilla_sdk/records/responses/","title":"<code>rg.Response</code>","text":"<p>Class for interacting with Argilla Responses of records. Responses are answers to questions by a user. Therefore, a recod question can have multiple responses, one for each user that has answered the question. A <code>Response</code> is typically created by a user in the UI or consumed from a data source as a label, unlike a <code>Suggestion</code> which is typically created by a model prediction.</p>"},{"location":"reference/argilla_sdk/records/responses/#usage-examples","title":"Usage Examples","text":"<p>Responses can be added to an instantiated <code>Record</code> directly or as a dictionary a dictionary. The following examples demonstrate how to add responses to a record object and how to access responses from a record object:</p> <p>Instantiate the <code>Record</code> and related <code>Response</code> objects:</p> <pre><code>dataset.records.add(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            responses=[rg.Response(\"label\", \"negative\", user_id=user.id)],\n            external_id=str(uuid.uuid4()),\n        )\n    ]\n)\n</code></pre> <p>Or, add a response from a dictionary where key is the question name and value is the response:</p> <pre><code>dataset.records.add(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"label.response\": \"negative\",\n        },\n    ]\n)\n</code></pre> <p>Responses can be accessed from a <code>Record</code> via their question name as an attribute of the record. So if a question is named <code>label</code>, the response can be accessed as <code>record.label</code>. The following example demonstrates how to access responses from a record object:</p> <pre><code># iterate over the records and responses\n\nfor record in dataset.records:\n    for response in record.responses.label:\n        print(response.value)\n        print(response.user_id)\n\n# validate that the record has a response\n\nfor record in dataset.records:\n    if record.responses.label:\n        for response in record.responses.label:\n            print(response.value)\n            print(response.user_id)\n</code></pre>"},{"location":"reference/argilla_sdk/records/responses/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/records/responses/#rgresponse_1","title":"<code>rg.Response</code>","text":"<p>Class for interacting with Argilla Responses of records. Responses are answers to questions by a user. Therefore, a recod question can have multiple responses, one for each user that has answered the question. A <code>Response</code> is typically created by a user in the UI or consumed from a data source as a label, unlike a <code>Suggestion</code> which is typically created by a model prediction.</p> Source code in <code>src/argilla_sdk/responses.py</code> <pre><code>class Response:\n    \"\"\"Class for interacting with Argilla Responses of records. Responses are answers to questions by a user.\n    Therefore, a recod question can have multiple responses, one for each user that has answered the question.\n    A `Response` is typically created by a user in the UI or consumed from a data source as a label,\n    unlike a `Suggestion` which is typically created by a model prediction.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        question_name: str,\n        value: Any,\n        user_id: UUID,\n        _record: Optional[\"Record\"] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a `Response` for a `Record` with a user_id and value\"\"\"\n\n        if question_name is None:\n            raise ValueError(\"question_name is required\")\n        if value is None:\n            raise ValueError(\"value is required\")\n        if user_id is None:\n            raise ValueError(\"user_id is required\")\n\n        self.record = _record\n        self.question_name = question_name\n        self.value = value\n        self.user_id = user_id\n\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"Serializes the Response to a dictionary. This is principally used for sending the response to the API, \\\n            but can be used for data wrangling or manual export.\n\n        Returns:\n            dict[str, Any]: The serialized response as a dictionary with keys `question_name`, `value`, and `user_id`.\n\n        Examples:\n\n        ```python\n        response = rg.Response(\"label\", \"negative\", user_id=user.id)\n        response.serialize()\n        ```\n        \"\"\"\n        return {\n            \"question_name\": self.question_name,\n            \"value\": self.value,\n            \"user_id\": self.user_id,\n        }\n</code></pre>"},{"location":"reference/argilla_sdk/records/responses/#argilla_sdk.responses.Response.__init__","title":"<code>__init__(question_name, value, user_id, _record=None)</code>","text":"<p>Initializes a <code>Response</code> for a <code>Record</code> with a user_id and value</p> Source code in <code>src/argilla_sdk/responses.py</code> <pre><code>def __init__(\n    self,\n    question_name: str,\n    value: Any,\n    user_id: UUID,\n    _record: Optional[\"Record\"] = None,\n) -&gt; None:\n    \"\"\"Initializes a `Response` for a `Record` with a user_id and value\"\"\"\n\n    if question_name is None:\n        raise ValueError(\"question_name is required\")\n    if value is None:\n        raise ValueError(\"value is required\")\n    if user_id is None:\n        raise ValueError(\"user_id is required\")\n\n    self.record = _record\n    self.question_name = question_name\n    self.value = value\n    self.user_id = user_id\n</code></pre>"},{"location":"reference/argilla_sdk/records/responses/#argilla_sdk.responses.Response.serialize","title":"<code>serialize()</code>","text":"<p>Serializes the Response to a dictionary. This is principally used for sending the response to the API,             but can be used for data wrangling or manual export.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The serialized response as a dictionary with keys <code>question_name</code>, <code>value</code>, and <code>user_id</code>.</p> <p>Examples:</p> <pre><code>response = rg.Response(\"label\", \"negative\", user_id=user.id)\nresponse.serialize()\n</code></pre> Source code in <code>src/argilla_sdk/responses.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serializes the Response to a dictionary. This is principally used for sending the response to the API, \\\n        but can be used for data wrangling or manual export.\n\n    Returns:\n        dict[str, Any]: The serialized response as a dictionary with keys `question_name`, `value`, and `user_id`.\n\n    Examples:\n\n    ```python\n    response = rg.Response(\"label\", \"negative\", user_id=user.id)\n    response.serialize()\n    ```\n    \"\"\"\n    return {\n        \"question_name\": self.question_name,\n        \"value\": self.value,\n        \"user_id\": self.user_id,\n    }\n</code></pre>"},{"location":"reference/argilla_sdk/records/suggestions/","title":"<code>rg.Suggestion</code>","text":"<p>Class for interacting with Argilla Suggestions of records. Suggestions are typically created by a model prediction, unlike a <code>Response</code> which is typically created by a user in the UI or consumed from a data source as a label.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/records/suggestions/#adding-records-with-suggestions","title":"Adding records with suggestions","text":"<p>Suggestions can be added to a record directly or via a dictionary structure. The following examples demonstrate how to add suggestions to a record object and how to access suggestions from a record object:</p> <p>Add a response from a dictionary where key is the question name and value is the response:</p> <pre><code>dataset.records.add(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"label\": \"negative\", # this will be used as a suggestion\n        },\n    ]\n)\n</code></pre> <p>If your data contains scores for suggestions you can add them as well via the <code>mapping</code> parameter. The following example demonstrates how to add a suggestion with a score to a record object:</p> <pre><code>dataset.records.add(\n    [\n        {\n            \"prompt\": \"Hello World, how are you?\",\n            \"label\": \"negative\",  # this will be used as a suggestion\n            \"score\": 0.9,  # this will be used as the suggestion score\n            \"model\": \"model_name\",  # this will be used as the suggestion agent\n        },\n    ],\n    mapping={\n        \"score\": \"label.suggestion.score\",\n        \"model\": \"label.suggestion.agent\",\n    },  # `label` is the question name in the dataset settings\n)\n</code></pre> <p>Or, instantiate the <code>Record</code> and related <code>Suggestions</code> objects directly, like this:</p> <pre><code>dataset.records.add(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            suggestions=[rg.Suggestion(\"negative\", \"label\", score=0.9, agent=\"model_name\")],\n        )\n    ]\n)\n</code></pre>"},{"location":"reference/argilla_sdk/records/suggestions/#iterating-over-records-with-suggestions","title":"Iterating over records with suggestions","text":"<p>Just like responses, suggestions can be accessed from a <code>Record</code> via their question name as an attribute of the record. So if a question is named <code>label</code>, the suggestion can be accessed as <code>record.label</code>. The following example demonstrates how to access suggestions from a record object:</p> <pre><code>for record in dataset.records(with_suggestions=True):\n    print(record.suggestions.label)\n</code></pre>"},{"location":"reference/argilla_sdk/records/suggestions/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/records/suggestions/#rgsuggestion_1","title":"<code>rg.Suggestion</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla Suggestions. Suggestions are typically model predictions for records. Suggestions are rendered in the user interfaces as 'hints' or 'suggestions' for the user to review and accept or reject.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The value of the suggestion.add()</p> <code>question_name</code> <code>str</code> <p>The name of the question that the suggestion is for.</p> <code>type</code> <code>str</code> <p>The type of suggestion, either 'model' or 'human'.</p> <code>score</code> <code>float</code> <p>The score of the suggestion. For example, the probability of the model prediction.</p> <code>agent</code> <code>str</code> <p>The agent that created the suggestion. For example, the model name.</p> <code>question_id</code> <code>UUID</code> <p>The ID of the question that the suggestion is for.</p> Source code in <code>src/argilla_sdk/suggestions.py</code> <pre><code>class Suggestion(Resource):\n    \"\"\"Class for interacting with Argilla Suggestions. Suggestions are typically model predictions for records.\n    Suggestions are rendered in the user interfaces as 'hints' or 'suggestions' for the user to review and accept or reject.\n\n    Attributes:\n        value (str): The value of the suggestion.add()\n        question_name (str): The name of the question that the suggestion is for.\n        type (str): The type of suggestion, either 'model' or 'human'.\n        score (float): The score of the suggestion. For example, the probability of the model prediction.\n        agent (str): The agent that created the suggestion. For example, the model name.\n        question_id (UUID): The ID of the question that the suggestion is for.\n\n    \"\"\"\n\n    _model: SuggestionModel\n\n    def __init__(\n        self,\n        question_name: str,\n        value: Any,\n        score: Union[float, List[float], None] = None,\n        agent: Optional[str] = None,\n        type: Optional[Literal[\"model\", \"human\"]] = None,\n        id: Optional[UUID] = None,\n        question_id: Optional[UUID] = None,\n        _record: Optional[\"Record\"] = None,\n    ) -&gt; None:\n        super().__init__()\n\n        if question_name is None:\n            raise ValueError(\"question_name is required\")\n        if value is None:\n            raise ValueError(\"value is required\")\n\n        self.record = _record\n        self._model = SuggestionModel(\n            id=id,\n            question_name=question_name,\n            question_id=question_id,\n            value=value,\n            type=type,\n            score=score,\n            agent=agent,\n        )\n\n    ##############################\n    # Properties\n    ##############################\n\n    @property\n    def value(self) -&gt; Any:\n        \"\"\"The value of the suggestion.\"\"\"\n        return self._model.value\n\n    @property\n    def question_name(self) -&gt; Optional[str]:\n        \"\"\"The name of the question that the suggestion is for.\"\"\"\n        return self._model.question_name\n\n    @question_name.setter\n    def question_name(self, value: str) -&gt; None:\n        self._model.question_name = value\n\n    @property\n    def question_id(self) -&gt; Optional[UUID]:\n        \"\"\"The ID of the question that the suggestion is for.\"\"\"\n        return self._model.question_id\n\n    @question_id.setter\n    def question_id(self, value: UUID) -&gt; None:\n        self._model.question_id = value\n\n    @property\n    def type(self) -&gt; Optional[Literal[\"model\", \"human\"]]:\n        \"\"\"The type of suggestion, either 'model' or 'human'.\"\"\"\n        return self._model.type\n\n    @property\n    def score(self) -&gt; Optional[Union[float, List[float]]]:\n        \"\"\"The score of the suggestion.\"\"\"\n        return self._model.score\n\n    @score.setter\n    def score(self, value: float) -&gt; None:\n        self._model.score = value\n\n    @property\n    def agent(self) -&gt; Optional[str]:\n        \"\"\"The agent that created the suggestion.\"\"\"\n        return self._model.agent\n\n    @agent.setter\n    def agent(self, value: str) -&gt; None:\n        self._model.agent = value\n\n    @classmethod\n    def from_model(cls, model: SuggestionModel, dataset: \"Dataset\") -&gt; \"Suggestion\":\n        question = dataset.settings.question_by_id(model.question_id)\n        model.question_name = question.name\n        model.value = cls.__from_model_value(model.value, question)\n\n        return cls(**model.dict())\n\n    def api_model(self) -&gt; SuggestionModel:\n        if self.record is None or self.record.dataset is None:\n            return self._model\n\n        question = self.record.dataset.settings.question_by_name(self.question_name)\n        return SuggestionModel(\n            value=self.__to_model_value(self.value, question),\n            question_name=self.question_name,\n            question_id=self.question_id or question.id,\n            type=self._model.type,\n            score=self._model.score,\n            agent=self._model.agent,\n            id=self._model.id,\n        )\n\n    @classmethod\n    def __to_model_value(cls, value: Any, question: \"QuestionType\") -&gt; Any:\n        if isinstance(question, RankingQuestion):\n            return cls.__ranking_to_model_value(value)\n        return value\n\n    @classmethod\n    def __from_model_value(cls, value: Any, question: \"QuestionType\") -&gt; Any:\n        if isinstance(question, RankingQuestion):\n            return cls.__ranking_from_model_value(value)\n        return value\n\n    @classmethod\n    def __ranking_from_model_value(cls, value: List[Dict[str, Any]]) -&gt; List[str]:\n        return [v[\"value\"] for v in value]\n\n    @classmethod\n    def __ranking_to_model_value(cls, value: List[str]) -&gt; List[Dict[str, str]]:\n        return [{\"value\": str(v)} for v in value]\n</code></pre>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.agent","title":"<code>agent: Optional[str]</code>  <code>property</code> <code>writable</code>","text":"<p>The agent that created the suggestion.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.question_id","title":"<code>question_id: Optional[UUID]</code>  <code>property</code> <code>writable</code>","text":"<p>The ID of the question that the suggestion is for.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.question_name","title":"<code>question_name: Optional[str]</code>  <code>property</code> <code>writable</code>","text":"<p>The name of the question that the suggestion is for.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.score","title":"<code>score: Optional[Union[float, List[float]]]</code>  <code>property</code> <code>writable</code>","text":"<p>The score of the suggestion.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.type","title":"<code>type: Optional[Literal['model', 'human']]</code>  <code>property</code>","text":"<p>The type of suggestion, either 'model' or 'human'.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The value of the suggestion.</p>"},{"location":"reference/argilla_sdk/records/vectors/","title":"<code>rg.Vector</code>","text":"<p>A vector is a numerical representation of a <code>Record</code> field or attribute, usually the record's text. Vectors can be used to search for similar records via the UI or SDK. Vectors can be added to a record directly or as a dictionary with a key that the matches <code>rg.VectorField</code> name.</p>"},{"location":"reference/argilla_sdk/records/vectors/#usage-examples","title":"Usage Examples","text":"<p>To use vectors within a dataset, you must define a vector field in the dataset settings. The vector field is a list of vector fields that can be attached to a record. The following example demonstrates how to add vectors to a dataset and how to access vectors from a record object:</p> <pre><code>import argilla_sdk as rg\n\ndataset = Dataset(\n    name=\"dataset_with_metadata\",\n    settings=Settings(\n        fields=[TextField(name=\"text\")],\n        questions=[LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])],\n        vectors=[\n            VectorField(name=\"vector_name\"),\n        ],\n    ),\n)\ndataset.create()\n</code></pre> <p>Then, you can add records to the dataset with vectors that correspond to the vector field defined in the dataset settings:</p> <pre><code>dataset.records.add(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"vector_name\": [0.1, 0.2, 0.3]\n        }\n    ]\n)\n</code></pre> <p>Vectors can be passed using a mapping, where the key is the key in the data source and the value is the name in the dataset's setting's <code>rg.VectorField</code> object. For example, the following code adds a record with a vector using a mapping:</p> <pre><code>dataset.records.add(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"x\": [0.1, 0.2, 0.3]\n        }\n    ],\n    mapping={\"x\": \"vector_name\"}\n)\n</code></pre> <p>Or, vectors can be instantiated and added to a record directly, like this:</p> <pre><code>dataset.records.add(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            vectors=[rg.Vector(\"embedding\", [0.1, 0.2, 0.3])],\n        )\n    ]\n)\n</code></pre>"},{"location":"reference/argilla_sdk/records/vectors/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/records/vectors/#rgvector_1","title":"<code>rg.Vector</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla Vectors. Vectors are typically used to represent         embeddings or features of records. The <code>Vector</code> class is used to deliver vectors to the Argilla server.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the vector.</p> <code>values</code> <code>list[float]</code> <p>The values of the vector.</p> Source code in <code>src/argilla_sdk/vectors.py</code> <pre><code>class Vector(Resource):\n    \"\"\" Class for interacting with Argilla Vectors. Vectors are typically used to represent \\\n        embeddings or features of records. The `Vector` class is used to deliver vectors to the Argilla server.\n\n    Attributes:\n        name (str): The name of the vector.\n        values (list[float]): The values of the vector.\n    \"\"\"\n\n    _model: VectorModel\n\n    def __init__(\n        self,\n        name: str,\n        values: list[float],\n    ) -&gt; None:\n        \"\"\"Initializes a Vector with a name and values that can be used to search in the Argilla ui.\n\n        Parameters:\n            name (str): Name of the vector\n            values (list[float]): List of float values\n\n        \"\"\"\n        self._model = VectorModel(\n            name=name,\n            vector_values=values,\n        )\n\n    def __repr__(self) -&gt; str:\n        return repr(f\"{self.__class__.__name__}({self._model})\")\n\n    ##############################\n    # Properties\n    ##############################\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Name of the vector that corresponds to the name of the vector in the dataset's `Settings`\"\"\"\n        return self._model.name\n\n    @property\n    def values(self) -&gt; list[float]:\n        \"\"\"List of float values that represent the vector.\"\"\"\n        return self._model.vector_values\n\n    ##############################\n    # Methods\n    ##############################\n\n    @classmethod\n    def from_model(cls, model: VectorModel) -&gt; \"Vector\":\n        return cls(\n            name=model.name,\n            values=model.vector_values,\n        )\n\n    def serialize(self) -&gt; dict[str, Any]:\n        dumped_model = self._model.model_dump()\n        name = dumped_model.pop(\"name\")\n        values = dumped_model.pop(\"vector_values\")\n        return {name: values}\n</code></pre>"},{"location":"reference/argilla_sdk/records/vectors/#argilla_sdk.vectors.Vector.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Name of the vector that corresponds to the name of the vector in the dataset's <code>Settings</code></p>"},{"location":"reference/argilla_sdk/records/vectors/#argilla_sdk.vectors.Vector.values","title":"<code>values: list[float]</code>  <code>property</code>","text":"<p>List of float values that represent the vector.</p>"},{"location":"reference/argilla_sdk/records/vectors/#argilla_sdk.vectors.Vector.__init__","title":"<code>__init__(name, values)</code>","text":"<p>Initializes a Vector with a name and values that can be used to search in the Argilla ui.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the vector</p> required <code>values</code> <code>list[float]</code> <p>List of float values</p> required Source code in <code>src/argilla_sdk/vectors.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: list[float],\n) -&gt; None:\n    \"\"\"Initializes a Vector with a name and values that can be used to search in the Argilla ui.\n\n    Parameters:\n        name (str): Name of the vector\n        values (list[float]): List of float values\n\n    \"\"\"\n    self._model = VectorModel(\n        name=name,\n        vector_values=values,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/fields/","title":"Fields","text":"<p>Fields in Argilla are define the content of a record that will be reviewed by a user.</p>"},{"location":"reference/argilla_sdk/settings/fields/#usage-examples","title":"Usage Examples","text":"<p>To define a field, instantiate the <code>TextField</code> class and pass it to the <code>fields</code> parameter of the <code>Settings</code> class.</p> <pre><code>text_field = rg.TextField(name=\"text\")\nmarkdown_field = rg.TextField(name=\"text\", use_markdown=True)\n</code></pre> <p>The <code>fields</code> parameter of the <code>Settings</code> class can accept a list of fields, like this:</p> <pre><code>settings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n)\n\ndata = rg.Dataset(\n    name=\"my_dataset\",\n    settings=settings,\n)\n</code></pre> <p>To add records with values for fields, refer to the <code>rg.Dataset.records</code> documentation.</p>"},{"location":"reference/argilla_sdk/settings/fields/#class-references","title":"Class References","text":""},{"location":"reference/argilla_sdk/settings/fields/#rgtextfield","title":"<code>rg.TextField</code>","text":"<p>             Bases: <code>SettingsPropertyBase</code></p> <p>Text field for use in Argilla <code>Dataset</code> <code>Settings</code></p> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>class TextField(SettingsPropertyBase):\n    \"\"\"Text field for use in Argilla `Dataset` `Settings`\"\"\"\n\n    _model: TextFieldModel\n\n    def __init__(\n        self,\n        name: str,\n        title: Optional[str] = None,\n        use_markdown: Optional[bool] = False,\n        required: Optional[bool] = True,\n        description: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Text field for use in Argilla `Dataset` `Settings`\n        Parameters:\n            name (str): The name of the field\n            title (Optional[str], optional): The title of the field. Defaults to None.\n            use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.\n            required (Optional[bool], optional): Whether the field is required. Defaults to True.\n            description (Optional[str], optional): The description of the field. Defaults to None.\n\n        \"\"\"\n        self._model = TextFieldModel(\n            name=name,\n            title=title,\n            required=required or True,\n            description=description,\n            settings=FieldSettings(type=\"text\", use_markdown=use_markdown),\n        )\n\n    @property\n    def use_markdown(self) -&gt; Optional[bool]:\n        return self._model.settings.use_markdown\n\n    @classmethod\n    def from_model(cls, model: TextFieldModel) -&gt; \"TextField\":\n        instance = cls(name=model.name)\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"TextField\":\n        model = TextFieldModel(**data)\n        return cls.from_model(model=model)\n</code></pre>"},{"location":"reference/argilla_sdk/settings/fields/#argilla_sdk.settings.TextField.__init__","title":"<code>__init__(name, title=None, use_markdown=False, required=True, description=None)</code>","text":"<p>Text field for use in Argilla <code>Dataset</code> <code>Settings</code> Parameters:     name (str): The name of the field     title (Optional[str], optional): The title of the field. Defaults to None.     use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.     required (Optional[bool], optional): Whether the field is required. Defaults to True.     description (Optional[str], optional): The description of the field. Defaults to None.</p> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    title: Optional[str] = None,\n    use_markdown: Optional[bool] = False,\n    required: Optional[bool] = True,\n    description: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Text field for use in Argilla `Dataset` `Settings`\n    Parameters:\n        name (str): The name of the field\n        title (Optional[str], optional): The title of the field. Defaults to None.\n        use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.\n        required (Optional[bool], optional): Whether the field is required. Defaults to True.\n        description (Optional[str], optional): The description of the field. Defaults to None.\n\n    \"\"\"\n    self._model = TextFieldModel(\n        name=name,\n        title=title,\n        required=required or True,\n        description=description,\n        settings=FieldSettings(type=\"text\", use_markdown=use_markdown),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/","title":"Metadata Properties","text":"<p>Metadata properties are used to define metadata fields in a dataset. Metadata fields are used to store additional information about the records in the dataset. For example, the category of a record, the price of a product, or any other information that is relevant to the record.</p>"},{"location":"reference/argilla_sdk/settings/metadata_property/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/settings/metadata_property/#defining-metadata-property-for-a-dataset","title":"Defining Metadata Property for a dataset","text":"<p>We define metadata properties via type specific classes. The following example demonstrates how to define metadata properties as either a float, integer, or terms metadata property:</p> <p><code>TermsMetadataProperty</code> is used to define a metadata field with a list of options. For example, a color field with options red, blue, and green. <code>FloatMetadataProperty</code> and <code>IntegerMetadataProperty</code> is used to define a metadata field with a float value. For example, a price field with a minimum value of 0.0 and a maximum value of 100.0.</p> <pre><code>import argilla_sdk as rg\n\n# Define metadata properties as terms\nmetadata_field = rg.TermsMetadataProperty(\n    name=\"color\",\n    options=[\"red\", \"blue\", \"green\"],\n    title=\"Color\",\n)\n\n# Define metadata properties as float\nfloat_ metadata_field = rg.FloatMetadataProperty(\n    name=\"price\",\n    min=0.0,\n    max=100.0,\n    title=\"Price\",\n)\n\n# Define metadata properties as integer\nint_metadata_field = rg.IntegerMetadataProperty(\n    name=\"quantity\",\n    min=0,\n    max=100,\n    title=\"Quantity\",\n)\n</code></pre> <p>Metadata properties can be added to a dataset settings object:</p> <pre><code>dataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=rg.Settings(\n        fields=[\n            rg.TextField(name=\"text\"),\n        ],\n        metadata=[\n            metadata_field,\n            float_metadata_field,\n            int_metadata_field,\n        ],\n    ),\n)\n</code></pre> <p>To add records with metadata, refer to the <code>rg.Metadata</code> class documentation.</p>"},{"location":"reference/argilla_sdk/settings/metadata_property/#class-references","title":"Class References","text":""},{"location":"reference/argilla_sdk/settings/metadata_property/#rgfloatmetadataproperty","title":"<code>rg.FloatMetadataProperty</code>","text":"<p>             Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>class FloatMetadataProperty(MetadataPropertyBase):\n    def __init__(\n        self, name: str, min: Optional[float] = None, max: Optional[float] = None, title: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Create a metadata field with float settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            min (Optional[float]): The minimum value\n            max (Optional[float]): The maximum value\n            title (Optional[str]): The title of the metadata field\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n\n\n        \"\"\"\n        try:\n            settings = FloatMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.float)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.float,\n            title=title,\n            settings=settings,\n        )\n\n    @property\n    def min(self) -&gt; Optional[int]:\n        return self._model.settings.min\n\n    @min.setter\n    def min(self, value: Optional[int]) -&gt; None:\n        self._model.settings.min = value\n\n    @property\n    def max(self) -&gt; Optional[int]:\n        return self._model.settings.max\n\n    @max.setter\n    def max(self, value: Optional[int]) -&gt; None:\n        self._model.settings.max = value\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"FloatMetadataProperty\":\n        instance = FloatMetadataProperty(name=model.name)\n        instance._model = model\n\n        return instance\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/#argilla_sdk.settings.FloatMetadataProperty.__init__","title":"<code>__init__(name, min=None, max=None, title=None)</code>","text":"<p>Create a metadata field with float settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>min</code> <code>Optional[float]</code> <p>The minimum value</p> <code>None</code> <code>max</code> <code>Optional[float]</code> <p>The maximum value</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>def __init__(\n    self, name: str, min: Optional[float] = None, max: Optional[float] = None, title: Optional[str] = None\n) -&gt; None:\n    \"\"\"Create a metadata field with float settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        min (Optional[float]): The minimum value\n        max (Optional[float]): The maximum value\n        title (Optional[str]): The title of the metadata field\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n\n\n    \"\"\"\n    try:\n        settings = FloatMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.float)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.float,\n        title=title,\n        settings=settings,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/#rgintegermetadataproperty","title":"<code>rg.IntegerMetadataProperty</code>","text":"<p>             Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>class IntegerMetadataProperty(MetadataPropertyBase):\n    def __init__(\n        self, name: str, min: Optional[int] = None, max: Optional[int] = None, title: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Create a metadata field with integer settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            min (Optional[int]): The minimum value\n            max (Optional[int]): The maximum value\n            title (Optional[str]): The title of the metadata field\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n        \"\"\"\n\n        try:\n            settings = IntegerMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.integer)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.integer,\n            title=title,\n            settings=settings,\n        )\n\n    @property\n    def min(self) -&gt; Optional[int]:\n        return self._model.settings.min\n\n    @min.setter\n    def min(self, value: Optional[int]) -&gt; None:\n        self._model.settings.min = value\n\n    @property\n    def max(self) -&gt; Optional[int]:\n        return self._model.settings.max\n\n    @max.setter\n    def max(self, value: Optional[int]) -&gt; None:\n        self._model.settings.max = value\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"IntegerMetadataProperty\":\n        instance = IntegerMetadataProperty(name=model.name)\n        instance._model = model\n\n        return instance\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/#argilla_sdk.settings.IntegerMetadataProperty.__init__","title":"<code>__init__(name, min=None, max=None, title=None)</code>","text":"<p>Create a metadata field with integer settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>min</code> <code>Optional[int]</code> <p>The minimum value</p> <code>None</code> <code>max</code> <code>Optional[int]</code> <p>The maximum value</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>def __init__(\n    self, name: str, min: Optional[int] = None, max: Optional[int] = None, title: Optional[str] = None\n) -&gt; None:\n    \"\"\"Create a metadata field with integer settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        min (Optional[int]): The minimum value\n        max (Optional[int]): The maximum value\n        title (Optional[str]): The title of the metadata field\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n    \"\"\"\n\n    try:\n        settings = IntegerMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.integer)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.integer,\n        title=title,\n        settings=settings,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/#rgtermsmetadataproperty","title":"<code>rg.TermsMetadataProperty</code>","text":"<p>             Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>class TermsMetadataProperty(MetadataPropertyBase):\n    def __init__(\n        self,\n        name: str,\n        options: Optional[List[str]] = None,\n        title: Optional[str] = None,\n        visible_for_annotators: Optional[bool] = True,\n    ) -&gt; None:\n        \"\"\"Create a metadata field with terms settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            options (Optional[List[str]]): The list of options\n            title (Optional[str]): The title of the metadata field\n            visible_for_annotators (Optional[bool]): Whether the metadata field is visible for annotators\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n        \"\"\"\n        super().__init__()\n\n        try:\n            settings = TermsMetadataPropertySettings(values=options, type=MetadataPropertyType.terms)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.terms,\n            title=title,\n            settings=settings,\n            visible_for_annotators=visible_for_annotators,\n        )\n\n    @property\n    def options(self) -&gt; Optional[List[str]]:\n        return self._model.settings.values\n\n    @options.setter\n    def options(self, value: list[str]) -&gt; None:\n        self._model.settings.values = value\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"TermsMetadataProperty\":\n        instance = TermsMetadataProperty(name=model.name)\n        instance._model = model\n\n        return instance\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/#argilla_sdk.settings.TermsMetadataProperty.__init__","title":"<code>__init__(name, options=None, title=None, visible_for_annotators=True)</code>","text":"<p>Create a metadata field with terms settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>options</code> <code>Optional[List[str]]</code> <p>The list of options</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <code>visible_for_annotators</code> <code>Optional[bool]</code> <p>Whether the metadata field is visible for annotators</p> <code>True</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    options: Optional[List[str]] = None,\n    title: Optional[str] = None,\n    visible_for_annotators: Optional[bool] = True,\n) -&gt; None:\n    \"\"\"Create a metadata field with terms settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        options (Optional[List[str]]): The list of options\n        title (Optional[str]): The title of the metadata field\n        visible_for_annotators (Optional[bool]): Whether the metadata field is visible for annotators\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n    \"\"\"\n    super().__init__()\n\n    try:\n        settings = TermsMetadataPropertySettings(values=options, type=MetadataPropertyType.terms)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.terms,\n        title=title,\n        settings=settings,\n        visible_for_annotators=visible_for_annotators,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/","title":"Questions","text":"<p>Questions in Argilla are the questions that will be answered as feedback. They are used to define the questions that will be answered by users or models.</p>"},{"location":"reference/argilla_sdk/settings/questions/#usage-examples","title":"Usage Examples","text":"<p>To define a label question, for example, instantiate the <code>LabelQuestion</code> class and pass it to the <code>Settings</code> class.</p> <pre><code>label_question = rg.LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])\n\nsettings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    questions=[\n        label_question,\n    ],\n)\n</code></pre> <p>Questions can be combined in extensible ways based on the type of feedback you want to collect. For example, you can combine a label question with a text question to collect both a label and a text response.</p> <pre><code>label_question = rg.LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])\ntext_question = rg.TextQuestion(name=\"response\")\n\nsettings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    questions=[\n        label_question,\n        text_question,\n    ],\n)\n\ndataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=settings,\n)\n</code></pre> <p>To add records with responses to questions, refer to the <code>rg.Response</code> class documentation.</p>"},{"location":"reference/argilla_sdk/settings/questions/#class-references","title":"Class References","text":""},{"location":"reference/argilla_sdk/settings/questions/#rglabelquestion","title":"<code>rg.LabelQuestion</code>","text":"<p>             Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class LabelQuestion(QuestionPropertyBase):\n    _model: LabelQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        labels: List[str],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n        visible_labels: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\" Define a new label question for `Settings` of a `Dataset`. A label \\\n            question is a question where the user can select one label from \\\n            a list of available labels.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            labels: List[str]: The list of available labels for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n            visible_labels: Optional[int]: The number of visible labels for the question.\n        \"\"\"\n        self._model = LabelQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=LabelQuestionSettings(\n                options=self._render_values_as_options(labels), visible_options=visible_labels\n            ),\n        )\n\n    @classmethod\n    def from_model(cls, model: LabelQuestionModel) -&gt; \"LabelQuestion\":\n        instance = cls(name=model.name, labels=cls._render_options_as_values(model.settings.options))\n        instance._model = model\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"LabelQuestion\":\n        model = LabelQuestionModel(**data)\n        return cls.from_model(model=model)\n\n    ##############################\n    # Public properties\n    ##############################\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return self._render_options_as_labels(self._model.settings.options)\n\n    @labels.setter\n    def labels(self, labels: List[str]) -&gt; None:\n        self._model.settings.options = self._render_values_as_options(labels)\n\n    @property\n    def visible_labels(self) -&gt; Optional[int]:\n        return self._model.settings.visible_options\n\n    @visible_labels.setter\n    def visible_labels(self, visible_labels: Optional[int]) -&gt; None:\n        self._model.settings.visible_options = visible_labels\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.LabelQuestion.__init__","title":"<code>__init__(name, labels, title=None, description=None, required=True, visible_labels=None)</code>","text":"<p>Define a new label question for <code>Settings</code> of a <code>Dataset</code>. A label             question is a question where the user can select one label from             a list of available labels.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>labels</code> <code>List[str]</code> <p>List[str]: The list of available labels for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> <code>visible_labels</code> <code>Optional[int]</code> <p>Optional[int]: The number of visible labels for the question.</p> <code>None</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    labels: List[str],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n    visible_labels: Optional[int] = None,\n) -&gt; None:\n    \"\"\" Define a new label question for `Settings` of a `Dataset`. A label \\\n        question is a question where the user can select one label from \\\n        a list of available labels.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        labels: List[str]: The list of available labels for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n        visible_labels: Optional[int]: The number of visible labels for the question.\n    \"\"\"\n    self._model = LabelQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=LabelQuestionSettings(\n            options=self._render_values_as_options(labels), visible_options=visible_labels\n        ),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#rgmultilabelquestion","title":"<code>rg.MultiLabelQuestion</code>","text":"<p>             Bases: <code>LabelQuestion</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class MultiLabelQuestion(LabelQuestion):\n    _model: MultiLabelQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        labels: List[str],\n        visible_labels: Optional[int] = None,\n        labels_order: str = \"natural\",\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new multilabel question for `Settings` of a `Dataset`. A \\\n            multilabel question is a question where the user can select multiple \\\n            labels from a list of available labels.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            labels: List[str]: The list of available labels for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n            visible_labels: Optional[int]: The number of visible labels for the question.\n            labels_order: str: The order of the labels in the UI. Can be either \"natural\" or \"suggestion\". Default is \"natural\". \n        \"\"\"\n        self._model = MultiLabelQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=MultiLabelQuestionSettings(\n                options=self._render_values_as_options(labels),\n                visible_options=visible_labels,\n                options_order=labels_order,\n            ),\n        )\n\n    @classmethod\n    def from_model(cls, model: MultiLabelQuestionModel) -&gt; \"MultiLabelQuestion\":\n        instance = cls(\n            name=model.name,\n            labels=cls._render_options_as_values(model.settings.options),\n            labels_order=model.settings.options_order,\n        )\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"MultiLabelQuestion\":\n        model = MultiLabelQuestionModel(**data)\n        return cls.from_model(model=model)\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.MultiLabelQuestion.__init__","title":"<code>__init__(name, labels, visible_labels=None, labels_order='natural', title=None, description=None, required=True)</code>","text":"<p>Create a new multilabel question for <code>Settings</code> of a <code>Dataset</code>. A             multilabel question is a question where the user can select multiple             labels from a list of available labels.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>labels</code> <code>List[str]</code> <p>List[str]: The list of available labels for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> <code>visible_labels</code> <code>Optional[int]</code> <p>Optional[int]: The number of visible labels for the question.</p> <code>None</code> <code>labels_order</code> <code>str</code> <p>str: The order of the labels in the UI. Can be either \"natural\" or \"suggestion\". Default is \"natural\".</p> <code>'natural'</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    labels: List[str],\n    visible_labels: Optional[int] = None,\n    labels_order: str = \"natural\",\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new multilabel question for `Settings` of a `Dataset`. A \\\n        multilabel question is a question where the user can select multiple \\\n        labels from a list of available labels.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        labels: List[str]: The list of available labels for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n        visible_labels: Optional[int]: The number of visible labels for the question.\n        labels_order: str: The order of the labels in the UI. Can be either \"natural\" or \"suggestion\". Default is \"natural\". \n    \"\"\"\n    self._model = MultiLabelQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=MultiLabelQuestionSettings(\n            options=self._render_values_as_options(labels),\n            visible_options=visible_labels,\n            options_order=labels_order,\n        ),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#rgrankingquestion","title":"<code>rg.RankingQuestion</code>","text":"<p>             Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class RankingQuestion(QuestionPropertyBase):\n    _model: RankingQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        values: List[str],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new ranking question for `Settings` of a `Dataset`. A ranking question \\\n            is a question where the user can rank a list of options.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            values: List[str]: The list of available values for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n        self._model = RankingQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=RankingQuestionSettings(options=self._render_values_as_options(values)),\n        )\n\n    @classmethod\n    def from_model(cls, model: RankingQuestionModel) -&gt; \"RankingQuestion\":\n        instance = cls(name=model.name, values=cls._render_options_as_values(model.settings.options))\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"RankingQuestion\":\n        model = RankingQuestionModel(**data)\n        return cls.from_model(model=model)\n\n    @property\n    def values(self) -&gt; List[str]:\n        return self._render_options_as_labels(self._model.settings.options)\n\n    @values.setter\n    def values(self, values: List[int]) -&gt; None:\n        self._model.settings.options = self._render_values_as_options(values)\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.RankingQuestion.__init__","title":"<code>__init__(name, values, title=None, description=None, required=True)</code>","text":"<p>Create a new ranking question for <code>Settings</code> of a <code>Dataset</code>. A ranking question             is a question where the user can rank a list of options.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>values</code> <code>List[str]</code> <p>List[str]: The list of available values for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: List[str],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new ranking question for `Settings` of a `Dataset`. A ranking question \\\n        is a question where the user can rank a list of options.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        values: List[str]: The list of available values for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n    \"\"\"\n    self._model = RankingQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=RankingQuestionSettings(options=self._render_values_as_options(values)),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#rgtextquestion","title":"<code>rg.TextQuestion</code>","text":"<p>             Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class TextQuestion(QuestionPropertyBase):\n    _model: TextQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n        use_markdown: bool = False,\n    ) -&gt; None:\n        \"\"\"Create a new text question for `Settings` of a `Dataset`. A text question \\\n            is a question where the user can input text.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n            use_markdown: bool: If the question should use markdown for the description.\n        \"\"\"\n        self._model = TextQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=TextQuestionSettings(use_markdown=use_markdown),\n        )\n\n    @classmethod\n    def from_model(cls, model: TextQuestionModel) -&gt; \"TextQuestion\":\n        instance = cls(name=model.name)\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"TextQuestion\":\n        model = TextQuestionModel(**data)\n        return cls.from_model(model=model)\n\n    @property\n    def use_markdown(self) -&gt; bool:\n        return self._model.settings.use_markdown\n\n    @use_markdown.setter\n    def use_markdown(self, use_markdown: bool) -&gt; None:\n        self._model.settings.use_markdown = use_markdown\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.TextQuestion.__init__","title":"<code>__init__(name, title=None, description=None, required=True, use_markdown=False)</code>","text":"<p>Create a new text question for <code>Settings</code> of a <code>Dataset</code>. A text question             is a question where the user can input text.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> <code>use_markdown</code> <code>bool</code> <p>bool: If the question should use markdown for the description.</p> <code>False</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n    use_markdown: bool = False,\n) -&gt; None:\n    \"\"\"Create a new text question for `Settings` of a `Dataset`. A text question \\\n        is a question where the user can input text.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n        use_markdown: bool: If the question should use markdown for the description.\n    \"\"\"\n    self._model = TextQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=TextQuestionSettings(use_markdown=use_markdown),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#rgratingquestion","title":"<code>rg.RatingQuestion</code>","text":"<p>             Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class RatingQuestion(QuestionPropertyBase):\n    _model: RatingQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        values: List[int],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new rating question for `Settings` of a `Dataset`. A rating question \\\n            is a question where the user can select a value from a sequential list of options.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            values: List[int]: The list of available values for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n        self._model = RatingQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            values=values,\n            settings=RatingQuestionSettings(options=self._render_values_as_options(values)),\n        )\n\n    @classmethod\n    def from_model(cls, model: RatingQuestionModel) -&gt; \"RatingQuestion\":\n        instance = cls(name=model.name, values=cls._render_options_as_values(model.settings.options))\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"RatingQuestion\":\n        model = RatingQuestionModel(**data)\n        return cls.from_model(model=model)\n\n    @property\n    def values(self) -&gt; List[int]:\n        return self._render_options_as_labels(self._model.settings.options)\n\n    @values.setter\n    def values(self, values: List[int]) -&gt; None:\n        self._model.values = self._render_values_as_options(values)\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.RatingQuestion.__init__","title":"<code>__init__(name, values, title=None, description=None, required=True)</code>","text":"<p>Create a new rating question for <code>Settings</code> of a <code>Dataset</code>. A rating question             is a question where the user can select a value from a sequential list of options.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>values</code> <code>List[int]</code> <p>List[int]: The list of available values for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: List[int],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new rating question for `Settings` of a `Dataset`. A rating question \\\n        is a question where the user can select a value from a sequential list of options.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        values: List[int]: The list of available values for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n    \"\"\"\n    self._model = RatingQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        values=values,\n        settings=RatingQuestionSettings(options=self._render_values_as_options(values)),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#rgspanquestion","title":"<code>rg.SpanQuestion</code>","text":"<p>             Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class SpanQuestion(QuestionPropertyBase):\n    _model: SpanQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        field: str,\n        labels: List[str],\n        allow_overlapping: bool = False,\n        visible_labels: Optional[int] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ):\n        \"\"\" Create a new span question for `Settings` of a `Dataset`. A span question \\\n            is a question where the user can select a section of text within a text field \\\n            and assign it a label.\n\n            Parameters:\n                name: str: The name of the question to be used as a reference.\n                field: str: The name of the text field to apply the span question to.\n                labels: List[str]: The list of available labels for the question.\n                allow_overlapping: bool: If the user can select overlapping spans.\n                visible_labels: Optional[int]: The number of labels to show at once.\n                title: Optional[str]: The title of the question to be shown in the UI.\n                description: Optional[str]: The description of the question to be shown in the UI.\n                required: bool: If the question is required for a record to be valid.\n            \"\"\"\n        self._model = SpanQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=SpanQuestionSettings(\n                field=field,\n                allow_overlapping=allow_overlapping,\n                visible_options=visible_labels,\n                options=self._render_values_as_options(labels),\n            ),\n        )\n\n    @property\n    def name(self):\n        return self._model.name\n\n    @property\n    def field(self):\n        return self._model.settings.field\n\n    @field.setter\n    def field(self, field: str):\n        self._model.settings.field = field\n\n    @property\n    def allow_overlapping(self):\n        return self._model.settings.allow_overlapping\n\n    @allow_overlapping.setter\n    def allow_overlapping(self, allow_overlapping: bool):\n        self._model.settings.allow_overlapping = allow_overlapping\n\n    @property\n    def visible_labels(self) -&gt; Optional[int]:\n        return self._model.settings.visible_options\n\n    @visible_labels.setter\n    def visible_labels(self, visible_labels: Optional[int]) -&gt; None:\n        self._model.settings.visible_options = visible_labels\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return self._render_options_as_labels(self._model.settings.options)\n\n    @labels.setter\n    def labels(self, labels: List[str]) -&gt; None:\n        self._model.settings.options = self._render_values_as_options(labels)\n\n    @classmethod\n    def from_model(cls, model: SpanQuestionModel) -&gt; \"SpanQuestion\":\n        instance = cls(\n            name=model.name,\n            field=model.settings.field,\n            labels=cls._render_options_as_values(model.settings.options),\n        )\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"SpanQuestion\":\n        model = SpanQuestionModel(**data)\n        return cls.from_model(model=model)\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.SpanQuestion.__init__","title":"<code>__init__(name, field, labels, allow_overlapping=False, visible_labels=None, title=None, description=None, required=True)</code>","text":"<p>Create a new span question for <code>Settings</code> of a <code>Dataset</code>. A span question             is a question where the user can select a section of text within a text field             and assign it a label.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>field</code> <code>str</code> <p>str: The name of the text field to apply the span question to.</p> required <code>labels</code> <code>List[str]</code> <p>List[str]: The list of available labels for the question.</p> required <code>allow_overlapping</code> <code>bool</code> <p>bool: If the user can select overlapping spans.</p> <code>False</code> <code>visible_labels</code> <code>Optional[int]</code> <p>Optional[int]: The number of labels to show at once.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    field: str,\n    labels: List[str],\n    allow_overlapping: bool = False,\n    visible_labels: Optional[int] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n):\n    \"\"\" Create a new span question for `Settings` of a `Dataset`. A span question \\\n        is a question where the user can select a section of text within a text field \\\n        and assign it a label.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            field: str: The name of the text field to apply the span question to.\n            labels: List[str]: The list of available labels for the question.\n            allow_overlapping: bool: If the user can select overlapping spans.\n            visible_labels: Optional[int]: The number of labels to show at once.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n    self._model = SpanQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=SpanQuestionSettings(\n            field=field,\n            allow_overlapping=allow_overlapping,\n            visible_options=visible_labels,\n            options=self._render_values_as_options(labels),\n        ),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/settings/","title":"<code>rg.Settings</code>","text":"<p><code>rg.Settings</code> is used to define the setttings of an Argilla <code>Dataset</code>. The settings can be used to configure the behavior of the dataset, such as the fields, questions, guidelines, metadata, and vectors. The <code>Settings</code> class is passed to the <code>Dataset</code> class and used to create the dataset on the server. Once created, the settings of a dataset cannot be changed.</p>"},{"location":"reference/argilla_sdk/settings/settings/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/settings/settings/#creating-a-new-dataset-with-settings","title":"Creating a new dataset with settings","text":"<p>To create a new dataset with settings, instantiate the <code>Settings</code> class and pass it to the <code>Dataset</code> class.</p> <pre><code>import argilla_sdk as rg\n\nsettings = rg.Settings(\n    guidelines=\"Select the sentiment of the prompt.\",\n    fields=[rg.TextField(name=\"prompt\", use_markdown=True)],\n    questions=[rg.LabelQuestion(name=\"sentiment\", labels=[\"positive\", \"negative\"])],\n)\n\ndataset = rg.Dataset(name=\"sentiment_analysis\", settings=settings)\n\n# Create the dataset on the server\ndataset.create()\n</code></pre> <p>To define the settings for fields, questions, metadata, or vectors, refer to the <code>rg.TextField</code>, <code>rg.LabelQuestion</code>, <code>rg.TermsMetadataProperty</code>, and <code>rg.VectorField</code> class documentation.</p>"},{"location":"reference/argilla_sdk/settings/settings/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/settings/settings/#rgsettings_1","title":"<code>rg.Settings</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Settings class for Argilla Datasets.</p> <p>This class is used to define the representation of a Dataset within the UI.</p> Source code in <code>src/argilla_sdk/settings/_resource.py</code> <pre><code>class Settings(Resource):\n    \"\"\"\n    Settings class for Argilla Datasets.\n\n    This class is used to define the representation of a Dataset within the UI.\n    \"\"\"\n\n    def __init__(\n        self,\n        fields: Optional[List[FieldType]] = None,\n        questions: Optional[List[QuestionType]] = None,\n        vectors: Optional[List[VectorField]] = None,\n        metadata: Optional[List[MetadataType]] = None,\n        guidelines: Optional[str] = None,\n        allow_extra_metadata: bool = False,\n        _dataset: Optional[\"Dataset\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            fields (List[TextField]): A list of TextField objects that represent the fields in the Dataset.\n            questions (List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]): A list of Question objects that represent the questions in the Dataset.\n            vectors (List[VectorField]): A list of VectorField objects that represent the vectors in the Dataset.\n            metadata (List[MetadataField]): A list of MetadataField objects that represent the metadata in the Dataset.\n            guidelines (str): A string containing the guidelines for the Dataset.\n            allow_extra_metadata (bool): A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.\n        \"\"\"\n        super().__init__(client=_dataset._client if _dataset else None)\n\n        self.__questions = questions or []\n        self.__fields = fields or []\n        self.__vectors = vectors or []\n        self.__metadata = metadata or []\n\n        self.__guidelines = self.__process_guidelines(guidelines)\n        self.__allow_extra_metadata = allow_extra_metadata\n\n        self._dataset = _dataset\n\n    #####################\n    # Properties        #\n    #####################\n\n    @property\n    def fields(self) -&gt; List[FieldType]:\n        return self.__fields\n\n    @fields.setter\n    def fields(self, fields: List[FieldType]):\n        self.__fields = fields\n\n    @property\n    def questions(self) -&gt; List[QuestionType]:\n        return self.__questions\n\n    @questions.setter\n    def questions(self, questions: List[QuestionType]):\n        self.__questions = questions\n\n    @property\n    def guidelines(self) -&gt; str:\n        return self.__guidelines\n\n    @guidelines.setter\n    def guidelines(self, guidelines: str):\n        self.__guidelines = self.__process_guidelines(guidelines)\n\n    @property\n    def vectors(self) -&gt; List[VectorField]:\n        return self.__vectors\n\n    @vectors.setter\n    def vectors(self, vectors: List[VectorField]):\n        self.__vectors = vectors\n\n    @property\n    def metadata(self) -&gt; List[MetadataType]:\n        return self.__metadata\n\n    @metadata.setter\n    def metadata(self, metadata: List[MetadataType]):\n        self.__metadata = metadata\n\n    @property\n    def allow_extra_metadata(self) -&gt; bool:\n        return self.__allow_extra_metadata\n\n    @allow_extra_metadata.setter\n    def allow_extra_metadata(self, value: bool):\n        self.__allow_extra_metadata = value\n\n    @property\n    def dataset(self) -&gt; \"Dataset\":\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, dataset: \"Dataset\"):\n        self._dataset = dataset\n        self._client = dataset._client\n\n    @cached_property\n    def schema(self) -&gt; dict:\n        schema_dict = {}\n\n        for field in self.fields:\n            schema_dict[field.name] = field\n\n        for question in self.questions:\n            schema_dict[question.name] = question\n\n        for vector in self.vectors:\n            schema_dict[vector.name] = vector\n\n        for metadata in self.metadata:\n            schema_dict[metadata.name] = metadata\n\n        return schema_dict\n\n    @cached_property\n    def schema_by_id(self) -&gt; Dict[UUID, Union[FieldType, QuestionType]]:\n        return {v.id: v for v in self.schema.values()}\n\n    def validate(self) -&gt; None:\n        self._validate_empty_settings()\n        self._validate_duplicate_names()\n\n    #####################\n    #  Public methods   #\n    #####################\n\n    def get(self) -&gt; \"Settings\":\n        self.__fetch_fields()\n        self.__fetch_questions()\n        self.__fetch_vectors()\n        self.__fetch_metadata()\n        self.__get_dataset_related_attributes()\n\n        self._update_last_api_call()\n        return self\n\n    def create(self) -&gt; \"Settings\":\n        self.__upsert_fields()\n        self.__upsert_questions()\n        self.__upsert_vectors()\n        self.__upsert_metadata()\n        self.__update_dataset_related_attributes()\n\n        self._update_last_api_call()\n        return self\n\n    def question_by_name(self, question_name: str) -&gt; QuestionType:\n        for question in self.questions:\n            if question.name == question_name:\n                return question\n        raise ValueError(f\"Question with name {question_name} not found\")\n\n    def question_by_id(self, question_id: UUID) -&gt; QuestionType:\n        property = self.schema_by_id.get(question_id)\n        if isinstance(property, QuestionPropertyBase):\n            return property\n        raise ValueError(f\"Question with id {question_id} not found\")\n\n    def serialize(self):\n        try:\n            return {\n                \"guidelines\": self.guidelines,\n                \"fields\": self.__serialize_fields(fields=self.fields),\n                \"questions\": self.__serialize_questions(questions=self.questions),\n                \"allow_extra_metadata\": self.allow_extra_metadata,\n            }\n        except Exception as e:\n            raise ArgillaSerializeError(f\"Failed to serialize the settings. {e.__class__.__name__}\") from e\n\n    def to_json(self, path: Union[Path, str]) -&gt; None:\n        \"\"\"Save the settings to a file on disk\n\n        Parameters:\n            path (str): The path to save the settings to\n        \"\"\"\n        if not isinstance(path, Path):\n            path = Path(path)\n        if path.exists():\n            raise FileExistsError(f\"File {path} already exists\")\n        with open(path, \"w\") as file:\n            json.dump(self.serialize(), file)\n\n    @classmethod\n    def from_json(cls, path: Union[Path, str]) -&gt; \"Settings\":\n        \"\"\"Load the settings from a file on disk\"\"\"\n\n        with open(path, \"r\") as file:\n            settings_dict = json.load(file)\n\n        guidelines = settings_dict.get(\"guidelines\")\n        fields = settings_dict.get(\"fields\")\n        questions = settings_dict.get(\"questions\")\n        allow_extra_metadata = settings_dict.get(\"allow_extra_metadata\")\n\n        fields = [field_from_dict(field) for field in fields]\n        questions = [question_from_dict(question) for question in questions]\n\n        return cls(\n            guidelines=guidelines,\n            fields=fields,\n            questions=questions,\n            allow_extra_metadata=allow_extra_metadata,\n        )\n\n    def __eq__(self, other: \"Settings\") -&gt; bool:\n        return self.serialize() == other.serialize()  # TODO: Create proper __eq__ methods for fields and questions\n\n    #####################\n    #  Repr Methods     #\n    #####################\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"Settings(guidelines={self.guidelines}, allow_extra_metadata={self.allow_extra_metadata}, \"\n            f\"fields={self.fields}, questions={self.questions}, vectors={self.vectors}, metadata={self.metadata})\"\n        )\n\n    #####################\n    #  Private methods  #\n    #####################\n\n    def __fetch_fields(self) -&gt; List[FieldType]:\n        models = self._client.api.fields.list(dataset_id=self._dataset.id)\n        self.__fields = [field_from_model(model) for model in models]\n\n        return self.__fields\n\n    def __fetch_questions(self) -&gt; List[QuestionType]:\n        models = self._client.api.questions.list(dataset_id=self._dataset.id)\n        self.__questions = [question_from_model(model) for model in models]\n\n        return self.__questions\n\n    def __fetch_vectors(self) -&gt; List[VectorField]:\n        models = self._client.api.vectors.list(dataset_id=self._dataset.id)\n        self.__vectors = [field_from_model(model) for model in models]\n\n        return self.__vectors\n\n    def __fetch_metadata(self) -&gt; List[MetadataType]:\n        models = self._client.api.metadata.list(dataset_id=self._dataset.id)\n        self.__metadata = [field_from_model(model) for model in models]\n\n        return self.__metadata\n\n    def __get_dataset_related_attributes(self):\n        # This flow may be a bit weird, but it's the only way to update the dataset related attributes\n        # Everything is point that we should have several settings-related endpoints in the API to handle this.\n        # POST /api/v1/datasets/{dataset_id}/settings\n        # {\n        #   \"guidelines\": ....,\n        #   \"allow_extra_metadata\": ....,\n        # }\n        # But this is not implemented yet, so we need to update the dataset model directly\n        dataset_model = self._client.api.datasets.get(self._dataset.id)\n\n        self.guidelines = dataset_model.guidelines\n        self.allow_extra_metadata = dataset_model.allow_extra_metadata\n\n    def __update_dataset_related_attributes(self):\n        # This flow may be a bit weird, but it's the only way to update the dataset related attributes\n        # Everything is point that we should have several settings-related endpoints in the API to handle this.\n        # POST /api/v1/datasets/{dataset_id}/settings\n        # {\n        #   \"guidelines\": ....,\n        #   \"allow_extra_metadata\": ....,\n        # }\n        # But this is not implemented yet, so we need to update the dataset model directly\n        dataset_model = DatasetModel(\n            id=self._dataset.id,\n            name=self._dataset.name,\n            guidelines=self.guidelines,\n            allow_extra_metadata=self.allow_extra_metadata,\n        )\n        self._client.api.datasets.update(dataset_model)\n\n    def __upsert_questions(self) -&gt; None:\n        for question in self.__questions:\n            try:\n                question_model = self._client.api.questions.create(\n                    dataset_id=self._dataset.id, question=question._model\n                )\n                question._model = question_model\n            except ArgillaAPIError as e:\n                raise SettingsError(f\"Failed to create question {question.name}\") from e\n\n    def __upsert_fields(self) -&gt; None:\n        for field in self.__fields:\n            try:\n                field_model = self._client.api.fields.create(dataset_id=self._dataset.id, field=field._model)\n                field._model = field_model\n            except ArgillaAPIError as e:\n                raise SettingsError(f\"Failed to create field {field.name}\") from e\n\n    def __upsert_vectors(self) -&gt; None:\n        for vector in self.__vectors:\n            try:\n                vector_model = self._client.api.vectors.create(dataset_id=self._dataset.id, vector=vector._model)\n                vector._model = vector_model\n            except ArgillaAPIError as e:\n                raise SettingsError(f\"Failed to create vector {vector.name}\") from e\n\n    def __upsert_metadata(self) -&gt; None:\n        for metadata in self.__metadata:\n            metadata_model = self._client.api.metadata.create(\n                dataset_id=self._dataset.id, metadata_field=metadata._model\n            )\n            metadata._model = metadata_model\n\n    def _validate_empty_settings(self):\n        if not all([self.fields, self.questions]):\n            message = \"Fields and questions are required\"\n            raise SettingsError(message=message)\n\n    def _validate_duplicate_names(self) -&gt; None:\n        dataset_properties_by_name = {}\n\n        for prop in self.fields + self.questions + self.vectors + self.metadata:\n            if prop.name in dataset_properties_by_name:\n                raise SettingsError(\n                    f\"names of dataset settings must be unique, \"\n                    f\"but the name {prop.name!r} is used by {type(prop).__name__!r} and {type(dataset_properties_by_name[prop.name]).__name__!r} \"\n                )\n            dataset_properties_by_name[prop.name] = prop\n\n    def __process_fields(self, fields: List[FieldType]) -&gt; List[\"TextFieldModel\"]:\n        processed_fields = []\n        for field in fields:\n            try:\n                processed_field = field._model\n            except Exception as e:\n                raise SettingsError(f\"Failed to process field {field.name}\") from e\n            processed_fields.append(processed_field)\n        return processed_fields\n\n    def __process_questions(self, questions: List[QuestionType]) -&gt; List[\"TextQuestionModel\"]:\n        processed_questions = []\n        for question in questions:\n            try:\n                processed_question = question._model\n            except Exception as e:\n                raise SettingsError(f\"Failed to process question {question.name}\") from e\n            processed_questions.append(processed_question)\n        return processed_questions\n\n    def __process_guidelines(self, guidelines):\n        if guidelines is None:\n            return guidelines\n\n        if not isinstance(guidelines, str):\n            raise SettingsError(\"Guidelines must be a string or a path to a file\")\n\n        if os.path.exists(guidelines):\n            with open(guidelines, \"r\") as file:\n                return file.read()\n\n        return guidelines\n\n    def __serialize_fields(self, fields: List[FieldType]):\n        return [field.serialize() for field in fields]\n\n    def __serialize_questions(self, questions: List[QuestionType]):\n        return [question.serialize() for question in questions]\n</code></pre>"},{"location":"reference/argilla_sdk/settings/settings/#argilla_sdk.settings.Settings.__init__","title":"<code>__init__(fields=None, questions=None, vectors=None, metadata=None, guidelines=None, allow_extra_metadata=False, _dataset=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>fields</code> <code>List[TextField]</code> <p>A list of TextField objects that represent the fields in the Dataset.</p> <code>None</code> <code>questions</code> <code>List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]</code> <p>A list of Question objects that represent the questions in the Dataset.</p> <code>None</code> <code>vectors</code> <code>List[VectorField]</code> <p>A list of VectorField objects that represent the vectors in the Dataset.</p> <code>None</code> <code>metadata</code> <code>List[MetadataField]</code> <p>A list of MetadataField objects that represent the metadata in the Dataset.</p> <code>None</code> <code>guidelines</code> <code>str</code> <p>A string containing the guidelines for the Dataset.</p> <code>None</code> <code>allow_extra_metadata</code> <code>bool</code> <p>A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.</p> <code>False</code> Source code in <code>src/argilla_sdk/settings/_resource.py</code> <pre><code>def __init__(\n    self,\n    fields: Optional[List[FieldType]] = None,\n    questions: Optional[List[QuestionType]] = None,\n    vectors: Optional[List[VectorField]] = None,\n    metadata: Optional[List[MetadataType]] = None,\n    guidelines: Optional[str] = None,\n    allow_extra_metadata: bool = False,\n    _dataset: Optional[\"Dataset\"] = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        fields (List[TextField]): A list of TextField objects that represent the fields in the Dataset.\n        questions (List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]): A list of Question objects that represent the questions in the Dataset.\n        vectors (List[VectorField]): A list of VectorField objects that represent the vectors in the Dataset.\n        metadata (List[MetadataField]): A list of MetadataField objects that represent the metadata in the Dataset.\n        guidelines (str): A string containing the guidelines for the Dataset.\n        allow_extra_metadata (bool): A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.\n    \"\"\"\n    super().__init__(client=_dataset._client if _dataset else None)\n\n    self.__questions = questions or []\n    self.__fields = fields or []\n    self.__vectors = vectors or []\n    self.__metadata = metadata or []\n\n    self.__guidelines = self.__process_guidelines(guidelines)\n    self.__allow_extra_metadata = allow_extra_metadata\n\n    self._dataset = _dataset\n</code></pre>"},{"location":"reference/argilla_sdk/settings/settings/#argilla_sdk.settings.Settings.from_json","title":"<code>from_json(path)</code>  <code>classmethod</code>","text":"<p>Load the settings from a file on disk</p> Source code in <code>src/argilla_sdk/settings/_resource.py</code> <pre><code>@classmethod\ndef from_json(cls, path: Union[Path, str]) -&gt; \"Settings\":\n    \"\"\"Load the settings from a file on disk\"\"\"\n\n    with open(path, \"r\") as file:\n        settings_dict = json.load(file)\n\n    guidelines = settings_dict.get(\"guidelines\")\n    fields = settings_dict.get(\"fields\")\n    questions = settings_dict.get(\"questions\")\n    allow_extra_metadata = settings_dict.get(\"allow_extra_metadata\")\n\n    fields = [field_from_dict(field) for field in fields]\n    questions = [question_from_dict(question) for question in questions]\n\n    return cls(\n        guidelines=guidelines,\n        fields=fields,\n        questions=questions,\n        allow_extra_metadata=allow_extra_metadata,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/settings/#argilla_sdk.settings.Settings.to_json","title":"<code>to_json(path)</code>","text":"<p>Save the settings to a file on disk</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the settings to</p> required Source code in <code>src/argilla_sdk/settings/_resource.py</code> <pre><code>def to_json(self, path: Union[Path, str]) -&gt; None:\n    \"\"\"Save the settings to a file on disk\n\n    Parameters:\n        path (str): The path to save the settings to\n    \"\"\"\n    if not isinstance(path, Path):\n        path = Path(path)\n    if path.exists():\n        raise FileExistsError(f\"File {path} already exists\")\n    with open(path, \"w\") as file:\n        json.dump(self.serialize(), file)\n</code></pre>"},{"location":"reference/argilla_sdk/settings/vectors/","title":"Vectors","text":"<p>Vector fields in Argilla are used to define the vector form of a record that will be reviewed by a user.</p>"},{"location":"reference/argilla_sdk/settings/vectors/#usage-examples","title":"Usage Examples","text":"<p>To define a vector field, instantiate the <code>VectorField</code> class with a name and dimenstions, then pass it to the <code>vectors</code> parameter of the <code>Settings</code> class.</p> <pre><code>settings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    vectors=[\n        rg.VectorField(\n            name=\"my_vector\",\n            dimension=768,\n            title=\"Document Embedding\",\n        ),\n    ],\n)\n</code></pre> <p>To add records with vectors, refer to the <code>rg.Vector</code> class documentation.</p>"},{"location":"reference/argilla_sdk/settings/vectors/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla_sdk/settings/vectors/#rgvectorfield","title":"<code>rg.VectorField</code>","text":"<p>             Bases: <code>SettingsPropertyBase</code></p> <p>Vector field for use in Argilla <code>Dataset</code> <code>Settings</code></p> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>class VectorField(SettingsPropertyBase):\n    \"\"\"Vector field for use in Argilla `Dataset` `Settings`\"\"\"\n\n    _model: VectorFieldModel\n\n    def __init__(\n        self,\n        name: str,\n        dimensions: int,\n        title: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Vector field for use in Argilla `Dataset` `Settings`\n\n        Parameters:\n            name (str): The name of the field\n            dimensions (int): The number of dimensions in the vector\n            title (Optional[str], optional): The title of the field. Defaults to None.\n        \"\"\"\n        self._model = VectorFieldModel(\n            name=name,\n            title=title,\n            dimensions=dimensions,\n        )\n\n    @classmethod\n    def from_model(cls, model: VectorFieldModel) -&gt; \"VectorField\":\n        instance = cls(name=model.name, dimensions=model.dimensions)\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"VectorField\":\n        model = VectorFieldModel(**data)\n        return cls.from_model(model=model)\n\n    @property\n    def dimensions(self) -&gt; int:\n        return self._model.dimensions\n\n    @property\n    def title(self) -&gt; Optional[str]:\n        return self._model.title\n\n    @property\n    def name(self) -&gt; str:\n        return self._model.name\n\n    @property\n    def description(self) -&gt; Optional[str]:\n        # TODO: Setting resources should be aligned at the API level\n        return None\n\n    @property\n    def required(self) -&gt; bool:\n        # TODO: Setting resources should be aligned at the API level\n        return False\n\n    @property\n    def type(self) -&gt; str:\n        # TODO: Setting resources should be aligned at the API level\n        return \"vector\"\n</code></pre>"},{"location":"reference/argilla_sdk/settings/vectors/#argilla_sdk.settings.VectorField.__init__","title":"<code>__init__(name, dimensions, title=None)</code>","text":"<p>Vector field for use in Argilla <code>Dataset</code> <code>Settings</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field</p> required <code>dimensions</code> <code>int</code> <p>The number of dimensions in the vector</p> required <code>title</code> <code>Optional[str]</code> <p>The title of the field. Defaults to None.</p> <code>None</code> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    dimensions: int,\n    title: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Vector field for use in Argilla `Dataset` `Settings`\n\n    Parameters:\n        name (str): The name of the field\n        dimensions (int): The number of dimensions in the vector\n        title (Optional[str], optional): The title of the field. Defaults to None.\n    \"\"\"\n    self._model = VectorFieldModel(\n        name=name,\n        title=title,\n        dimensions=dimensions,\n    )\n</code></pre>"}]}