{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Argilla is a collaboration platform for AI engineers and domain experts that require high-quality outputs, full data ownership, and overall efficiency.</p> <ul> <li> <p> Get started in 5 minutes</p> <p>Install <code>argilla</code> with <code>pip</code> and deploy a <code>Docker</code> for free on Hugging Face to get up and running in minutes.</p> <p> Getting started</p> </li> <li> <p> Installation</p> <p>Learn how to <code>pip</code> install Argilla and configure the server and UI using <code>Docker</code>, <code>k8s</code> and cloud proivders.</p> <p> Installation</p> </li> <li> <p> How to guides</p> <p>Get familiar with common workflows for Argilla. From managing <code>Users</code>, <code>Workspaces</code>. <code>Datasets</code> and <code>Records</code> to fine-tuning a model.</p> <p> How to guide</p> </li> <li> <p> Tutorials</p> <p>Discover cool applied examples of Argilla working on techniques like RAG with <code>haystack</code>, fine-tuning <code>transformers</code>,  few-shot textcat with <code>setfit</code> and more.</p> <p> Tutorials</p> </li> <li> <p> UI demo</p> <p>If you just want to get started, we recommend our <code>UI demo</code> which contains non-technical human readable examples to showcase the diversity of Argilla.</p> <p> UI demo</p> </li> <li> <p> API Reference</p> <p>Get familiar with the codebase of our <code>Python SDK</code> and <code>FastAPI server</code>.</p> <p> API Reference</p> </li> </ul>"},{"location":"#why-use-argilla","title":"Why use Argilla?","text":"<p>Whether you are working on monitoring and improving complex generative tasks involving LLM pipelines with RAG, or you are working on a predictive task for things like AB-testing of span- and text-classification models. Our versatile platform helps you ensure your data work pays off.</p>"},{"location":"#improve-your-ai-output-quality-through-data-quality","title":"Improve your AI output quality through data quality","text":"<p>Compute is expensive and output quality is important. We help you focus on data, which tackles the root cause of both of these problems at once. Argilla helps you to achieve and keep high-quality standards for your data. This means you can improve the quality of your AI output.</p>"},{"location":"#take-control-of-your-data-and-models","title":"Take control of your data and models","text":"<p>Most AI platforms are black boxes. Argilla is different. We believe that you should be the owner of both your data and your models. That's why we provide you with all the tools your team needs to manage your data and models in a way that suits you best.</p>"},{"location":"#improve-efficiency-by-quickly-iterating-on-the-right-data-and-models","title":"Improve efficiency by quickly iterating on the right data and models","text":"<p>Gathering data is a time-consuming process. Argilla helps by providing a platform that allows you to interact with your data in a more engaging way. This means you can quickly and easily label your data with filters, AI feedback suggestions and semantic search. So you can focus on training your models and monitoring their performance.</p>"},{"location":"#what-do-people-build-with-argilla","title":"What do people build with Argilla?","text":""},{"location":"#datasets-and-models","title":"Datasets and models","text":"<p>Argilla is a tool that can be used to achieve and keep high-quality data standards with a focus on NLP and LLMs. Our community uses Argilla to create amazing open-source datasets and models, and we love contributions to open-source ourselves too.</p> <ul> <li>Our cleaned UltraFeedback dataset and the Notus and Notux models, where we improved benchmark and empirical human judgment for the Mistral and Mixtral models with cleaner data using human feedback.</li> <li>Our distilabeled Intel Orca DPO dataset and the improved OpenHermes model, show how we improve model performance by filtering out 50% of the original dataset through human and AI feedback.</li> </ul>"},{"location":"#projects-and-pipelines","title":"Projects and pipelines","text":"<p>AI teams from companies like the Red Cross, Loris.ai and Prolific use Argilla to improve the quality and efficiency of AI projects. They shared their experiences in our AI community meetup.</p> <ul> <li>AI for good: the Red Cross presentation showcases how their experts and AI team collaborate by classifying and redirecting requests from refugees of the Ukrainian crisis to streamline the support processes of the Red Cross.</li> <li>Customer support: during the Loris meetup they showed how their AI team uses unsupervised and few-shot contrastive learning to help them quickly validate and gain labelled samples for a huge amount of multi-label classifiers.</li> <li>Research studies: the showcase from Prolific announced their integration with our platform. They use it to actively distribute data collection projects among their annotating workforce. This allows them to quickly and efficiently collect high-quality data for their research studies.</li> </ul>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/","title":"Add suggestions and responses 005","text":"<p>First, let's install our dependencies and import the necessary libraries:</p> <pre><code>!pip install \"argilla-python\"\n!pip install datasets transformers\n</code></pre> <pre><code>import argilla_sdk as rg\nfrom datasets import load_dataset\nfrom transformers import pipeline\nfrom datetime import datetime\n</code></pre> <p>In order to run this notebook we will need some credentials to push and load datasets from <code>Argilla</code> and <code>\ud83e\udd17 Hub</code>, let's set them in the following cell:</p> <p>Log in to argilla:</p> <pre><code>client = rg.Argilla()\n</code></pre> <pre><code>dataset = client.datasets.get(name=\"end2end_textclassification\", workspace=\"argilla\")\n</code></pre> <p>Let us briefly examine what our dataset looks like. It is a dataset that consists of data items with the field <code>text</code> that is yet to be annotated.</p> <pre><code>dataset[0].fields\n</code></pre> <pre>\n<code>{'text': \"Wall St. Bears Claw Back Into the Black (Reuters) Reuters - Short-sellers, Wall Street's dwindling\\\\band of ultra-cynics, are seeing green again.\"}</code>\n</pre> <p>As we will be using the gold labels in the original dataset as the responses, we can pull the original dataset from HuggingFace Hub. We can do this by using the <code>load_dataset</code> method.</p> <pre><code>dataset_org = load_dataset(\"ag_news\", split=\"train[:1000]\")\n</code></pre> <p>The labels in the original dataset are in the form of integers while we need to present them to the annotators in the form of strings. Therefore, we will create a dictionary that maps the integer labels to their string counterparts.</p> <pre><code>for index, record in enumerate(dataset.records):\n    record.responses.create(\n        name=\"label\",\n        value=dataset_org[index][\"label\"],\n    )\n</code></pre> <pre><code>model_name = \"cointegrated/rubert-tiny-bilingual-nli\"\nclassifier = pipeline(\"zero-shot-classification\", model=model_name)\ncandidate_labels = [\"World\", \"Sports\", \"Business\", \"Sci/Tech\"]\n</code></pre> <p>We can iterate over the data items and add the suggestions for each item by classifying the text with the model at the same time. Additionally, we would like to add the model as the <code>agent</code> of the suggestions for future reference.</p> <pre><code>for record in dataset.records:\n    record.suggestions.create(\n        name=\"label\", value=classifier(record.fields[\"text\"], candidate_labels)[\"labels\"][0], agent=model_name\n    )\n</code></pre> <pre><code>dataset.publish()\n</code></pre> <p>Let us go to Argilla and look at the dataset we created. When you first open the dataset, you should the message \"You have no pending records\" as we have uploaded all the responses and there is no pending record left. As seen below, if you go to the <code>Submitted</code> tab, you can see that all the records are submitted with the exact labels we have uploaded above.</p> <p></p> <p>As all the records are submitted, we no longer see the suggestion for each one of the records. To demonstrate how they are seen, you can see the Argilla UI below where the record is not submitted yet and the suggestion (<code>Sports</code> in this case) is shown to the annotator.</p> <p></p> <pre><code>from huggingface_hub import login\n\nhf_token = \"YOUR_HF_TOKEN\"\nlogin(token=hf_token)\n</code></pre> <p>We only need to call the <code>to_datasets</code> method to convert the dataset to datasets format.</p> <pre><code>ds = dataset.to_datasets()\nds.push_to_hub(\"argilla/end2end_textclassification\", use_auth_token=hf_token)\n</code></pre>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#add-responses-and-suggestions-to-feedbackdataset","title":"Add <code>Responses</code> and <code>Suggestions</code> to <code>FeedbackDataset</code>","text":"<p>In this part of the end-to-end tutorial series, we will see how we can update the records of our dataset with the responses and suggestions. You can refer to previous tutorials for creating the dataset, configuring the users and workspaces or adding metadata. Feel free to check out the practical guides page for more in-depth information.</p> <p>In Argilla, <code>responses</code> are the answers that the annotators give to the questions that we ask them. If we have a dataset that has been annotated already, we can add these gold responses to our dataset as responses. This comes in handy in that we will not have to annotate the dataset again. On the other hand, <code>suggestions</code> are the model predictions that we show to our annotators in the UI during the annotation process. This way, the annotation process will become much faster and easier for the annotators.</p> <p></p>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Pull the Dataset</li> <li>From Argilla</li> <li>From HuggingFace Hub</li> <li>Pull the Original Dataset</li> <li>Add Responses</li> <li>Add Suggestions</li> <li>Push the Dataset</li> <li>To Argilla</li> <li>To HuggingFace Hub</li> <li>Conclusion</li> </ol>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#running-argilla","title":"Running Argilla","text":"<p>For this tutorial, you will need to have an Argilla server running. There are two main options for deploying and running Argilla:</p> <p>Deploy Argilla on Hugging Face Spaces: If you want to run tutorials with external notebooks (e.g., Google Colab) and you have an account on Hugging Face, you can deploy Argilla on Spaces with a few clicks:</p> <p></p> <p>For details about configuring your deployment, check the official Hugging Face Hub guide.</p> <p>Launch Argilla using Argilla's quickstart Docker image: This is the recommended option if you want Argilla running on your local machine. Note that this option will only let you run the tutorial locally and not with an external notebook service.</p> <p>For more information on deployment options, please check the Deployment section of the documentation.</p>   Tip  This tutorial is a Jupyter Notebook. There are two options to run it:  - Use the Open in Colab button at the top of this page. This option allows you to run the notebook directly on Google Colab. Don't forget to change the runtime type to GPU for faster model training and inference. - Download the .ipynb file by clicking on the View source link at the top of the page. This option allows you to download the notebook and run it on your local machine or on a Jupyter notebook tool of your choice."},{"location":"_source/tutorials/add-suggestions-and-responses-005/#get-the-dataset","title":"Get the Dataset","text":"<p>As we uploaded the dataset that we created in the previous tutorial to both Argilla and HuggingFace Hub, we can now get the dataset. Let us see how we can pull the dataset from both.</p>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#from-argilla","title":"From Argilla","text":"<p>We can pull the dataset from Argilla by using the <code>from_argilla</code> method.</p>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#pull-the-original-dataset","title":"Pull the Original Dataset","text":""},{"location":"_source/tutorials/add-suggestions-and-responses-005/#add-responses","title":"Add <code>Responses</code>","text":"<p>Now that we have the original dataset and the dataset that we created in the previous tutorial, we can add the responses. The process is slightly different for the local FeedbackDataset and the RemoteFeedbackDataset. Let us see how we can do it for both.</p>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#add-suggestions","title":"Add <code>Suggestions</code>","text":"<p>As we have mentioned, suggestions are the predictions by any model of your preference to be added as suggested responses to our dataset. In this tutorial, we will be using the <code>cointegrated/rubert-tiny-bilingual-nli</code> model from the HuggingFace Hub to obtain our model predictions. To obtain the predictions, we will use the <code>pipeline</code> method from the <code>transformers</code> library, which makes it easy to use models for inference. Let us first load the model. To give us our zero-shot model, we also create a list of the labels that we want to predict.</p>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#publish-the-responses-and-suggestions-to-argilla","title":"Publish the Responses and Suggestions to Argilla","text":"<p>Now that we have added the responses and suggestions to our dataset, we can push the dataset to Argilla. We can do this by using the <code>publish</code> method.</p>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#to-huggingface-hub","title":"To HuggingFace Hub","text":"<p>If you would like to push the dataset you created to the HuggingFace Hub, you can simply use the <code>push_to_huggingface</code> method to upload it. Do not forget to create a model card as well, which will make the dataset more readable and understandable for the users.</p> <p>To be able to upload your dataset to the Hub, you must be logged in to the Hub. The following cell will log us with our previous token.</p> <p>If we don't have one already, we can obtain it from here (remember to set the write access).</p>"},{"location":"_source/tutorials/add-suggestions-and-responses-005/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we have seen how we can add responses and suggestions to our dataset. Adding responses to your dataset given that you already have the annotated labels is a great way to save time and effort for your project. Similarly, adding suggestions to your dataset will make the annotation process much faster and easier for your annotators. Now, with the dataset we obtained, we can move on to training our model and computing the metrics. For more detailed info on how to utilize various tools, please refer to our practical guides</p>"},{"location":"_source/tutorials/assign-records-002/","title":"Assign records 002","text":"<p>First, let's install our dependencies and import the necessary libraries:</p> <pre><code>!pip install \"argilla-python\"\n!pip install datasets\n</code></pre> <pre><code>import argilla_sdk as rg\n</code></pre> <p>In order to run this notebook we will need some credentials to push and load datasets from <code>Argilla</code> and <code>\ud83e\udd17 Hub</code>, let's set them in the following cell:</p> <p>Log in to argilla:</p> <pre><code>client = rg.Argilla()\n</code></pre> <pre><code>dataset = client.datasets.get(name=\"end2end_textclassification\", workspace=\"argilla\")\n</code></pre> <p>If the dataset does not</p> <pre><code>dataset[0].fields\n</code></pre> <pre>\n<code>{'text': \"Wall St. Bears Claw Back Into the Black (Reuters) Reuters - Short-sellers, Wall Street's dwindling\\\\band of ultra-cynics, are seeing green again.\"}</code>\n</pre> <p>Feedback dataset supports multiple annotation for each record, allowing for straightforward aggregation and utilization. Simply ensure that your dataset is available in a shared workspace accessible to all team members. For detailed guidance on setting this up, refer to our comprehensive example on configuring users and workspaces.</p> <p>If you aim to specify a fixed number of annotations per record, it's advisable to implement a controlled overlap. To facilitate this, we offer a variety of options and workflows tailored to meet your needs.</p> <p>First, we will set our groups and the records. In this example, we'll be considering a scenario where we are collaborating with two teams, each consisting of five members and a thousand records that need to be annotated. This will be the first time we work with this teams, so we will only be providing their names.</p> <p>&gt; Note: The names of your members should be written in lower case.</p> <pre><code># Get all the users in the workspace\nworkspace_users = client.workspaces.get(name=\"argilla\").users\n\n# Split the users in to two groups\nusers_group_1 = workspace_users[: len(workspace_users) // 2]\nusers_group_2 = workspace_users[len(workspace_users) // 2 :]\n</code></pre> <p>1.1. Define groups from new users</p> <pre><code>tania = rg.User(username=\"tania\", password=\"taniascat\")\nbill = rg.User(username=\"jeroen\", password=\"jeroensdog\")\narmita = rg.User(username=\"armita\", password=\"amitasbird\")\ntim = rg.User(username=\"tim\", password=\"taniascat\")\njames = rg.User(username=\"james\", password=\"jamesfish\")\nrashida = rg.User(username=\"rashida\", password=\"rashidaslizard\")\n\nfor user in [tania, bill, armita, tim, james, rashida]:\n    client.users.create(user)\n</code></pre> <p>1.2 Define groups existing users</p> <pre><code>tania = client.users.get(username=\"tania\")\nbill = client.users.get(username=\"jeroen\")\narmita = client.users.get(username=\"armita\")\nrashida = client.users.get(username=\"rashida\")\ntim = rg.User(username=\"tim\", password=\"taniascat\")\njames = rg.User(username=\"james\", password=\"jamesfish\")\n\n# Add the users to the workspace\nclient.users.create(tim)\nclient.users.create(james)\n</code></pre> <p>We will use the <code>assign_records</code> function to assign the annotations. We will specify the following parameters:</p> <ul> <li><code>users</code>: This will be our dictionary with the groups.</li> <li><code>records</code>: The list of 1000 records.</li> <li><code>overlap</code>: We will set the overlap value to 1 (also known as zero overlap), indicating that the teams will annotate the samples independently, without any overlap. Since each group comprises five members, ultimately, each record will receive 5 annotations, as all members from the same team will be annotating the same records.</li> <li><code>shuffle</code>: To avoid any kind of bias, we will set it to <code>True</code>, so the samples are shuffled before the assignment.</li> </ul> <p>As we already mention, we have not yet worked with these annotators, so their users in Argilla will be automatically created.</p> <p>&gt; Note: The username and first name will be the names provided, the default password is \"12345678\" and they will have the role of \"annotator\".</p> <pre><code>users_group_1 = [tania, bill, armita]\nusers_group_2 = [tim, james, rashida]\n\nassignments = dataset.assign(groups=[users_group_1, users_group_2], overlap=1, shuffle=True)\nclient.datasets.update(dataset)\n</code></pre> <p></p>"},{"location":"_source/tutorials/assign-records-002/#assign-records-to-your-team","title":"Assign records to your team","text":"<p>This tutorial is part of a series in which we will get to know the <code>FeedbackDataset</code>. In this step, we will show the complete workflow to assign the records of our TextClassification dataset to a team. You can have a look at the previous tutorials for creating the dataset and configuring the users and workspaces. Feel free to check out the practical guides page for more in-depth information.</p>"},{"location":"_source/tutorials/assign-records-002/#table-of-contents","title":"Table of contents","text":"<ol> <li>Load a FeedbackDataset</li> <li>From Argilla</li> <li>From the HuggingFace Hub</li> <li>Full Overlap</li> <li>Controlled Overlap</li> <li>Working with Groups</li> <li>Working with a List of Users</li> <li>Conclusion</li> </ol>"},{"location":"_source/tutorials/assign-records-002/#running-argilla","title":"Running Argilla","text":"<p>For this tutorial, you will need to have an Argilla server running. There are two main options for deploying and running Argilla:</p> <p>Deploy Argilla on Hugging Face Spaces: If you want to run tutorials with external notebooks (e.g., Google Colab) and you have an account on Hugging Face, you can deploy Argilla on Spaces with a few clicks:</p> <p></p> <p>For details about configuring your deployment, check the official Hugging Face Hub guide.</p> <p>Launch Argilla using Argilla's quickstart Docker image: This is the recommended option if you want Argilla running on your local machine. Note that this option will only let you run the tutorial locally and not with an external notebook service.</p> <p>For more information on deployment options, please check the Deployment section of the documentation.</p>   Tip  This tutorial is a Jupyter Notebook. There are two options to run it:  - Use the Open in Colab button at the top of this page. This option allows you to run the notebook directly on Google Colab. Don't forget to change the runtime type to GPU for faster model training and inference. - Download the .ipynb file by clicking on the View source link at the top of the page. This option allows you to download the notebook and run it on your local machine or on a Jupyter notebook tool of your choice."},{"location":"_source/tutorials/assign-records-002/#pull-the-dataset","title":"Pull the Dataset","text":"<p>As we uploaded the dataset we created in the previous tutorial to both Argilla and HuggingFace Hub, we can pull the dataset from either of them. Let us see how we can pull the dataset from both.</p>"},{"location":"_source/tutorials/assign-records-002/#from-argilla","title":"From Argilla","text":"<p>We can pull the dataset from Argilla by using the <code>get</code> method.</p>"},{"location":"_source/tutorials/assign-records-002/#full-overlap","title":"Full Overlap","text":""},{"location":"_source/tutorials/assign-records-002/#controlled-overlap","title":"Controlled Overlap","text":""},{"location":"_source/tutorials/assign-records-002/#working-with-groups","title":"Working with Groups","text":"<p>This section will focus on describing all the steps to assign records to predefined groups of annotators.</p>"},{"location":"_source/tutorials/assign-records-002/#1-get-the-users-and-records","title":"1. Get the users and records","text":""},{"location":"_source/tutorials/assign-records-002/#2-assign-the-records","title":"2. Assign the records","text":""},{"location":"_source/tutorials/assign-records-002/#conclusion","title":"Conclusion","text":"<p>To sum up, we have shown how to assign records with full and controlled overlap. In scenarios involving controlled overlap, we explored the methods for distributing records among groups of annotators and a specified list of users through the use of <code>assign_records</code> and <code>assign_workspaces</code>. Additionally, we examined the technique for transferring these allocated records to their respective workspaces. In the next tutorial, we will see how we can add metadata properties to our dataset.</p>"},{"location":"_source/tutorials/configure-users-and-workspaces-000/","title":"Configure users and workspaces 000","text":"<p>First let's install our dependencies and import the necessary libraries:</p> <pre><code>!pip install \"argilla-python\"\n</code></pre> <pre><code>from argilla import Argilla\n</code></pre> <p>Log to argilla:</p> <pre><code>rg = Argilla(\n    api_url=\"http://localhost:6900/\",\n    api_key=\"admin.apikey\",\n)\n</code></pre> <pre><code>user = rg.User.get_me()\nuser\n</code></pre> <pre>\n<code>User(username='admin', first_name='Admin', role=&lt;Role.admin: 'admin'&gt;, last_name=None, password=None, id='5bb2a532-36f6-4af8-b5b8-ad2fbba4b7d3', api_key='admin.apikey', inserted_at='2024-01-31T18:48:52.994136', updated_at='2024-01-31T18:48:52.994136')</code>\n</pre> <p>As we can see, we are logged into the default <code>User</code> called <code>argilla</code>, which has the <code>owner</code> role. This <code>role</code> is allowed to create new <code>Users</code> and configure workspaces.</p> <pre><code>user = rg.User(\n        username=\"admin\",\n        first_name=\"Admin\",\n        role=\"admin\",\n    )\nuser.create()\n</code></pre> <pre><code>user.update(\n    first_name=\"Admin\",\n    last_name=\"AdminMcAdmin\",\n) \n</code></pre> <p>In this tutorial, we created some Argilla <code>Users</code> and <code>Workspaces</code>, and created some annotation team configurations.</p>"},{"location":"_source/tutorials/configure-users-and-workspaces-000/#configuring-users-and-workspaces","title":"Configuring <code>Users</code> and <code>Workspaces</code>","text":"<p>This tutorial is part of a series in which we will get to know Argilla's <code>Dataset</code>. In this step, we will show how to configure <code>Users</code> and <code>Workspaces</code>. If you need additional context, consult user management and workspace management.</p> <p></p>"},{"location":"_source/tutorials/configure-users-and-workspaces-000/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Configure Users</li> <li>Current active User</li> <li>Create User</li> <li>Update User</li> <li>Conclusion</li> </ol>"},{"location":"_source/tutorials/configure-users-and-workspaces-000/#running-argilla","title":"Running Argilla","text":"<p>For this tutorial, you will need to have an Argilla server running. There are two main options for deploying and running Argilla:</p> <p>Deploy Argilla on Hugging Face Spaces: If you want to run tutorials with external notebooks (e.g., Google Colab) and you have an account on Hugging Face, you can deploy Argilla on Spaces with a few clicks:</p> <p></p> <p>For details about configuring your deployment, check the official Hugging Face Hub guide.</p> <p>Launch Argilla using Argilla's quickstart Docker image: This is the recommended option if you want Argilla running on your local machine. Note that this option will only let you run the tutorial locally and not with an external notebook service.</p> <p>For more information on deployment options, please check the Deployment section of the documentation.</p>   Tip  This tutorial is a Jupyter Notebook. There are two options to run it:  - Use the Open in Colab button at the top of this page. This option allows you to run the notebook directly on Google Colab. Don't forget to change the runtime type to GPU for faster model training and inference. - Download the .ipynb file by clicking on the View source link at the top of the page. This option allows you to download the notebook and run it on your local machine or on a Jupyter notebook tool of your choice."},{"location":"_source/tutorials/configure-users-and-workspaces-000/#configure-users","title":"Configure <code>Users</code>","text":""},{"location":"_source/tutorials/configure-users-and-workspaces-000/#current-active-user","title":"Current active <code>User</code>","text":"<p>For this tutorial, we'll start with exploring the currently active user we've configured during the initialization. We can do this using our <code>Python</code> client or <code>CLI</code>.</p>"},{"location":"_source/tutorials/configure-users-and-workspaces-000/#create-user","title":"Create <code>User</code>","text":"<p>Next, we will create two new users with the role of <code>admin</code> and <code>annotator</code> to configure our first small team. For convenience and reproducibility, we will call them <code>admin</code> and <code>annotator</code>, and we'll set their <code>password</code> to the default <code>argilla.apikey</code>. Their <code>api_key</code> will be randomly generated according to safety standards. We will first create the <code>admin</code> user with our <code>Python</code> client.</p>"},{"location":"_source/tutorials/configure-users-and-workspaces-000/#update-user","title":"Update <code>User</code>","text":"<p>We can update a user using the update method and passing the new user informations. Existing arguments will remain the same if not updated.</p>"},{"location":"_source/tutorials/configure-users-and-workspaces-000/#conclusion","title":"Conclusion","text":""},{"location":"_source/tutorials/create-dataset-001/","title":"Create dataset 001","text":"<p>First let's install our dependencies and import the necessary libraries:</p> <pre><code>!pip install \"argilla-python\"\n!pip install datasets\n</code></pre> <pre><code>import argilla as rg\nfrom datasets import load_dataset\n</code></pre> <pre>\n<code>/home/ben/code/argilla-python/.venv/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</code>\n</pre> <p>Connect to argilla:</p> <pre><code># papermill_description=logging-to-argilla\nclient = rg.Argilla()\n</code></pre> <p>For this tutorial we will use the ag_news dataset which can be downloaded from the \ud83e\udd17<code>hub</code>. We will load only the first 1000 items from the training sample.</p> <pre><code>ds = load_dataset(\"ag_news\", split=\"train[:1000]\")\nds\n</code></pre> <pre>\n<code>Downloading data: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18.6M/18.6M [00:06&lt;00:00, 3.09MB/s]\nDownloading data: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1.23M/1.23M [00:00&lt;00:00, 2.32MB/s]\nGenerating train split: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 120000/120000 [00:00&lt;00:00, 1338233.95 examples/s]\nGenerating test split: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 7600/7600 [00:00&lt;00:00, 1354093.30 examples/s]\n</code>\n</pre> <pre>\n<code>Dataset({\n    features: ['text', 'label'],\n    num_rows: 1000\n})</code>\n</pre> <p>We will just load the first 1000 records for this tutorial, but feel free to test the full dataset.</p> <p>This dataset contains a collection of news articles (we can see the content in the <code>text</code> column), which have been asigned one of the following classification <code>labels</code>: World (0), Sports (1), Business (2), Sci/Tech (3).</p> <p>Let's use the task templates to create a feedback dataset ready for <code>text-classification</code>.</p> <pre><code>text_classification_dataset = rg.Dataset(\n    template=rg.Template.for_text_classification(\n        guidelines=\"Classify the articles into one of the four categories.\",\n        labels=[\"World\", \"Sports\", \"Business\", \"Sci/Tech\"],\n    )\n)\nclient.datasets.create(text_classification_dataset)\n</code></pre> <p>We could compare this dataset with the custom configuration we would use previously (we can take a look at the custom configuration for more information on the creation of a <code>Dataset</code> when we want a finer control):</p> <pre><code>custom_text_classification_template = rg.Template(\n    guidelines=\"Classify the articles into one of the four categories.\",\n    fields=[\n        rg.Field(name=\"text\", title=\"Text from the article\"),\n        rg.Field(name=\"context\", title=\"Context from the article\"),\n    ],\n    questions=[\n        rg.Question(\n            name=\"label\",\n            title=\"In which category does this article fit?\",\n            required=True,\n            settings=rg.QuestionSettings.MultiLabel(\n                options=rg.LabelOption.from_labels([\"World\", \"Sports\", \"Business\", \"Sci/Tech\"])\n            ),\n        )\n    ],\n)\ncustom_text_classification_dataset = rg.Dataset(template=custom_text_classification_template)\nclient.datasets.create(custom_text_classification_dataset)\n</code></pre> <pre>\n<code>FeedbackDataset(\n   fields=[TextField(name='text', title='Text from the article', required=True, type='text', use_markdown=False)]\n   questions=[LabelQuestion(name='label', title='In which category does this article fit?', description=None, required=True, type='label_selection', labels={'World': '0', 'Sports': '1', 'Business': '2', 'Sci/Tech': '3'}, visible_labels=None)]\n   guidelines=Classify the articles into one of the four categories.)\n   metadata_properties=[])\n)</code>\n</pre> <p>The next step once we have our <code>Dataset</code> created is adding the FeedbackRecords to it.</p> <p>In order to create our records we can just loop over the items in the <code>datasets.Dataset</code>.</p> <pre><code>for i, item in enumerate(ds):\n    text_classification_dataset.records.add(\n        rg.Record(\n            fields={\n                \"text\": item[\"text\"],\n            },\n            external_id=f\"record-{i}\",\n        )\n    )\n</code></pre> <p>If we had our data in a different format, let's say a <code>csv</code> file, maybe it's more direct to read the data using pandas for that.</p> <p>We will transform our dataset to pandas format for this example, and the remaining <code>FeedbackRecord</code> creation remains just the same:</p> <pre><code>df_dataset = ds.to_pandas()\ndf_dataset.head()\n</code></pre> text label 0 Wall St. Bears Claw Back Into the Black (Reute... 2 1 Carlyle Looks Toward Commercial Aerospace (Reu... 2 2 Oil and Economy Cloud Stocks' Outlook (Reuters... 2 3 Iraq Halts Oil Exports from Main Southern Pipe... 2 4 Oil prices soar to all-time record, posing new... 2 <p>Let's add our records to the dataset:</p> <pre><code>for i, item in df_dataset.iterrows():\n    text_classification_dataset.records.add(\n        rg.Record(\n            fields={\n                \"text\": item[\"text\"],\n            },\n            external_id=f\"record-{i}\",\n        )\n    )\n</code></pre> <pre><code>client.datasets.publish(text_classification_dataset)\n</code></pre> <p>By now we have our dataset with the texts ready to be labeled, let's push it to <code>Argilla</code>.</p> <p>If we go to our <code>Argilla</code> instance we should see a similar screen like the following.</p> <p></p> <pre><code>dataset = client.datasets.get(text_classification_dataset.id)\nlocal_dataset = dataset.pull()\n# We can now convert to our favorite format\n\ndf = dataset.to_pandas()\nds = dataset.to_datasets()\n</code></pre> <p>In this tutorial we created an <code>Argilla</code> <code>FeedbackDataset</code> for text classification, starting from ag_news.</p> <p>We created a <code>FeedbackDataset</code> for text classification with a <code>LabelQuestion</code>, from data stored as a <code>datasets.Dataset</code> and a <code>pandas.DataFrame</code>. This dataset was pushed both to <code>Argilla</code> where we can curate and label the records, and finally pushed it to the \ud83e\udd17<code>hub</code>.</p> <p>To learn more about how to work with the <code>FeedbackDataset</code> check the cheatsheet. To continue with assigning records to annotators, you can refer to the next tutorial.</p>"},{"location":"_source/tutorials/create-dataset-001/#creating-a-dataset","title":"Creating a <code>Dataset</code>","text":"<p>This tutorial is part of a series in which we will get to know the <code>Dataset</code>. Before starting this tutorial, you need to do the tutorial on configuring users and workspaces. In this step, we will show how to configure a <code>Dataset</code> and add <code>Records</code> to it.</p> <p>We will start by creating a basic dataset using the ag_news dataset as an example and push it to <code>Argilla</code> and the Hugging Face <code>hub</code>.</p>"},{"location":"_source/tutorials/create-dataset-001/#running-argilla","title":"Running Argilla","text":"<p>For this tutorial, you will need to have an Argilla server running. There are two main options for deploying and running Argilla:</p> <p>Deploy Argilla on Hugging Face Spaces: If you want to run tutorials with external notebooks (e.g., Google Colab) and you have an account on Hugging Face, you can deploy Argilla on Spaces with a few clicks:</p> <p></p> <p>For details about configuring your deployment, check the official Hugging Face Hub guide.</p> <p>Launch Argilla using Argilla's quickstart Docker image: This is the recommended option if you want Argilla running on your local machine. Note that this option will only let you run the tutorial locally and not with an external notebook service.</p> <p>For more information on deployment options, please check the Deployment section of the documentation.</p>   Tip  This tutorial is a Jupyter Notebook. There are two options to run it:  - Use the Open in Colab button at the top of this page. This option allows you to run the notebook directly on Google Colab. Don't forget to change the runtime type to GPU for faster model training and inference. - Download the .ipynb file by clicking on the View source link at the top of the page. This option allows you to download the notebook and run it on your local machine or on a Jupyter notebook tool of your choice."},{"location":"_source/tutorials/create-dataset-001/#configure-a-dataset","title":"Configure a <code>Dataset</code>","text":""},{"location":"_source/tutorials/create-dataset-001/#add-records","title":"Add <code>Records</code>","text":""},{"location":"_source/tutorials/create-dataset-001/#from-a-hugging-face-dataset","title":"From a Hugging Face <code>dataset</code>","text":""},{"location":"_source/tutorials/create-dataset-001/#from-a-pandasdataframe","title":"From a <code>pandas.DataFrame</code>","text":""},{"location":"_source/tutorials/create-dataset-001/#publish-our-dataset-to-argilla-for-feedback","title":"Publish our dataset to Argilla for Feedback","text":""},{"location":"_source/tutorials/create-dataset-001/#download-our-dataset-for-use","title":"Download our dataset for use","text":""},{"location":"_source/tutorials/create-dataset-001/#conclusion","title":"Conclusion","text":""},{"location":"_source/tutorials/quickstart-tutorial/","title":"Quickstart tutorial","text":"<pre><code>import argilla_sdk as rg\n</code></pre> <pre><code>client = rg.Argilla(api_url=\"http://localhost:6900\", api_key=\"owner.apikey\")\n</code></pre> <pre><code>client.workspaces\n</code></pre> <pre><code>ws = rg.Workspace(\"end-to-end\", client=client)\n</code></pre> <pre><code>try:\n    ws.create()\nexcept Exception as e:\n    print(\"Workspace exists\")\n</code></pre> <pre>\n<code>Workspace exists\n</code>\n</pre> <pre><code>user = rg.User(username=\"end-user\", password=\"password\", client=client)\n\ntry:\n    ws.create()\nexcept Exception as e:\n    print(\"User exists\")\n</code></pre> <pre>\n<code>User exists\n</code>\n</pre> <pre><code># !pip install -qqq datasets\n\nfrom uuid import uuid4\n\nfrom datasets import load_dataset\n\n\nds = load_dataset(\"imdb\", split=\"train[:100]\").to_list()\n\nds = [{\"text\": x[\"text\"], \"label\": \"positive\" if x[\"label\"] == 1 else \"negative\", \"external_id\": uuid4()} for x in ds]\n\nprint(ds[:5], sep=\"\\n\")\n</code></pre> <pre>\n<code>/home/ben/code/argilla-python/.venv/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</code>\n</pre> <pre>\n<code>[{'text': 'I rented I AM CURIOUS-YELLOW from my video store because of all the controversy that surrounded it when it was first released in 1967. I also heard that at first it was seized by U.S. customs if it ever tried to enter this country, therefore being a fan of films considered \"controversial\" I really had to see this for myself.&lt;br /&gt;&lt;br /&gt;The plot is centered around a young Swedish drama student named Lena who wants to learn everything she can about life. In particular she wants to focus her attentions to making some sort of documentary on what the average Swede thought about certain political issues such as the Vietnam War and race issues in the United States. In between asking politicians and ordinary denizens of Stockholm about their opinions on politics, she has sex with her drama teacher, classmates, and married men.&lt;br /&gt;&lt;br /&gt;What kills me about I AM CURIOUS-YELLOW is that 40 years ago, this was considered pornographic. Really, the sex and nudity scenes are few and far between, even then it\\'s not shot like some cheaply made porno. While my countrymen mind find it shocking, in reality sex and nudity are a major staple in Swedish cinema. Even Ingmar Bergman, arguably their answer to good old boy John Ford, had sex scenes in his films.&lt;br /&gt;&lt;br /&gt;I do commend the filmmakers for the fact that any sex shown in the film is shown for artistic purposes rather than just to shock people and make money to be shown in pornographic theaters in America. I AM CURIOUS-YELLOW is a good film for anyone wanting to study the meat and potatoes (no pun intended) of Swedish cinema. But really, this film doesn\\'t have much of a plot.', 'label': 'negative', 'external_id': UUID('7cfc65f5-16fe-4d4b-96eb-505bdb4ebf92')}, {'text': '\"I Am Curious: Yellow\" is a risible and pretentious steaming pile. It doesn\\'t matter what one\\'s political views are because this film can hardly be taken seriously on any level. As for the claim that frontal male nudity is an automatic NC-17, that isn\\'t true. I\\'ve seen R-rated films with male nudity. Granted, they only offer some fleeting views, but where are the R-rated films with gaping vulvas and flapping labia? Nowhere, because they don\\'t exist. The same goes for those crappy cable shows: schlongs swinging in the breeze but not a clitoris in sight. And those pretentious indie movies like The Brown Bunny, in which we\\'re treated to the site of Vincent Gallo\\'s throbbing johnson, but not a trace of pink visible on Chloe Sevigny. Before crying (or implying) \"double-standard\" in matters of nudity, the mentally obtuse should take into account one unavoidably obvious anatomical difference between men and women: there are no genitals on display when actresses appears nude, and the same cannot be said for a man. In fact, you generally won\\'t see female genitals in an American film in anything short of porn or explicit erotica. This alleged double-standard is less a double standard than an admittedly depressing ability to come to terms culturally with the insides of women\\'s bodies.', 'label': 'negative', 'external_id': UUID('7b70b469-0eb9-4111-b26b-b496f614ebbc')}, {'text': \"If only to avoid making this type of film in the future. This film is interesting as an experiment but tells no cogent story.&lt;br /&gt;&lt;br /&gt;One might feel virtuous for sitting thru it because it touches on so many IMPORTANT issues but it does so without any discernable motive. The viewer comes away with no new perspectives (unless one comes up with one while one's mind wanders, as it will invariably do during this pointless film).&lt;br /&gt;&lt;br /&gt;One might better spend one's time staring out a window at a tree growing.&lt;br /&gt;&lt;br /&gt;\", 'label': 'negative', 'external_id': UUID('a39f6772-8479-4a66-8b36-69ee106ebc67')}, {'text': \"This film was probably inspired by Godard's Masculin, f\u00e9minin and I urge you to see that film instead.&lt;br /&gt;&lt;br /&gt;The film has two strong elements and those are, (1) the realistic acting (2) the impressive, undeservedly good, photo. Apart from that, what strikes me most is the endless stream of silliness. Lena Nyman has to be most annoying actress in the world. She acts so stupid and with all the nudity in this film,...it's unattractive. Comparing to Godard's film, intellectuality has been replaced with stupidity. Without going too far on this subject, I would say that follows from the difference in ideals between the French and the Swedish society.&lt;br /&gt;&lt;br /&gt;A movie of its time, and place. 2/10.\", 'label': 'negative', 'external_id': UUID('ca380a0e-ab99-4b34-8e87-a3643b50dc6a')}, {'text': 'Oh, brother...after hearing about this ridiculous film for umpteen years all I can think of is that old Peggy Lee song..&lt;br /&gt;&lt;br /&gt;\"Is that all there is??\" ...I was just an early teen when this smoked fish hit the U.S. I was too young to get in the theater (although I did manage to sneak into \"Goodbye Columbus\"). Then a screening at a local film museum beckoned - Finally I could see this film, except now I was as old as my parents were when they schlepped to see it!!&lt;br /&gt;&lt;br /&gt;The ONLY reason this film was not condemned to the anonymous sands of time was because of the obscenity case sparked by its U.S. release. MILLIONS of people flocked to this stinker, thinking they were going to see a sex film...Instead, they got lots of closeups of gnarly, repulsive Swedes, on-street interviews in bland shopping malls, asinie political pretension...and feeble who-cares simulated sex scenes with saggy, pale actors.&lt;br /&gt;&lt;br /&gt;Cultural icon, holy grail, historic artifact..whatever this thing was, shred it, burn it, then stuff the ashes in a lead box!&lt;br /&gt;&lt;br /&gt;Elite esthetes still scrape to find value in its boring pseudo revolutionary political spewings..But if it weren\\'t for the censorship scandal, it would have been ignored, then forgotten.&lt;br /&gt;&lt;br /&gt;Instead, the \"I Am Blank, Blank\" rhythymed title was repeated endlessly for years as a titilation for porno films (I am Curious, Lavender - for gay films, I Am Curious, Black - for blaxploitation films, etc..) and every ten years or so the thing rises from the dead, to be viewed by a new generation of suckers who want to see that \"naughty sex film\" that \"revolutionized the film industry\"...&lt;br /&gt;&lt;br /&gt;Yeesh, avoid like the plague..Or if you MUST see it - rent the video and fast forward to the \"dirty\" parts, just to get it over with.&lt;br /&gt;&lt;br /&gt;', 'label': 'negative', 'external_id': UUID('61806eaa-c97a-41fb-8302-9dc00a7d3974')}]\n</code>\n</pre> <pre><code># Defining the dataset's feedback task\nsettings = rg.Settings(\n    guidelines=\"Classify the articles into one of the four categories.\",\n    fields=[\n        rg.TextField(\n            name=\"text\",\n            title=\"Text from the article\",\n            use_markdown=False,\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(\n            name=\"label\",\n            title=\"In which category does this article fit?\",\n            labels=[\"positive\", \"negative\"],\n        )\n    ],\n)\n</code></pre> <pre><code>dataset = rg.Dataset(\n    name=f\"IMDB-dataset-{uuid4()}\",\n    workspace_id=str(client.workspaces[0].id),\n    settings=settings,\n    client=client,\n)\n</code></pre> <pre><code>dataset.publish()\ndataset.records.add(records=ds)\n</code></pre> <pre>\n<code>/home/ben/code/argilla-python/src/argilla_sdk/records/_resource.py:192: UserWarning: Record attribute external_id is not in the schema so skipping. \n                    Define a mapping to map source data fields to Argilla Fields, Questions, and ids\n\n  warnings.warn(\n</code>\n</pre> <p>We can now pull and export the records from Argilla and see that we have dictionaries with a key <code>label.suggestion</code> that reflects the source data.</p> <pre><code>records = dataset.records.to_list()\nrecords[:5]\n</code></pre> <pre>\n<code>[{'external_id': UUID('4f29315f-67cf-4650-a887-d86abe9bf8dd'),\n  'text': 'I rented I AM CURIOUS-YELLOW from my video store because of all the controversy that surrounded it when it was first released in 1967. I also heard that at first it was seized by U.S. customs if it ever tried to enter this country, therefore being a fan of films considered \"controversial\" I really had to see this for myself.&lt;br /&gt;&lt;br /&gt;The plot is centered around a young Swedish drama student named Lena who wants to learn everything she can about life. In particular she wants to focus her attentions to making some sort of documentary on what the average Swede thought about certain political issues such as the Vietnam War and race issues in the United States. In between asking politicians and ordinary denizens of Stockholm about their opinions on politics, she has sex with her drama teacher, classmates, and married men.&lt;br /&gt;&lt;br /&gt;What kills me about I AM CURIOUS-YELLOW is that 40 years ago, this was considered pornographic. Really, the sex and nudity scenes are few and far between, even then it\\'s not shot like some cheaply made porno. While my countrymen mind find it shocking, in reality sex and nudity are a major staple in Swedish cinema. Even Ingmar Bergman, arguably their answer to good old boy John Ford, had sex scenes in his films.&lt;br /&gt;&lt;br /&gt;I do commend the filmmakers for the fact that any sex shown in the film is shown for artistic purposes rather than just to shock people and make money to be shown in pornographic theaters in America. I AM CURIOUS-YELLOW is a good film for anyone wanting to study the meat and potatoes (no pun intended) of Swedish cinema. But really, this film doesn\\'t have much of a plot.',\n  'label.suggestion': 'negative',\n  'label.score': None},\n {'external_id': UUID('019ac0fc-d197-4201-a058-90ac24ef5f7b'),\n  'text': '\"I Am Curious: Yellow\" is a risible and pretentious steaming pile. It doesn\\'t matter what one\\'s political views are because this film can hardly be taken seriously on any level. As for the claim that frontal male nudity is an automatic NC-17, that isn\\'t true. I\\'ve seen R-rated films with male nudity. Granted, they only offer some fleeting views, but where are the R-rated films with gaping vulvas and flapping labia? Nowhere, because they don\\'t exist. The same goes for those crappy cable shows: schlongs swinging in the breeze but not a clitoris in sight. And those pretentious indie movies like The Brown Bunny, in which we\\'re treated to the site of Vincent Gallo\\'s throbbing johnson, but not a trace of pink visible on Chloe Sevigny. Before crying (or implying) \"double-standard\" in matters of nudity, the mentally obtuse should take into account one unavoidably obvious anatomical difference between men and women: there are no genitals on display when actresses appears nude, and the same cannot be said for a man. In fact, you generally won\\'t see female genitals in an American film in anything short of porn or explicit erotica. This alleged double-standard is less a double standard than an admittedly depressing ability to come to terms culturally with the insides of women\\'s bodies.',\n  'label.suggestion': 'negative',\n  'label.score': None},\n {'external_id': UUID('a8b9fe09-ce71-4355-a5de-4c15404a6def'),\n  'text': \"If only to avoid making this type of film in the future. This film is interesting as an experiment but tells no cogent story.&lt;br /&gt;&lt;br /&gt;One might feel virtuous for sitting thru it because it touches on so many IMPORTANT issues but it does so without any discernable motive. The viewer comes away with no new perspectives (unless one comes up with one while one's mind wanders, as it will invariably do during this pointless film).&lt;br /&gt;&lt;br /&gt;One might better spend one's time staring out a window at a tree growing.&lt;br /&gt;&lt;br /&gt;\",\n  'label.suggestion': 'negative',\n  'label.score': None},\n {'external_id': UUID('d67c2f84-3812-42ec-a53f-f054f958e6d5'),\n  'text': \"This film was probably inspired by Godard's Masculin, f\u00e9minin and I urge you to see that film instead.&lt;br /&gt;&lt;br /&gt;The film has two strong elements and those are, (1) the realistic acting (2) the impressive, undeservedly good, photo. Apart from that, what strikes me most is the endless stream of silliness. Lena Nyman has to be most annoying actress in the world. She acts so stupid and with all the nudity in this film,...it's unattractive. Comparing to Godard's film, intellectuality has been replaced with stupidity. Without going too far on this subject, I would say that follows from the difference in ideals between the French and the Swedish society.&lt;br /&gt;&lt;br /&gt;A movie of its time, and place. 2/10.\",\n  'label.suggestion': 'negative',\n  'label.score': None},\n {'external_id': UUID('71b14ad5-2018-4396-b390-c28650d0bb95'),\n  'text': 'Oh, brother...after hearing about this ridiculous film for umpteen years all I can think of is that old Peggy Lee song..&lt;br /&gt;&lt;br /&gt;\"Is that all there is??\" ...I was just an early teen when this smoked fish hit the U.S. I was too young to get in the theater (although I did manage to sneak into \"Goodbye Columbus\"). Then a screening at a local film museum beckoned - Finally I could see this film, except now I was as old as my parents were when they schlepped to see it!!&lt;br /&gt;&lt;br /&gt;The ONLY reason this film was not condemned to the anonymous sands of time was because of the obscenity case sparked by its U.S. release. MILLIONS of people flocked to this stinker, thinking they were going to see a sex film...Instead, they got lots of closeups of gnarly, repulsive Swedes, on-street interviews in bland shopping malls, asinie political pretension...and feeble who-cares simulated sex scenes with saggy, pale actors.&lt;br /&gt;&lt;br /&gt;Cultural icon, holy grail, historic artifact..whatever this thing was, shred it, burn it, then stuff the ashes in a lead box!&lt;br /&gt;&lt;br /&gt;Elite esthetes still scrape to find value in its boring pseudo revolutionary political spewings..But if it weren\\'t for the censorship scandal, it would have been ignored, then forgotten.&lt;br /&gt;&lt;br /&gt;Instead, the \"I Am Blank, Blank\" rhythymed title was repeated endlessly for years as a titilation for porno films (I am Curious, Lavender - for gay films, I Am Curious, Black - for blaxploitation films, etc..) and every ten years or so the thing rises from the dead, to be viewed by a new generation of suckers who want to see that \"naughty sex film\" that \"revolutionized the film industry\"...&lt;br /&gt;&lt;br /&gt;Yeesh, avoid like the plague..Or if you MUST see it - rent the video and fast forward to the \"dirty\" parts, just to get it over with.&lt;br /&gt;&lt;br /&gt;',\n  'label.suggestion': 'negative',\n  'label.score': None}]</code>\n</pre> <pre><code>dataset.records.update(records=ds, mapping={\"label\": \"label.response\"})\n</code></pre> <pre>\n<code>WARNING:root:DatasetRecords: \n            No existing records founds to update. \n            If you want to add new records, you should use the `Dataset.records.add` method.\n\n</code>\n</pre> <pre><code>records = dataset.records.to_list()\nrecords[:5]\n</code></pre> <pre>\n<code>[{'external_id': UUID('5f604b00-e2b2-4c54-9a67-c563a1a09d05'),\n  'text': 'I rented I AM CURIOUS-YELLOW from my video store because of all the controversy that surrounded it when it was first released in 1967. I also heard that at first it was seized by U.S. customs if it ever tried to enter this country, therefore being a fan of films considered \"controversial\" I really had to see this for myself.&lt;br /&gt;&lt;br /&gt;The plot is centered around a young Swedish drama student named Lena who wants to learn everything she can about life. In particular she wants to focus her attentions to making some sort of documentary on what the average Swede thought about certain political issues such as the Vietnam War and race issues in the United States. In between asking politicians and ordinary denizens of Stockholm about their opinions on politics, she has sex with her drama teacher, classmates, and married men.&lt;br /&gt;&lt;br /&gt;What kills me about I AM CURIOUS-YELLOW is that 40 years ago, this was considered pornographic. Really, the sex and nudity scenes are few and far between, even then it\\'s not shot like some cheaply made porno. While my countrymen mind find it shocking, in reality sex and nudity are a major staple in Swedish cinema. Even Ingmar Bergman, arguably their answer to good old boy John Ford, had sex scenes in his films.&lt;br /&gt;&lt;br /&gt;I do commend the filmmakers for the fact that any sex shown in the film is shown for artistic purposes rather than just to shock people and make money to be shown in pornographic theaters in America. I AM CURIOUS-YELLOW is a good film for anyone wanting to study the meat and potatoes (no pun intended) of Swedish cinema. But really, this film doesn\\'t have much of a plot.',\n  'label.suggestion': 'negative',\n  'label.score': None},\n {'external_id': UUID('1d607171-fc90-40ec-880e-0f30ae8eff5a'),\n  'text': '\"I Am Curious: Yellow\" is a risible and pretentious steaming pile. It doesn\\'t matter what one\\'s political views are because this film can hardly be taken seriously on any level. As for the claim that frontal male nudity is an automatic NC-17, that isn\\'t true. I\\'ve seen R-rated films with male nudity. Granted, they only offer some fleeting views, but where are the R-rated films with gaping vulvas and flapping labia? Nowhere, because they don\\'t exist. The same goes for those crappy cable shows: schlongs swinging in the breeze but not a clitoris in sight. And those pretentious indie movies like The Brown Bunny, in which we\\'re treated to the site of Vincent Gallo\\'s throbbing johnson, but not a trace of pink visible on Chloe Sevigny. Before crying (or implying) \"double-standard\" in matters of nudity, the mentally obtuse should take into account one unavoidably obvious anatomical difference between men and women: there are no genitals on display when actresses appears nude, and the same cannot be said for a man. In fact, you generally won\\'t see female genitals in an American film in anything short of porn or explicit erotica. This alleged double-standard is less a double standard than an admittedly depressing ability to come to terms culturally with the insides of women\\'s bodies.',\n  'label.suggestion': 'negative',\n  'label.score': None},\n {'external_id': UUID('10bf877f-f0c8-457b-a35e-9df8a745e0f9'),\n  'text': \"If only to avoid making this type of film in the future. This film is interesting as an experiment but tells no cogent story.&lt;br /&gt;&lt;br /&gt;One might feel virtuous for sitting thru it because it touches on so many IMPORTANT issues but it does so without any discernable motive. The viewer comes away with no new perspectives (unless one comes up with one while one's mind wanders, as it will invariably do during this pointless film).&lt;br /&gt;&lt;br /&gt;One might better spend one's time staring out a window at a tree growing.&lt;br /&gt;&lt;br /&gt;\",\n  'label.suggestion': 'negative',\n  'label.score': None},\n {'external_id': UUID('c7bddb86-4303-4365-acff-c05bc60cbba0'),\n  'text': \"This film was probably inspired by Godard's Masculin, f\u00e9minin and I urge you to see that film instead.&lt;br /&gt;&lt;br /&gt;The film has two strong elements and those are, (1) the realistic acting (2) the impressive, undeservedly good, photo. Apart from that, what strikes me most is the endless stream of silliness. Lena Nyman has to be most annoying actress in the world. She acts so stupid and with all the nudity in this film,...it's unattractive. Comparing to Godard's film, intellectuality has been replaced with stupidity. Without going too far on this subject, I would say that follows from the difference in ideals between the French and the Swedish society.&lt;br /&gt;&lt;br /&gt;A movie of its time, and place. 2/10.\",\n  'label.suggestion': 'negative',\n  'label.score': None},\n {'external_id': UUID('ee08db3b-f3da-4bb2-860a-4242e743b7d8'),\n  'text': 'Oh, brother...after hearing about this ridiculous film for umpteen years all I can think of is that old Peggy Lee song..&lt;br /&gt;&lt;br /&gt;\"Is that all there is??\" ...I was just an early teen when this smoked fish hit the U.S. I was too young to get in the theater (although I did manage to sneak into \"Goodbye Columbus\"). Then a screening at a local film museum beckoned - Finally I could see this film, except now I was as old as my parents were when they schlepped to see it!!&lt;br /&gt;&lt;br /&gt;The ONLY reason this film was not condemned to the anonymous sands of time was because of the obscenity case sparked by its U.S. release. MILLIONS of people flocked to this stinker, thinking they were going to see a sex film...Instead, they got lots of closeups of gnarly, repulsive Swedes, on-street interviews in bland shopping malls, asinie political pretension...and feeble who-cares simulated sex scenes with saggy, pale actors.&lt;br /&gt;&lt;br /&gt;Cultural icon, holy grail, historic artifact..whatever this thing was, shred it, burn it, then stuff the ashes in a lead box!&lt;br /&gt;&lt;br /&gt;Elite esthetes still scrape to find value in its boring pseudo revolutionary political spewings..But if it weren\\'t for the censorship scandal, it would have been ignored, then forgotten.&lt;br /&gt;&lt;br /&gt;Instead, the \"I Am Blank, Blank\" rhythymed title was repeated endlessly for years as a titilation for porno films (I am Curious, Lavender - for gay films, I Am Curious, Black - for blaxploitation films, etc..) and every ten years or so the thing rises from the dead, to be viewed by a new generation of suckers who want to see that \"naughty sex film\" that \"revolutionized the film industry\"...&lt;br /&gt;&lt;br /&gt;Yeesh, avoid like the plague..Or if you MUST see it - rent the video and fast forward to the \"dirty\" parts, just to get it over with.&lt;br /&gt;&lt;br /&gt;',\n  'label.suggestion': 'negative',\n  'label.score': None}]</code>\n</pre> <p>In this way, we could also handle diverse naming in our source data, so we could deal with:</p> <pre><code>source_data = [{\"x\": \"I'm a data sample in a dataset with vague field names :(\", \"y\": \"negative\", \"idx\": \"90146\"}]\ndataset.records.add(records=source_data, mapping={\"y\": \"label\", \"x\": \"text\", \"idx\": \"id\"})\n</code></pre>"},{"location":"_source/tutorials/quickstart-tutorial/#end-to-end-tutorial-for-using-the-new-argilla-sdk","title":"End to end tutorial for using the new Argilla SDK","text":"<p>This tutorial encomposses the full workflow of using the Argilla SDK to manage human feedback tasks. The main three areas are:</p> <ol> <li>Setting up a project:</li> <li>Connecting to an Argilla server:</li> <li>Creating a workspace:</li> <li>Creating users:</li> <li>Creating a dataset:</li> <li>Defining the dataset's feedback task:</li> <li>Adding records to the dataset:</li> <li>Manipulating records:</li> <li>Adding records with suggestions</li> <li>Adding or Updating records with responses</li> </ol> <p>We will work through each of these areas and show three depths of control: A line, B line, and C line. The A line is the simplest and most abstracted, the B line is a bit more detailed, and the C line is the most detailed and flexible.</p>"},{"location":"_source/tutorials/quickstart-tutorial/#1-setting-up-a-project","title":"1. Setting up a project","text":"<ul> <li>Connecting to an Argilla server</li> <li>Creating a workspace</li> <li>Creating users</li> </ul>"},{"location":"_source/tutorials/quickstart-tutorial/#workspaces","title":"Workspaces","text":"datasetsnameidupdated_at749admin47a2ace0-a9b2-4dde-9710-0656646a3de32024-01-31T18:48:50.8565841new_wsb4b7410c-7014-4ae4-a923-ec095d4a72722024-03-19T05:59:06.3622750end-to-ende5bf1534-b89a-4245-9a30-99284710a1a92024-04-08T13:41:11.967896"},{"location":"_source/tutorials/quickstart-tutorial/#2-creating-a-dataset","title":"2. Creating a dataset","text":"<ul> <li>Defining the dataset's feedback task</li> <li>Adding records to the dataset</li> <li>Collecting the records</li> </ul>"},{"location":"_source/tutorials/quickstart-tutorial/#3-manipulating-records","title":"3. Manipulating records","text":""},{"location":"_source/tutorials/quickstart-tutorial/#adding-records-with-suggestions","title":"Adding records with suggestions","text":"<p>Argilla handles labels in the dataset with the same name as the question as suggestions. For example, if you have a <code>rg.TextQuestion(name=\"label\")</code> and a <code>label</code> key in your sample, Argilla will assign the values of <code>label</code> to the question <code>label</code>. Below we'll customize this behaviour.</p>"},{"location":"_source/tutorials/quickstart-tutorial/#adding-or-updating-records-with-reponses","title":"Adding or updating records with reponses","text":"<p>Let's say that the source data contains responses that we want to handle as true values, for example mannually annotated labels. We can use a  <code>mapping</code> to map the keys in our source data to Argilla questions, and specify <code>response</code>. </p>"},{"location":"how_to_guides/","title":"How-to guides","text":"<p>These are the how-to guides for the Argilla-python SDK. They provide step-by-step instructions for common scenarios, including detailed explanations and code samples.</p> <ul> <li> <p> Manage users, credentials, and workspaces</p> <p>Learn what they are and how to manage (create, read and delete) <code>Users</code> and <code>Workspaces</code> in Argilla.</p> <p> How-to guide</p> </li> <li> <p> Manage and create datasets</p> <p>Learn what they are and how to manage (create, read and delete) <code>Datasets</code> and customize them using the <code>Settings</code> for <code>Fields</code>, <code>Questions</code>,  <code>Metadata</code> and <code>Vectors</code>.</p> <p> How-to guide</p> </li> <li> <p> Add, update, and delete records</p> <p>Learn what they are and how to add, update and delete the values for a <code>Record</code>, which are made up of <code>Metadata</code>, <code>Vectors</code>, <code>Suggestions</code> and <code>Responses</code>.</p> <p> How-to guide</p> </li> <li> <p> Query, filter and export records</p> <p>Learn how to query and filter a <code>Dataset</code> and export their <code>Records</code>.</p> <p> How-to guide</p> </li> </ul>"},{"location":"how_to_guides/dataset/","title":"Dataset management","text":"<p>This guide provides an overview of datasets, explaining the basics of how to set them up and manage them in Argilla.</p> <p>A dataset is a collection of records that you can configure for labelers to provide feedback using the UI. Depending on the specific requirements of your task, you may need various types of feedback. You can customize the dataset to include different kinds of questions, so the first step will be to define the aim of your project and the kind of data and feedback you will need. With this information, you can start configuring a dataset by defining fields, questions, metadata, vectors, and guidelines through settings.</p> <p>Question: Who can manage datasets?</p> <p>Only users with the <code>owner</code> role can manage (create, retrieve, update and delete) all the datasets.</p> <p>The users with the <code>admin</code> role can manage (create, retrieve, update and delete) the datasets in the workspaces they have access to.</p>"},{"location":"how_to_guides/dataset/#rgdataset","title":"rg.Dataset","text":"<p>A dataset in Argilla is represented by the <code>Dataset</code> class. You can indicate the <code>workspace</code> where you want to store your dataset by providing the object or their name. If not, the dataset will be stored in the first workspace. To customize it, you should pass the <code>settings</code> with the fields, questions, metadata, vectors, and guidelines.</p> <p>Check the Dataset - Python Reference to see the attributes, arguments, and methods of the <code>Dataset</code> class in detail.</p> <pre><code>rg.Dataset(\n    name=\"name\",\n    workspace=workspace,\n    settings=settings,\n    status=\"ready\",\n    client=client,\n)\n</code></pre>"},{"location":"how_to_guides/dataset/#rgsettings","title":"rg.Settings","text":"<p>The settings of a Dataset are represented in the <code>Settings</code> class where you can indicate the <code>fields</code> and the <code>questions</code> that annotators will need to answer to provide feedback. Optionally, you can add <code>metadata</code>, <code>vectors</code> and <code>guidelines</code>. We will cover each of these settings in detail in the following section.</p> <p>Check the Settings - Python Reference to see the attributes, arguments, and methods of the <code>Settings</code> class in detail.</p> <pre><code>rg.Settings(\n    fields = [\n        rg.TextField(name=\"text\")\n        ],\n    questions = [\n        rg.LabelQuestion(\n            name=\"label\",\n            labels=[\"label_1\", \"label_2\", \"label_3\"]\n            )\n        ],\n    metadata = [\n        rg.TermsMetadataProperty(\n            name=\"metadata\",\n            options=[\"option_1\", \"option_2\", \"option_3\"]\n            )\n        ],\n    vectors = [\n        rg.VectorField(name=\"vector\", dimensions=10)\n        ],\n    guidelines = \"guidelines\",\n    allow_extra_metadata = True,\n)\n</code></pre>"},{"location":"how_to_guides/dataset/#how-to-guide","title":"How-to guide","text":"<p>This section starts by showing how to create a basic dataset in Argilla and define its settings, and then how to list all the datasets available in each workspace and retrieve a specific one. Finally, the guide covers the steps to update and delete a dataset.</p>"},{"location":"how_to_guides/dataset/#create-a-dataset","title":"Create a dataset","text":"<p>To create a dataset, you can define it in the <code>Dataset</code> class and then call the <code>publish</code> method that will send the dataset to the server so that it can be visualized in the UI. If the dataset does not appear in the UI, you may need to click the refresh button to update the view. For further configuration of the dataset, you can refer to the settings section.</p> <p>The created dataset will be empty, to add the records refer to this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nsettings = rg.Settings(\n    guidelines=\"These are some guidelines.\",\n    fields=[\n        rg.TextField(\n            name=\"text\",\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(name=\"label\", labels=[\"label_1\", \"label_2\", \"label_3\"]),\n    ],\n)\n\ndataset = rg.Dataset(\n    name=\"my_dataset\",\n    workspace=\"my_workspace\",\n    settings=settings,\n    client=client,\n)\n\ndataset.publish()\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a dataset by calling them directly on the <code>dataset</code> object. For example, <code>dataset.id</code>, <code>dataset.name</code> or <code>dataset.settings</code>. You can similarly access the fields, questions, metadata, vectors and guidelines. For instance, <code>dataset.fields</code> or <code>dataset.questions</code>.</p>"},{"location":"how_to_guides/dataset/#define-dataset-settings","title":"Define dataset settings","text":""},{"location":"how_to_guides/dataset/#fields","title":"Fields","text":"<p>The fields in a dataset consist of one or more data items requiring annotation. Currently, Argilla only supports the <code>TextField</code> type\u2014a plain text field\u2014though there are plans to introduce additional field types in future updates.</p> <p>A field is defined in the <code>TextField</code> class that has the following arguments:</p> <ul> <li><code>name</code>: The name of the field.</li> <li><code>title</code> (optional): The name of the field, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The description of the field, as it will be displayed in the UI. Defaults to <code>None</code>.</li> <li><code>required</code> (optional): Whether the field is required or not. Defaults to <code>True</code>. At least one field must be required.</li> <li><code>use_markdown</code> (optional): Specify whether you want markdown rendered in the UI. Defaults to <code>False</code>. If you set it to True, you will be able to use all the Markdown features for text formatting, as well as embed multimedia content and PDFs.</li> </ul> <p>Note</p> <p>The order of the fields in the UI follows the order in which these are added to the fields attribute in the Python SDK.</p> <p><pre><code>rg.TextField(\n    name=\"text\",\n    title=\"Text\",\n    description=\"The text to be annotated\",\n    required=True,\n    use_markdown=False\n)\n</code></pre> </p>"},{"location":"how_to_guides/dataset/#questions","title":"Questions","text":"<p>To collect feedback for your dataset, you need to formulate questions that annotators will be asked to answer. Currently, Argilla supports the following types of questions: <code>LabelQuestion</code>, <code>MultiLabelQuestion</code>, <code>RankingQuestion</code>, <code>RatingQuestion</code>, <code>SpanQuestion</code>, and <code>TextQuestion</code>.</p> LabelMulti-labelRankingRatingSpanText <p>A <code>LabelQuestion</code> asks annotators to choose a unique label from a list of options. This type is useful for text classification tasks. In the UI, they will have a rounded shape. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text displayed in the UI.</li> </ul> <p><pre><code>rg.LabelQuestion(\n    name=\"label\",\n    title=\"Is the response relevant for the given prompt?\",\n    description=\"Select the one that applies.\",\n    required=True,\n    labels={\"YES\": \"Yes\", \"NO\": \"No\"}, # or [\"YES\", \"NO\"]\n)\n</code></pre> </p> <p>A <code>MultiLabelQuestion</code> asks annotators to choose all applicable labels from a list of options. This type is useful for multi-label text classification tasks. In the UI, they will have a squared shape. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text displayed in the UI.</li> <li><code>visible_labels</code> (optional): The number of labels that will be visible at first sight in the UI. By default, the UI will show 20 labels and collapse the rest. Set your preferred number to change this limit or set <code>visible_labels=None</code> to show all options.</li> </ul> <p><pre><code>rg.MultiLabelQuestion(\n    name=\"multi_label\",\n    title=\"Does the response include any of the following?\",\n    description=\"Select all that apply.\",\n    required=True,\n    labels={\n        \"hate\": \"Hate Speech\",\n        \"sexual\": \"Sexual content\",\n        \"violent\": \"Violent content\",\n        \"pii\": \"Personal information\",\n        \"untruthful\": \"Untruthful info\",\n        \"not_english\": \"Not English\",\n        \"inappropriate\": \"Inappropriate content\"\n    }, # or [\"hate\", \"sexual\", \"violent\", \"pii\", \"untruthful\", \"not_english\", \"inappropriate\"]\n    visible_labels=4\n)\n</code></pre> </p> <p>A <code>RankingQuestion</code> asks annotators to order a list of options. It is useful to gather information on the preference or relevance of a set of options. Ties are allowed and all options will need to be ranked. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>values</code>: A list of strings with the options they will need to rank. If you'd like the text of the options to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value is the text to display in the UI.</li> </ul> <pre><code>rg.RankingQuestion(\n    name=\"ranking\",\n    title=\"Order replies based on your preference\",\n    description=\"1 = best, 3 = worst. Ties are allowed.\",\n    required=True,\n    values={\n        \"reply-1\": \"Reply 1\",\n        \"reply-2\": \"Reply 2\",\n        \"reply-3\": \"Reply 3\"\n    } # or [\"reply-1\", \"reply-2\", \"reply-3\"]\n)\n</code></pre> <p></p> <p>A <code>RatingQuestion</code> asks annotators to select one option from a list of integer values. This type is useful for collecting numerical scores. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>values</code>: A list of unique integers representing the scores that annotators can select from should be defined within the range [1, 10].</li> </ul> <pre><code>rg.RatingQuestion(\n    name=\"rating\",\n    title=\"How satisfied are you with the response?\",\n    description=\"1 = very unsatisfied, 10 = very satisfied\",\n    required=True,\n    values=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n)\n</code></pre> <p></p> <p>A <code>SpanQuestion</code> asks annotators to select a portion of the text of a specific field and apply a label to it. This type of question is useful for named entity recognition or information extraction tasks. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text to display in the UI.</li> <li><code>field</code>: This question is always attached to a specific field. You should pass a string with the name of the field where the labels of the <code>SpanQuestion</code> should be used.</li> <li><code>allow_overlapping</code>: This value specifies whether overlapped spans are allowed or not. Defaults to <code>False</code>.</li> <li><code>visible_labels</code> (optional): The number of labels that will be visible at first sight in the UI. By default, the UI will show 20 labels and collapse the rest. Set your preferred number to change this limit or set <code>visible_labels=None</code> to show all options.</li> </ul> <pre><code>rg.SpanQuestion(\n    name=\"span\",\n    title=\"Select the entities in the text\",\n    description=\"Select the entities in the text\",\n    required=True,\n    labels={\n        \"PERSON\": \"Person\",\n        \"ORG\": \"Organization\",\n        \"LOC\": \"Location\",\n        \"MISC\": \"Miscellaneous\"\n        },\n    field=\"text\",\n    allow_overlapping=False,\n    visible_labels=None\n)\n</code></pre> <p></p> <p>A <code>TextQuestion</code> offers to annotators a free-text area where they can enter any text. This type is useful for collecting natural language data, such as corrections or explanations. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>use_markdown</code> (optional): Define whether the field should render markdown text. Defaults to <code>False</code>. If you set it to <code>True</code>, you will be able to use all the Markdown features for text formatting, as well as embed multimedia content and PDFs.</li> </ul> <pre><code>rg.TextQuestion(\n    name=\"text\",\n    title=\"Please provide feedback on the response\",\n    description=\"Please provide feedback on the response\",\n    required=True,\n    use_markdown=True\n)\n</code></pre> <p></p>"},{"location":"how_to_guides/dataset/#metadata","title":"Metadata","text":"<p>Metadata properties allow you to configure the use of metadata information for the filtering and sorting features available in the UI and Python SDK. There exist three types of metadata you can add: <code>TermsMetadataProperty</code>, <code>IntegerMetadataProperty</code> and <code>FloatMetadataProperty</code>.</p> TermsIntegerFloat <p>A <code>TermsMetadataProperty</code> allows to add a list of strings as metadata options. It has the following configuration:  </p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>options</code>: You can pass a list of valid values for this metadata property, in case you want to run any validation.</li> </ul> <p><pre><code>rg.TermsMetadataProperty(\n    name=\"terms\",\n    title=\"Annotation groups\",\n    options=[\"group-a\", \"group-b\", \"group-c\"]\n)\n</code></pre> </p> <p>An <code>IntegerMetadataProperty</code> allows to add integer values as metadata. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>min</code>: You can pass a minimum valid value. If none is provided, the minimum value will be computed from the values provided in the records.</li> <li><code>max</code>: You can pass a maximum valid value. If none is provided, the maximum value will be computed from the values provided in the records.</li> </ul> <p><pre><code>rg.IntegerMetadataProperty(\n    name=\"integer\",\n    title=\"length-input\",\n    min=50,\n    max=1897,\n)\n</code></pre> </p> <p>A <code>FloatMetadataProperty</code> allows to add float values as metadata. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>min</code>: You can pass a minimum valid value. If none is provided, the minimum value will be computed from the values provided in the records.</li> <li><code>max</code>: You can pass a maximum valid value. If none is provided, the maximum value will be computed from the values provided in the records.</li> </ul> <p><pre><code>rg.FloatMetadataProperty(\n    name=\"float\",\n    title=\"Reading ease\",\n    min=-92.29914,\n    max=119.6975,\n)\n</code></pre> </p>"},{"location":"how_to_guides/dataset/#vectors","title":"Vectors","text":"<p>To use the similarity search in the UI and the Python SDK, you will need to configure vectors using the <code>VectorField</code> class. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the vector.</li> <li><code>title</code> (optional): A name for the vector to display in the UI for better readability.</li> <li><code>dimensions</code>: The dimensions of the vectors used in this setting.</li> </ul> <p><pre><code>rg.VectorField(\n    name=\"my_vector\",\n    title=\"My Vector\",\n    dimensions=768\n),\n</code></pre> </p>"},{"location":"how_to_guides/dataset/#guidelines","title":"Guidelines","text":"<p>Once you have decided on the data to show and the questions to ask, it's important to provide clear guidelines to the annotators. These guidelines help them understand the task and answer the questions consistently. You can provide guidelines in two ways:</p> <ul> <li> <p>In the dataset guidelines: this is added as an argument when you create your dataset in the Python SDK. It will appear in the dataset settings in the UI. <pre><code>guidelines = \"In this dataset, you will find a collection of records that show a category, an instruction, a context and a response to that instruction. [...]\"\n</code></pre> </p> </li> <li> <p>As question descriptions: these are added as an argument when you create questions in the Python SDK. This text will appear in a tooltip next to the question in the UI. </p> </li> </ul> <p>It is good practice to use at least the dataset guidelines if not both methods. Question descriptions should be short and provide context to a specific question. They can be a summary of the guidelines to that question, but often that is not sufficient to align the whole annotation team. In the guidelines, you can include a description of the project, details on how to answer each question with examples, instructions on when to discard a record, etc.</p> <p>Tip</p> <p>If you want further guidance on good practices for guidelines during the project development, check our blog post.</p>"},{"location":"how_to_guides/dataset/#list-datasets","title":"List datasets","text":"<p>You can list all the datasets available in a workspace using the <code>datasets</code> attribute of the <code>Workspace</code> class. You can also use <code>len(workspace.datasets)</code> to get the number of datasets in a workspace.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndatasets = workspace.datasets\n\nfor dataset in datasets:\n    print(dataset)\n</code></pre>"},{"location":"how_to_guides/dataset/#retrieve-a-dataset","title":"Retrieve a dataset","text":"<p>You can retrieve a dataset by calling the <code>datasets</code> method on the <code>Argilla</code> class and passing the name of the dataset as an argument. By default, this method attempts to retrieve the dataset from the first workspace. If the dataset is in a different workspace, you must specify either the workspace name or id as an argument.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\n# Retrieve the dataset from the first workspace\nretrieved_dataset = client.datasets(name=\"my_dataset\")\n\n# Retrieve the dataset from the specified workspace\nretrieved_dataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n</code></pre>"},{"location":"how_to_guides/dataset/#check-dataset-existence","title":"Check dataset existence","text":"<p>You can check if a dataset exists by calling the <code>exists</code> method on the <code>Dataset</code> class. This method returns a boolean value.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset = client.datasets(name=\"my_dataset\")\n\ndataset_existed = dataset.exists()\ndataset_existed\n</code></pre>"},{"location":"how_to_guides/dataset/#update-a-dataset","title":"Update a dataset","text":"<p>You can update a dataset by calling the <code>update</code> method on the <code>Dataset</code> class and passing the new settings as an argument.</p> <p>For further information on how to update the dataset settings (fields, questions, metadata, vectors and guidelines), check this how-to guide.</p> <p>Note</p> <p>Keep in mind that once your dataset is published, only the guidelines can be updated.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset_to_update = client.datasets(name=\"my_dataset\")\n\nsettings_to_update = rg.Settings(\n    guidelines=\"These are some updated guidelines.\",\n    fields=[\n        rg.TextField(\n            name=\"text\",\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(name=\"label\", labels=[\"label_4\", \"label_5\", \"label_6\"]),\n    ],\n)\n\ndataset_to_update.settings = settings_to_update\n\ndataset_updated = dataset_to_update.update()\ndataset_updated\n</code></pre>"},{"location":"how_to_guides/dataset/#delete-a-dataset","title":"Delete a dataset","text":"<p>You can delete an existing dataset by calling the <code>delete</code> method on the <code>Dataset</code> class.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset_to_delete = client.datasets(name=\"my_dataset\")\n\ndataset_deleted = dataset_to_delete.delete()\n</code></pre>"},{"location":"how_to_guides/fine_tune/","title":"Fine-tune","text":"<p>These are the how-to guides for the Argilla-python SDK. They provide step-by-step instructions for common scenarios, including detailed explanations and code samples.</p>"},{"location":"how_to_guides/query_export/","title":"Query, filter, and export records","text":"<p>This guide provides an overview of how to query and filter a dataset in Argilla and export records.</p> <p>You can search for records in your dataset by querying or filtering. The query focuses on the content of the text field, while the filter is used to filter the records based on conditions. You can use them independently or combine multiple filters to create complex search queries. You can also export records from a dataset either as a single dictionary or a list of dictionaries.</p>"},{"location":"how_to_guides/query_export/#rgquery-and-rgfilter","title":"rg.Query and rg.Filter","text":"<p>A query is defined in the <code>Query</code> class that you can use to search for terms or filter records based on conditions. To specify a condition, you should use a tuple or a list of tuples with the following structure: <code>(field, operator, value)</code>. Below, you can see the operators you can use to filter records.</p> operator description <code>==</code> The <code>field</code> value is equal to the <code>value</code> <code>&gt;=</code> The <code>field</code> value is greater than or equal to the <code>value</code> <code>&lt;=</code> The <code>field</code> value is less than or equal to the <code>value</code> <code>in</code> TThe <code>field</code> value is included in a list of values <p>Check the Query and Filter - Python Reference to see the attributes, arguments, and methods of the <code>Query</code> and <code>Filter</code> classes in detail.</p> <pre><code>rg.Query(\n    query=\"query\",\n    filter=rg.Filter(\n        [\n            (\"field\", \"==\", \"value\"),\n            (\"field\", \"&gt;=\", 10),\n            (\"field\", \"&lt;=\", 20),\n            (\"field\", \"in\", [\"value1\", \"value2\"])\n        ]\n    )\n)\n</code></pre>"},{"location":"how_to_guides/query_export/#how-to-guide","title":"How-to guide","text":"<p>This section shows how to query a dataset in Argilla using specific terms or filters, and export records.</p>"},{"location":"how_to_guides/query_export/#query-with-search-terms","title":"Query with search terms","text":"<p>To search for records with terms, you can use the <code>Dataset.records</code> attribute with a query string. The search terms are used to search for records that contain the terms in the text field. You can search a single term or various terms, in the latter, all of them should appear in the record to be retrieved.</p> Single search termMultiple search term <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery = rg.Query(query=\"my_term\")\n\nqueried_records = list(dataset.records(query=query))\nqueried_records\n</code></pre> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery = rg.Query(query=\"my_term1 my_term2\")\n\nqueried_records = list(dataset.records(query=query))\nqueried_records\n</code></pre>"},{"location":"how_to_guides/query_export/#filter-by-conditions","title":"Filter by conditions","text":"<p>You can use the <code>Filter</code> class to define the conditions and pass them to the <code>Dataset.records</code> attribute to fetch records based on the conditions. Conditions include \"==\", \"&gt;=\", \"&lt;=\", or \"in\". Conditions can be combined with dot notation to filter records based on metadata, suggestions, or responses. You can use a single condition or multiple conditions to filter records.</p> Single conditionMultiple conditions <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nfilter_label = rg.Filter((\"label\", \"==\", \"positive\"))\n\nfiltered_records = list(dataset.records(query=rg.Query(filter=filter_label)))\nfiltered_records\n</code></pre> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nfilters = rg.Filter(\n    [\n        (\"label.suggestion\", \"==\", \"positive\"),\n        (\"metadata.count\", \"&gt;=\", 10),\n        (\"metadata.count\", \"&lt;=\", 20),\n        (\"label\", \"in\", [\"positive\", \"negative\"])\n    ]\n)\n\nfiltered_records = list(dataset.records(\n    query=rg.Query(filter=filters)),\n    with_metadata=True,\n    with_suggestions=True\n)\nfiltered_records\n</code></pre>"},{"location":"how_to_guides/query_export/#query-and-filter-a-dataset","title":"Query and filter a dataset","text":"<p>As mentioned, you can use a query with a search term and a filter or various filters to create complex search queries.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery_filter = rg.Query(\n    query=\"my_term\",\n    filter= rg.Filter(\n        [\n            (\"label.suggestion\", \"==\", \"positive\"),\n            (\"metadata.count\", \"&gt;=\", 10),\n        ]\n    )\n)\n\nqueried_filtered_records = list(dataset.records(\n    query=query_filter,\n    with_metadata=True,\n    with_suggestions=True\n    )\n)\nqueried_filtered_records\n</code></pre>"},{"location":"how_to_guides/query_export/#export-records-to-a-dictionary","title":"Export records to a dictionary","text":"<p>Records can be exported from <code>Dataset.records</code> as a dictionary. The <code>to_dict</code> method can be used to export records as a dictionary. You can specify the orientation of the dictionary output. You can also decide if to flatten or not the dictionary.</p> <p>=== \" <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\n# Export records as a dictionary\nexported_records = dataset.records.to_dict()\nexported_records\n# {\"text\": [\"Hello\", \"World\"], \"label.suggestion\": [\"greeting\", \"greeting\"]}\n\n# Export records as a dictionary with orient=index\nexported_records = dataset.records.to_dict(orient=\"index\")\nexported_records\n# {\"uuid\": {\"text\": \"Hello\", \"label\": \"greeting\"}}\n\n# Export records as a dictionary with flatten=false\nexported_records = dataset.records.to_dict(flatten=False)\nexported_records\n# {'fields': [{'text': 'Hello'},{'text': 'World'}], suggestions': [{'label': {'value': 'positive'}}, {'label': {'value': 'negative'}}]\n</code></pre></p>"},{"location":"how_to_guides/query_export/#export-records-to-a-list","title":"Export records to a list","text":"<p>Records can be exported from <code>Dataset.records</code> as a list of dictionaries. The <code>to_list</code> method can be used to export records as a list of dictionaries. You can decide if to flatten it or not.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\n# Export records as a list of dictionaries\nexported_records = dataset.records.to_list()\nexported_records\n# [{\"text\": \"Hello\", \"label\": \"greeting\"}, {\"text\": \"World\", \"label\": \"greeting\"}]\n\n# Export records as a list of dictionaries with flatten=False\nexported_records = dataset.records.to_list(flatten=False)\nexported_records\n# [{'fields': {'text': 'Hello'}, 'suggestion': {'label': {value: 'greeting'}}}, {'fields': {'text': 'World'}, 'suggestion': {'label': {value: 'greeting'}}}]\n</code></pre>"},{"location":"how_to_guides/record/","title":"Add, update, and delete records","text":"<p>This guide provides an overview of records, explaining the basics of how to define and manage them in Argilla.</p> <p>A record in Argilla is a data item that requires annotation, consisting of one or more fields. These are the pieces of information displayed to the user in the UI to facilitate the completion of the annotation task. Each record also includes questions that annotators are required to answer, with the option of adding suggestions and responses to assist them. Guidelines are also provided to help annotators effectively complete their tasks.</p> <p>A record is part of a dataset, so you will need to create a dataset before adding records. Check these guides to learn how to create a dataset.</p>"},{"location":"how_to_guides/record/#rgrecord","title":"rg.Record","text":"<p>You can add records to a dataset as dictionaries or instances of the <code>Record</code> class. A record will match the fields, metadata and vectors defined in the dataset settings. You can also add suggestions and responses to the records to help the annotators complete their tasks.</p> <p>Check the Record - Python Reference to see the attributes, arguments, and methods of the <code>Record</code> class in detail.</p> As a dictionaryAs a <code>Record</code> object <pre><code>record = {\n    \"question\": \"Do you need oxygen to breathe?\",\n    \"answer\": \"Yes\",\n    \"category\": \"A\",\n    \"my_vector\": [0.1, 0.2, 0.3],\n    \"my_label\": \"negative\",\n    \"my_label.score\": 0.9,\n    \"my_label.agent\": \"model_name\",\n    \"my_label.response\": \"positive\"\n    },\n</code></pre> <pre><code>rg.Record(\n    external_id=\"1234\",\n    fields={\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\"\n        },\n    metadata={\n        \"category\": \"A\"\n        },\n    vectors={\n        \"my_vector\": [0.1, 0.2, 0.3],\n        },\n    suggestions=[\n        rg.Suggestion(\"my_label\", \"positive\", score=0.9, agent=\"model_name\")\n        ],\n    responses=[\n        rg.Response(\"label\", \"positive\", user_id=user_id)\n        ],\n)\n</code></pre>"},{"location":"how_to_guides/record/#how-to-guide","title":"How-to guide","text":"<p>This section shows how to add records in Argilla with metadata, vectors, suggestions and responses. It also explains how to list and update them.</p>"},{"location":"how_to_guides/record/#add-records","title":"Add records","text":"<p>You can add records to a dataset in two different ways: either by using a dictionary or by directly initializing a <code>Record</code> object. You should ensure that fields, metadata and vectors match those configured in the dataset settings. In both cases, are added via the <code>Dataset.records.add</code> method. As soon as you add the records, these will be available in the Argilla UI. If they do not appear in the UI, you may need to click the refresh button to update the view.</p> <p>Tip</p> <p>Take some time to inspect the data before adding it to the dataset in case this triggers changes in the <code>questions</code> or <code>fields</code>.</p> <p>Note</p> <p>If you are planning to use public data, the Datasets page of the Hugging Face Hub is a good place to start. Remember to always check the license to make sure you can legally use it for your specific use case.</p> As a dictionaryAs a <code>Record</code> object <p>You can add the data directly as a dictionary, where the keys correspond to the names of fields, questions, metadata or vectors in the dataset and the values are the data to be added. However, you can also use a mapping to specify the data structure.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\n# Add records to the dataset with the fields 'question' and 'answer'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n    },\n]\ndataset.records.add(data)\n\n# Add records to the dataset with the a mapping of the fields\ndata = [\n    {\n        \"query\": \"Do you need oxygen to breathe?\",\n        \"response\": \"Yes\",\n    },\n    {\n        \"query\": \"What is the boiling point of water?\",\n        \"response\": \"100 degrees Celsius\",\n    },\n]\ndataset.records.add(data, mapping={\"query\": \"question\", \"response\": \"answer\"})\n</code></pre> <p>HF example</p> <pre><code>import datasets\nfrom datasets import load_dataset\nfrom uuid import uuid4\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\nworkspace = client.workspaces(\"my_workspace\")\nuser_id = client.users(\"my_user\").id\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nhf_dataset = load_dataset(\"imdb\", split=\"train[:100]\").to_list()\nrecords = [\n    {\n        \"text\": sample[\"text\"],\n        \"label\": \"positive\" if sample[\"label\"] == 1 else \"negative\",\n        \"external_id\": uuid4()\n    }\n    for sample in hf_dataset\n]\n\n\ndataset.records.add(records, user_id=user_id)\n</code></pre> <p>You can also add records to a dataset by initializing a <code>Record</code> object directly.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n    ),\n]\n\ndataset.records.add(records)\n</code></pre> <p>HF example</p> <pre><code>import datasets\nfrom datasets import load_dataset\nfrom uuid import uuid4\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\nworkspace = client.workspaces(\"my_workspace\")\nuser_id = client.users(\"my_user\").id\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nhf_dataset = load_dataset(\"imdb\", split=\"train[:100]\").to_list()\nrecords = [\n    rg.Record(\n        fields={\"text\": sample[\"text\"]}\n        responses=[\n            rg.Response(\n                \"label\",\n                \"positive\" if sample[\"label\"] == 1 else \"negative\",\n                user_id=user_id)\n            ],\n        external_id=uuid4()\n    )\n    for sample in hf_dataset\n]\n\ndataset.records.add(records)\n</code></pre>"},{"location":"how_to_guides/record/#metadata","title":"Metadata","text":"<p>Record metadata can include any information about the record that is not part of the fields in the form of a dictionary. To use metadata for filtering and sorting records, make sure that the key of the dictionary corresponds with the metadata property <code>name</code>. When the key doesn't correspond, this will be considered extra metadata that will get stored with the record (as long as <code>allow_extra_metadata</code> is set to <code>True</code> for the dataset), but will not be usable for filtering and sorting.</p> <p>Note</p> <p>Remember that to use metadata within a dataset, you must define a metadata property in the dataset settings.</p> As part of a dictionaryAs part of a <code>Record</code> object <p>You can add metadata to a record directly as a dictionary, where the keys correspond to the names of metadata properties in the dataset and the values are the metadata to be added. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code># Add records to the dataset with the metadata 'category'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"category\": \"A\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"category\": \"B\",\n    },\n]\ndataset.records.add(data)\n</code></pre> <p>You can also add metadata to a record in an initialized <code>Record</code> object.</p> <pre><code># Add records to the dataset with the metadata 'category'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        metadata={\"category\": \"A\"},\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        metadata={\"category\": \"B\"},\n    ),\n]\ndataset.records.add(records)\n</code></pre>"},{"location":"how_to_guides/record/#vectors","title":"Vectors","text":"<p>You can associate vectors, like text embeddings, to your records. They can be used for semantic search in the UI and the Python SDK. Make sure that the length of the list corresponds to the dimensions set in the vector settings.</p> <p>Note</p> <p>Remember that to use vectors within a dataset, you must define them in the dataset settings.</p> As part of a dictionaryAs part of a <code>Record</code> object <p>You can add vectors as a dictionary, where the keys correspond to the <code>name</code>s of the vector settings that were configured for your dataset and the value is a list of floats. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code># Add records to the dataset with the vector 'my_vector' and dimension=3\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"my_vector\": [0.1, 0.2, 0.3],\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"my_vector\": [0.2, 0.5, 0.3],\n    },\n]\ndataset.records.add(data)\n</code></pre> <p>You can also add vectors to a record in an initialized <code>Record</code> object.</p> <p>Check the Vector - Python Reference to see the attributes, arguments, and methods of the <code>Vector</code> class in detail.</p> <pre><code># Add records to the dataset with the vector 'my_vector' and dimension=3\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        vectors=[\n            rg.Vector(\"my_vector\", [0.1, 0.2, 0.3])\n        ],\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        vectors=[\n            rg.Vector(\"my_vector\", [0.2, 0.5, 0.3])\n        ],\n    ),\n]\ndataset.records.add(records)\n</code></pre>"},{"location":"how_to_guides/record/#suggestions","title":"Suggestions","text":"<p>Suggestions refer to suggested responses (e.g. model predictions) that you can add to your records to make the annotation process faster. These can be added during the creation of the record or at a later stage. Only one suggestion can be provided for each question, and suggestion values must be compliant with the pre-defined questions e.g. if we have a <code>RatingQuestion</code> between 1 and 5, the suggestion should have a valid value within that range.</p> As part of a dictionaryAs part of a <code>Record</code> object <p>You can add suggestions as a dictionary, where the keys correspond to the <code>name</code>s of the labels that were configured for your dataset. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code># Add records to the dataset with the label 'my_label'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"my_label\": \"positive\",\n        \"my_label.score\": 0.9,\n        \"my_label.agent\": \"model_name\"\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"my_label\": \"negative\",\n        \"my_label.score\": 0.9,\n        \"my_label.agent\": \"model_name\"\n    },\n]\ndataset.records.add(data)\n</code></pre> <p>You can also add suggestions to a record in an initialized <code>Record</code> object.</p> <p>Check the Suggestions - Python Reference to see the attributes, arguments, and methods of the <code>Suggestion</code> class in detail.</p> <pre><code># Add records to the dataset with the label 'my_label'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        suggestions=[\n            rg.Suggestion(\n                \"my_label\",\n                \"positive\",\n                score=0.9,\n                agent=\"model_name\"\n            )\n        ],\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        suggestions=[\n            rg.Suggestion(\n                \"my_label\",\n                \"negative\",\n                score=0.9,\n                agent=\"model_name\"\n            )\n        ],\n    ),\n]\ndataset.records.add(records)\n</code></pre>"},{"location":"how_to_guides/record/#responses","title":"Responses","text":"<p>If your dataset includes some annotations, you can add those to the records as you create them. Make sure that the responses adhere to the same format as Argilla's output and meet the schema requirements for the specific type of question being answered. Make sure to include the <code>user_id</code> in case you're planning to add more than one response for the same question, if not responses will apply to all the annotators.</p> <p>Note</p> <p>Keep in mind that records with responses will be displayed as \"Draft\" in the UI.</p> As part of a dictionaryAs part of a <code>Record</code> object <p>You can add suggestions as a dictionary, where the keys correspond to the <code>name</code>s of the labels that were configured for your dataset. Remember that you can also use the <code>mapping</code> parameter to specify the data structure. If you want to specify the user that added the response, you can use the <code>user_id</code> parameter.</p> <pre><code># Add records to the dataset with the label 'my_label'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"my_label.response\": \"positive\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"my_label.response\": \"negative\",\n    },\n]\ndataset.records.add(data, user_id=user.id)\n</code></pre> <p>You can also add suggestions to a record in an initialized <code>Record</code> object.</p> <p>Check the Responses - Python Reference to see the attributes, arguments, and methods of the <code>Suggestion</code> class in detail.</p> <pre><code># Add records to the dataset with the label 'my_label'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        responses=[\n            rg.Response(\"my_label\", \"positive\", user_id=user.id)\n        ]\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        responses=[\n            rg.Response(\"my_label\", \"negative\", user_id=user.id)\n        ]\n    ),\n]\ndataset.records.add(records)\n</code></pre>"},{"location":"how_to_guides/record/#list-records","title":"List records","text":"<p>To list records in a dataset, you can use the <code>records</code> method on the <code>Dataset</code> object. This method returns a list of <code>Record</code> objects that can be iterated over to access the record properties.</p> <pre><code>for record in dataset.records(\n    with_suggestions=True, \n    with_responses=True, \n    with_metadata=True, \n    with_vectors=True\n    ):\n\n    # Access the record properties\n    print(record.metadata)\n    print(record.vectors)\n    print(record.suggestions)\n    print(record.responses)\n\n    # Access the responses of the record\n    for response in record.responses:\n        print(record.question_name.value)\n</code></pre>"},{"location":"how_to_guides/record/#update-records","title":"Update records","text":"<p>You can update records in a dataset calling the <code>update</code> method on the <code>Dataset</code> object. To update a record, you need to provide the record <code>id</code> or <code>external_id</code> and the new data to be updated.</p> <pre><code>data = dataset.records.to_dict()\n\nupdated_data = [\n    {\n        \"text\": sample[\"text\"],\n        \"label\": \"positive\",\n        \"external_id\": sample[\"external_id\"],\n    }\n    for sample in data\n]\ndataset.records.update(records=updated_data)\n</code></pre> <p>You can also update the metadata, vectors, suggestions, and responses separately by iterating over the records and updating the desired attribute.</p> <pre><code>for record in dataset.records(with_metadata=True):\n    record.metadata = {\"category\": \"C\"}\n</code></pre>"},{"location":"how_to_guides/team/","title":"Manage users, credentials, and workspaces","text":"<p>In these guides, you'll learn how to effectively manage your annotation team by setting up user accounts, assigning credentials, and organizing workspaces.</p> <ul> <li> <p> Users</p> <p>A user is an authorized person who can access the UI and use the Python client in a running Argilla instance.</p> <p>This guide will cover the following topics:</p> <ul> <li>What's a user and their roles.</li> <li>Who can manage users.</li> <li>Which are the default credentials.</li> <li>How to create, list, retrieve, and delete users.</li> </ul> <p> How-to guide</p> </li> <li> <p> Workspaces</p> <p>A workspace is a space inside your Argilla instance where authorized users can collaborate.</p> <p>This guide will cover the following topics:</p> <ul> <li>What's a workspace.</li> <li>Who can manage workspaces.</li> <li>Which are the default workspaces.</li> <li>How to create, list, retrieve, and delete workspaces.</li> </ul> <p> How-to guide</p> </li> </ul>"},{"location":"how_to_guides/team/user/","title":"User Management","text":"<p>This guide provides an overview of user roles and credentials, explaining how to set up and manage users in Argilla.</p> <p>A user in Argilla is an authorized person, who depending on their role, can use the Python SDK and access the UI in a running Argilla instance. We differentiate between three types of users depending on their role, permissions and needs: <code>owner</code>, <code>admin</code> and <code>annotator</code>. </p> OverviewOwnerAdminAnnotator <p></p> <p>The <code>owner</code> refers to the root user who created the Argilla instance. Using workspaces within Argilla proves highly beneficial for organizing tasks efficiently. So, the owner has full access to all workspaces and their functionalities:</p> <ul> <li>Workspace management: It can create, read and delete a workspace.</li> <li>User management: It can create a new user, assign it to a workspace, and delete it. It can also list them and search for a specific one.</li> <li>Dataset management: It can create, configure, retrieve, update, and delete datasets.</li> <li>Annotation: It can annotate datasets in the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> <p>An <code>admin</code> user can only access the workspaces it has been assigned to and cannot assign other users to it. An admin user has the following permissions:</p> <ul> <li>Dataset management: It can create, configure, retrieve, update, and delete datasets only on the assigned workspaces.</li> <li>Annotation: It can annotate datasets in the assigned workspaces via the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> <p>An <code>annotator</code> user is limited to accessing only the datasets assigned to it within the workspace. It has two specific permissions:</p> <ul> <li>Annotation: It can annotate the assigned datasets in the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> <p>Question: Who can manage users?</p> <p>Only users with the <code>owner</code> role can manage (create, retrieve, delete) other users.</p>"},{"location":"how_to_guides/team/user/#default-users-and-credentials","title":"Default users and credentials","text":"<p>Argilla provides a default user with the <code>owner</code> role to help you get started in Python and the UI. The credentials for this user vary depending on the server configuration.</p> Environment Username Password API Key Quickstart Docker and HF Space owner 12345678 owner.apikey Server image argilla 1234 argilla.apikey"},{"location":"how_to_guides/team/user/#rguser","title":"rg.User","text":"<p>A <code>User</code> object in Argilla represents a user with a specific role and credentials.</p> <p>Check the User - Python Reference to see the attributes, arguments, and methods of the <code>User</code> class in detail.</p> <pre><code>rg.User(\n    username=\"username\",\n    first_name=\"first_name\",\n    last_name=\"last_name\",\n    role=\"owner\",\n    password=\"password\",\n    client=client\n)\n</code></pre>"},{"location":"how_to_guides/team/user/#how-to-guide","title":"How-to guide","text":"<p>This section shows how to identify the currently active user in Argilla, allowing you to verify the correct credentials are used for user management. It then outlines the process of creating a user, listing them all and retrieving a specific one. Finally, it covers the steps to delete a user.</p>"},{"location":"how_to_guides/team/user/#get-current-user","title":"Get current user","text":"<p>To ensure you're using the correct credentials for managing users, you can get the current user in Argilla using the <code>me</code> attribute of the <code>Argilla</code> class.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ncurrent_user = client.me\ncurrent_user\n</code></pre>"},{"location":"how_to_guides/team/user/#create-a-user","title":"Create a user","text":"<p>To create a new user in Argilla, you can define it in the <code>User</code> class and then call the <code>create</code> method. This method is inherited from the <code>Resource</code> base class and operates without modifications.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser_to_create = rg.User(\n    username=\"my_username\",\n    first_name=\"my_first_name\",\n    last_name=\"my_last_name\",\n    role=\"owner\",\n    password=\"12345678\",\n    client=client\n)\n\ncreated_user = user_to_create.create()\ncreated_user\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a user by calling them directly on the <code>User</code> object. For example, <code>user.id</code> or <code>user.username</code>.</p>"},{"location":"how_to_guides/team/user/#list-users","title":"List users","text":"<p>You can list all the existing users in Argilla by accessing the <code>users</code> attribute on the <code>Argilla</code> class and iterating over them. You can also use <code>len(client.users)</code> to get the number of users.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nusers = client.users\n\nfor user in users:\n    print(user)\n</code></pre> <p>Notebooks</p> <p>When using a notebook, executing <code>client.users</code> will display a table with <code>username</code>, <code>id</code>, <code>role</code>, and the last update as <code>updated_at</code>.</p>"},{"location":"how_to_guides/team/user/#retrieve-a-user","title":"Retrieve a user","text":"<p>You can retrieve an existing user from Argilla by accessing the <code>users</code> attribute on the <code>Argilla</code> class and passing the <code>username</code> as an argument.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nretrieved_user = client.users('my_username')\nretrieved_user\n</code></pre>"},{"location":"how_to_guides/team/user/#delete-a-user","title":"Delete a user","text":"<p>You can delete an existing user from Argilla by calling the <code>delete</code> method on the <code>User</code> class.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser_to_delete = client.users('my_username')\n\ndeleted_user = user_to_delete.delete()\n</code></pre>"},{"location":"how_to_guides/team/workspace/","title":"Workspace Management","text":"<p>This guide provides an overview of workspaces, explaining how to set up and manage workspaces in Argilla.</p> <p>A workspace is a space inside your Argilla instance where authorized users can collaborate on datasets. It is accessible through the Python SDK and the UI.</p> <p>Question: Who can manage workspaces?</p> <p>Only users with the <code>owner</code> role can manage (create, read and delete) workspaces.</p> <p>A user with the <code>admin</code> role can only read the workspace to which it belongs.</p>"},{"location":"how_to_guides/team/workspace/#default-workspaces","title":"Default workspaces","text":"<p>Argilla provides a default workspace to help you get started in Python and the UI. The name of this workspace varies depending on the server configuration.</p> Environment Name Quickstart Docker and HF Space admin Server image argilla"},{"location":"how_to_guides/team/workspace/#rgworkspace","title":"rg.Workspace","text":"<p>A workspace in Argilla is represented by a <code>Workspace</code>.</p> <p>Check the Workspace - Python Reference to see the attributes, arguments, and methods of the <code>Workspace</code> class in detail.</p> <pre><code>rg.Workspace(\n    name = \"name\",\n    client=client\n)\n</code></pre>"},{"location":"how_to_guides/team/workspace/#how-to-guide","title":"How-to guide","text":"<p>This section shows how to create a new workspace in Argilla, the process of listing all the workspaces and retrieving a specific one or checking if it exists. Finally, the guide covers the steps to delete a user.</p>"},{"location":"how_to_guides/team/workspace/#create-a-new-workspace","title":"Create a new workspace","text":"<p>To create a new workspace in Argilla, you can define it in the <code>Workspace</code> class and then call the <code>create</code> method. This method is inherited from the <code>Resource</code> base class and operates without modifications.</p> <p>When you create a new workspace, it will be empty. To create and add a new dataset, check these guides.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace_to_create = rg.Workspace(\n    name = \"my_workspace\",\n    client=client\n)\n\ncreated_workspace = workspace_to_create.create()\ncreated_workspace\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a workspace by calling them directly on the <code>Workspace</code> object. For example, <code>workspace.id</code> or <code>workspace.name</code>.</p>"},{"location":"how_to_guides/team/workspace/#list-workspaces","title":"List workspaces","text":"<p>You can list all the existing workspaces in Argilla by calling the <code>workspaces</code> attribute on the <code>Argilla</code> class and iterating over them. You can also use <code>len(client.workspaces)</code> to get the number of workspaces.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspaces = client.workspaces\n\nfor workspace in workspaces:\n    print(workspace)\n</code></pre> <p>Notebooks</p> <p>When using a notebook, executing <code>client.workspaces</code> will display a table with the number of <code>datasets</code> in each workspace, <code>name</code>, <code>id</code>, and the last update as <code>updated_at</code>.</p>"},{"location":"how_to_guides/team/workspace/#retrieve-a-workspace","title":"Retrieve a workspace","text":"<p>You can retrieve a workspace by accessing the <code>workspaces</code> method on the <code>Argilla</code> class and passing the name of the workspace as an argument.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nretrieved_workspace = client.workspaces(\"my_workspace\")\nretrieved_workspace\n</code></pre>"},{"location":"how_to_guides/team/workspace/#check-workspace-existence","title":"Check workspace existence","text":"<p>You can check if a workspace exists by calling the <code>exists</code> method on the <code>Workspace</code> class. This method returns a boolean value.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\nworkspace_existed = workspace.exists()\nworkspace_existed\n</code></pre>"},{"location":"how_to_guides/team/workspace/#delete-a-workspace","title":"Delete a workspace","text":"<p>To delete a workspace, no dataset can be associated with it. If the workspace contains any dataset, deletion will fail. You can delete a workspace by calling the <code>delete</code> method on the <code>Workspace</code> class.</p> <p>To clear a workspace and delete all their datasets, refer to this how-to guide.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace_to_delete = client.workspaces(\"my_workspace\")\n\ndeleted_workspace = workspace_to_delete.delete()\n</code></pre>"},{"location":"integrations/","title":"argilla-sdk","text":"<ul> <li> <p> Distilabel</p> <p><code>distilabel</code> is a lightweight, easy-to-use, and scalable framework for AI feedback and synthetic data generation which directly integrates with Argilla. It is designed to help you quickly and easily create high-quality labeled data for your LLMs.</p> <p> Tutorial</p> </li> <li> <p> Argilla Metrics</p> <p><code>argilla-metrics</code> is a self-maintained library for tracking and evaluating the performance of your models and annotators.</p> <p> Tutorial</p> </li> <li> <p> Llama-index</p> <p><code>argilla-llama-index</code> is LLM orchestration framework. The integration with Argilla allows you to easily monitor pipeline traces and adding human feedback to your them.</p> <p> Tutorial</p> </li> <li> <p> Haystack</p> <p><code>argilla-haystack</code> is LLM orchestration framework. The integration with Argilla allows you to easily monitor pipeline traces and adding human feedback to your them.</p> <p> Tutorial</p> </li> <li> <p> Unstructured</p> <p><code>argilla-unstructured</code> is an ETL framework for LLM data. The integration with Argilla allows you to easily store and evaluate data from ETL pipelines and improve the quality using a human touch.</p> <p> Tutorial</p> </li> </ul>"},{"location":"overview/changelog/","title":"Changelog","text":"<p>Placeholder tex</p>"},{"location":"overview/community/","title":"Community","text":""},{"location":"overview/community/#community","title":"Community","text":"<p>We are an open-source community-driven project and we love to hear from you. Here are some ways to get involved:</p> <ul> <li> <p>Community Meetup: listen in or present during one of our bi-weekly events.</p> </li> <li> <p>Slack: get direct support from the community.</p> </li> <li> <p>Roadmap: plans change but we love to discuss those with our community so feel encouraged to participate.</p> </li> </ul>"},{"location":"overview/faq/","title":"Quickstart","text":"<p>Placeholder text</p>"},{"location":"overview/quickstart/","title":"Quickstart","text":"<p>Placeholder text</p>"},{"location":"overview/community/","title":"Community","text":""},{"location":"overview/community/#community","title":"Community","text":"<p>We are an open-source community-driven project and we love to hear from you. Here are some ways to get involved:</p> <ul> <li> <p>Community Meetup: listen in or present during one of our bi-weekly events.</p> </li> <li> <p>Slack: get direct support from the community.</p> </li> <li> <p>Roadmap: plans change but we love to discuss those with our community so feel encouraged to participate.</p> </li> </ul>"},{"location":"overview/community/contributor/","title":"GitHub workflows","text":""},{"location":"overview/community/contributor/#community","title":"Community","text":"<p>We are an open-source community-driven project and we love to hear from you. Here are some ways to get involved:</p> <ul> <li> <p>Community Meetup: listen in or present during one of our bi-weekly events.</p> </li> <li> <p>Slack: get direct support from the community.</p> </li> <li> <p>Roadmap: plans change but we love to discuss those with our community so feel encouraged to participate.</p> </li> </ul>"},{"location":"overview/community/developer/","title":"Development environment","text":""},{"location":"overview/community/developer/#community","title":"Community","text":"<p>We are an open-source community-driven project and we love to hear from you. Here are some ways to get involved:</p> <ul> <li> <p>Community Meetup: listen in or present during one of our bi-weekly events.</p> </li> <li> <p>Slack: get direct support from the community.</p> </li> <li> <p>Roadmap: plans change but we love to discuss those with our community so feel encouraged to participate.</p> </li> </ul>"},{"location":"overview/concepts/","title":"Argilla concepts","text":"<p>Placeholder text</p>"},{"location":"overview/installation/","title":"argilla-sdk","text":"<p>Placeholder text</p>"},{"location":"overview/installation/telemetry/","title":"argilla-sdk","text":"<p>Placeholder text</p>"},{"location":"reference/argilla_sdk/SUMMARY/","title":"SUMMARY","text":"<ul> <li>rg.Argilla</li> <li>rg.Workspace</li> <li>rg.User</li> <li>rg.Dataset<ul> <li>rg.Dataset.records</li> </ul> </li> <li>rg.Settings<ul> <li>Metadata</li> <li>Fields</li> <li>Vectors</li> <li>Questions</li> </ul> </li> <li>rg.Record<ul> <li>rg.Response</li> <li>rg.Suggestion</li> <li>rg.Vector</li> <li>rg.Metadata</li> </ul> </li> <li>rg.Query</li> </ul>"},{"location":"reference/argilla_sdk/client/","title":"<code>rg.Argilla</code>","text":"<p>To interact with the Argilla server from python you can use the <code>Argilla</code> class. The <code>Argilla</code> client is used to create, get, update, and delete all Argilla resources, such as workspaces, users, datasets, and records.</p>"},{"location":"reference/argilla_sdk/client/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/client/#connecting-to-an-argilla-server","title":"Connecting to an Argilla server","text":"<p>To connect to an Argilla server, instantiate the <code>Argilla</code> class and pass the <code>api_url</code> of the server and the <code>api_key</code> to authenticate.</p> <pre><code>import argilla_sdk as rg\n\nclient = rg.Argilla(\n    api_url=\"https://argilla.example.com\",\n    api_key=\"my_token\",\n)\n</code></pre>"},{"location":"reference/argilla_sdk/client/#accessing-dataset-workspace-and-user-objects","title":"Accessing Dataset, Workspace, and User objects","text":"<p>The <code>Argilla</code> clients provides access to the <code>Dataset</code>, <code>Workspace</code>, and <code>User</code> objects of the Argilla server.</p> <pre><code>my_dataset = client.datasets(\"my_dataset\")\n\nmy_workspace = client.workspaces(\"my_workspace\")\n\nmy_user = client.users(\"my_user\")\n</code></pre> <p>These resources can then be interacted with to access their properties and methods. For example, to list all datasets in a workspace:</p> <pre><code>for dataset in my_workspace.datasets:\n    print(dataset.name)\n</code></pre> <p>Or, to iterate over all records in a dataset:</p> <pre><code>for record in my_dataset.records:\n    print(record)\n</code></pre>"},{"location":"reference/argilla_sdk/client/#connecting-to-multiple-argilla-servers","title":"Connecting to multiple Argilla servers","text":"<p>To interact with multiple Argilla servers, you can create multiple <code>Argilla</code> clients with different <code>api_url</code> and <code>api_key</code> values.</p> <pre><code>dev_client = rg.Argilla(\n    api_url=\"https://dev.argilla.example.com\",\n    api_key=\"dev_token\",\n)\n\nprod_client = rg.Argilla(\n    api_url=\"https://prod.argilla.example.com\",\n    api_key=\"prod_token\", \n)\n\ndataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=rg.Settings(\n        fields=[rg.TextField(name=\"text\")],\n    ),\n    client=dev_client,\n)\n</code></pre>"},{"location":"reference/argilla_sdk/client/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>APIClient</code></p> <p>Argilla API client. This is the main entry point to interact with the API.</p> <p>Attributes:</p> Name Type Description <code>workspaces</code> <code>Workspaces</code> <p>A collection of workspaces.</p> <code>datasets</code> <code>Datasets</code> <p>A collection of datasets.</p> <code>users</code> <code>Users</code> <p>A collection of users.</p> <code>me</code> <code>User</code> <p>The current user.</p> Source code in <code>src/argilla_sdk/client.py</code> <pre><code>class Argilla(_api.APIClient):\n    \"\"\"Argilla API client. This is the main entry point to interact with the API.\n\n    Attributes:\n        workspaces: A collection of workspaces.\n        datasets: A collection of datasets.\n        users: A collection of users.\n        me: The current user.\n\n    \"\"\"\n\n    @property\n    def workspaces(self) -&gt; \"Workspaces\":\n        \"\"\"A collection of workspaces on the server.\"\"\"\n        return Workspaces(client=self)\n\n    @property\n    def datasets(self) -&gt; \"Datasets\":\n        \"\"\"A collection of datasets on the server.\"\"\"\n        return Datasets(client=self)\n\n    @property\n    def users(self) -&gt; \"Users\":\n        \"\"\"A collection of users on the server.\"\"\"\n        return Users(client=self)\n\n    @property\n    def me(self) -&gt; \"User\":\n        \"\"\"The current user.\"\"\"\n        from argilla_sdk import User\n\n        return User(client=self, _model=self.api.users.get_me())\n</code></pre>"},{"location":"reference/argilla_sdk/client/#argilla_sdk.client.Argilla.datasets","title":"<code>datasets: Datasets</code>  <code>property</code>","text":"<p>A collection of datasets on the server.</p>"},{"location":"reference/argilla_sdk/client/#argilla_sdk.client.Argilla.me","title":"<code>me: User</code>  <code>property</code>","text":"<p>The current user.</p>"},{"location":"reference/argilla_sdk/client/#argilla_sdk.client.Argilla.users","title":"<code>users: Users</code>  <code>property</code>","text":"<p>A collection of users on the server.</p>"},{"location":"reference/argilla_sdk/client/#argilla_sdk.client.Argilla.workspaces","title":"<code>workspaces: Workspaces</code>  <code>property</code>","text":"<p>A collection of workspaces on the server.</p>"},{"location":"reference/argilla_sdk/search/","title":"<code>rg.Query</code>","text":"<p>To collect records based on searching criteria, you can use the <code>Query</code> and <code>Filter</code> classes. The <code>Query</code> class is used to define the search criteria, while the <code>Filter</code> class is used to filter the search results. <code>Filter</code> is passed to a <code>Query</code> object so you can combine multiple filters to create complex search queries. A <code>Query</code> object can also be passed to <code>Dataset.records</code> to fetch records based on the search criteria.</p>"},{"location":"reference/argilla_sdk/search/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/search/#searching-for-records-with-terms","title":"Searching for records with terms","text":"<p>To search for records with terms, you can use the <code>Dataset.records</code> attribute with a query string. The search terms are used to search for records that contain the terms in the text field.</p> <pre><code>for record in dataset.records(query=\"paris\"):\n    print(record)\n</code></pre>"},{"location":"reference/argilla_sdk/search/#filtering-records-by-conditions","title":"Filtering records by conditions","text":"<p>Argilla allows you to filter records based on conditions. You can use the <code>Filter</code> class to define the conditions and pass them to the <code>Dataset.records</code> attribute to fetch records based on the conditions. Conditions include \"==\", \"&gt;=\", \"&lt;=\", or \"in\". Conditions can be combined with dot notation to filter records based on metadata, suggestions, or responses.</p> <pre><code># create a range from 10 to 20\nrange_filter = rg.Filter(\n    [\n        (\"metadata.count\", \"&gt;=\", 10),\n        (\"metadata.count\", \"&lt;=\", 20)\n    ]\n)\n\n# query records with metadata count greater than 10 and less than 20\nquery = rg.Query(filters=range_filter, query=\"paris\")\n\n# iterate over the results\nfor record in dataset.records(query=query):\n    print(record)\n</code></pre>"},{"location":"reference/argilla_sdk/search/#class-reference","title":"Class Reference","text":"<p>This class is used to map user queries to the internal query models</p> Source code in <code>src/argilla_sdk/records/_search.py</code> <pre><code>class Query:\n    \"\"\"This class is used to map user queries to the internal query models\"\"\"\n\n    query: Optional[str] = None\n\n    def __init__(self, *, query: Union[str, None] = None, filter: Union[Filter, None] = None):\n        \"\"\"Create a query object for use in Argilla search requests.add()\n\n        Parameters:\n            query (Union[str, None], optional): The query string that will be used to search.\n            filter (Union[Filter, None], optional): The filter object that will be used to filter the search results.\n        \"\"\"\n\n        self.query = query\n        self.filter = filter\n\n    @property\n    def model(self) -&gt; SearchQueryModel:\n        model = SearchQueryModel()\n\n        if self.query is not None:\n            text_query = TextQueryModel(q=self.query)\n            model.query = QueryModel(text=text_query)\n\n        if self.filter is not None:\n            model.filters = self.filter.model\n\n        return model\n</code></pre> <p>This class is used to map user filters to the internal filter models</p> Source code in <code>src/argilla_sdk/records/_search.py</code> <pre><code>class Filter:\n    \"\"\"This class is used to map user filters to the internal filter models\"\"\"\n\n    def __init__(self, conditions: Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None] = None):\n        \"\"\" Create a filter object for use in Argilla search requests.\n\n        Parameters:\n            conditions (Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None], optional): \\\n                The conditions that will be used to filter the search results. \\\n                The conditions should be a list of tuples where each tuple contains \\\n                the field, operator, and value. For example `(\"label\", \"in\", [\"positive\",\"happy\"])`.\\\n\n        \"\"\"\n\n        if isinstance(conditions, tuple):\n            conditions = [conditions]\n        self.conditions = [Condition(condition) for condition in conditions]\n\n    @property\n    def model(self) -&gt; AndFilterModel:\n        return AndFilterModel.parse_obj({\"and\": [condition.model for condition in self.conditions]})\n</code></pre>"},{"location":"reference/argilla_sdk/search/#argilla_sdk.records._search.Query.__init__","title":"<code>__init__(*, query=None, filter=None)</code>","text":"<p>Create a query object for use in Argilla search requests.add()</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, None]</code> <p>The query string that will be used to search.</p> <code>None</code> <code>filter</code> <code>Union[Filter, None]</code> <p>The filter object that will be used to filter the search results.</p> <code>None</code> Source code in <code>src/argilla_sdk/records/_search.py</code> <pre><code>def __init__(self, *, query: Union[str, None] = None, filter: Union[Filter, None] = None):\n    \"\"\"Create a query object for use in Argilla search requests.add()\n\n    Parameters:\n        query (Union[str, None], optional): The query string that will be used to search.\n        filter (Union[Filter, None], optional): The filter object that will be used to filter the search results.\n    \"\"\"\n\n    self.query = query\n    self.filter = filter\n</code></pre>"},{"location":"reference/argilla_sdk/search/#argilla_sdk.records._search.Filter.__init__","title":"<code>__init__(conditions=None)</code>","text":"<p>Create a filter object for use in Argilla search requests.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None]</code> <p>The conditions that will be used to filter the search results.                 The conditions should be a list of tuples where each tuple contains                 the field, operator, and value. For example <code>(\"label\", \"in\", [\"positive\",\"happy\"])</code>.</p> <code>None</code> Source code in <code>src/argilla_sdk/records/_search.py</code> <pre><code>def __init__(self, conditions: Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None] = None):\n    \"\"\" Create a filter object for use in Argilla search requests.\n\n    Parameters:\n        conditions (Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None], optional): \\\n            The conditions that will be used to filter the search results. \\\n            The conditions should be a list of tuples where each tuple contains \\\n            the field, operator, and value. For example `(\"label\", \"in\", [\"positive\",\"happy\"])`.\\\n\n    \"\"\"\n\n    if isinstance(conditions, tuple):\n        conditions = [conditions]\n    self.conditions = [Condition(condition) for condition in conditions]\n</code></pre>"},{"location":"reference/argilla_sdk/users/","title":"<code>rg.User</code>","text":"<p>A user in Argilla is a profile that uses the SDK or UI. Their profile can be used to track their feedback activity and to manage their access to the Argilla server.</p>"},{"location":"reference/argilla_sdk/users/#usage-examples","title":"Usage Examples","text":"<p>To create a new user, instantiate the <code>User</code> object with the client and the username:</p> <pre><code>user = rg.User(username=\"my_username\", password=\"my_password\")\nuser.create()\n</code></pre> <p>Existing users can be retrieved by their username:</p> <pre><code>user = client.users(\"my_username\")\n</code></pre> <p>The current user of the <code>rg.Argilla</code> client can be accessed using the <code>me</code> attribute:</p> <pre><code>client.me\n</code></pre>"},{"location":"reference/argilla_sdk/users/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla users in the Argilla server. User profiles         are used to manage access to the Argilla server and track responses to records.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>The username of the user.</p> <code>first_name</code> <code>str</code> <p>The first name of the user.</p> <code>last_name</code> <code>str</code> <p>The last name of the user.</p> <code>role</code> <code>str</code> <p>The role of the user, either 'annotator' or 'admin'.</p> <code>password</code> <code>str</code> <p>The password of the user.</p> <code>id</code> <code>UUID</code> <p>The ID of the user.</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>class User(Resource):\n    \"\"\"Class for interacting with Argilla users in the Argilla server. User profiles \\\n        are used to manage access to the Argilla server and track responses to records.\n\n    Attributes:\n        username (str): The username of the user.\n        first_name (str): The first name of the user.\n        last_name (str): The last name of the user.\n        role (str): The role of the user, either 'annotator' or 'admin'.\n        password (str): The password of the user.\n        id (UUID): The ID of the user.\n    \"\"\"\n\n    _model: UserModel\n    _api: UsersAPI\n\n    def __init__(\n        self,\n        username: Optional[str] = None,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        role: Optional[str] = None,\n        password: Optional[str] = None,\n        client: Optional[\"Argilla\"] = Argilla(),\n        id: Optional[UUID] = None,\n        _model: Optional[UserModel] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a User object with a client and a username\n\n        Parameters:\n            client (Argilla): The client used to interact with Argilla\n            username (str): The username of the user\n            first_name (str): The first name of the user\n            last_name (str): The last name of the user\n            role (str): The role of the user, either 'annotator', admin, or 'owner'\n            password (str): The password of the user\n\n        Returns:\n            User: The initialized user object\n        ```\n        \"\"\"\n        super().__init__(\n            client=client,\n            api=client.api.users,\n        )\n        if _model is None:\n            _model = UserModel(\n                username=username,\n                first_name=first_name or username,\n                last_name=last_name or username,\n                role=role or Role.annotator,\n                password=password,\n                id=id,\n            )\n            self.log(f\"Initialized user with username {username}\")\n        self._sync(model=_model)\n</code></pre>"},{"location":"reference/argilla_sdk/users/#argilla_sdk.users.User.__init__","title":"<code>__init__(username=None, first_name=None, last_name=None, role=None, password=None, client=Argilla(), id=None, _model=None)</code>","text":"<p>Initializes a User object with a client and a username</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Argilla</code> <p>The client used to interact with Argilla</p> <code>Argilla()</code> <code>username</code> <code>str</code> <p>The username of the user</p> <code>None</code> <code>first_name</code> <code>str</code> <p>The first name of the user</p> <code>None</code> <code>last_name</code> <code>str</code> <p>The last name of the user</p> <code>None</code> <code>role</code> <code>str</code> <p>The role of the user, either 'annotator', admin, or 'owner'</p> <code>None</code> <code>password</code> <code>str</code> <p>The password of the user</p> <code>None</code> <p>Returns:</p> Name Type Description <code>User</code> <code>None</code> <p>The initialized user object</p> <p>```</p> Source code in <code>src/argilla_sdk/users/_resource.py</code> <pre><code>def __init__(\n    self,\n    username: Optional[str] = None,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    role: Optional[str] = None,\n    password: Optional[str] = None,\n    client: Optional[\"Argilla\"] = Argilla(),\n    id: Optional[UUID] = None,\n    _model: Optional[UserModel] = None,\n) -&gt; None:\n    \"\"\"Initializes a User object with a client and a username\n\n    Parameters:\n        client (Argilla): The client used to interact with Argilla\n        username (str): The username of the user\n        first_name (str): The first name of the user\n        last_name (str): The last name of the user\n        role (str): The role of the user, either 'annotator', admin, or 'owner'\n        password (str): The password of the user\n\n    Returns:\n        User: The initialized user object\n    ```\n    \"\"\"\n    super().__init__(\n        client=client,\n        api=client.api.users,\n    )\n    if _model is None:\n        _model = UserModel(\n            username=username,\n            first_name=first_name or username,\n            last_name=last_name or username,\n            role=role or Role.annotator,\n            password=password,\n            id=id,\n        )\n        self.log(f\"Initialized user with username {username}\")\n    self._sync(model=_model)\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/","title":"<code>rg.Workspace</code>","text":"<p>In Argilla, workspaces are used to organize datasets in to groups. For example, you might have a workspace for each project or team.</p>"},{"location":"reference/argilla_sdk/workspaces/#usage-examples","title":"Usage Examples","text":"<p>To create a new workspace, instantiate the <code>Workspace</code> object with the client and the name:</p> <pre><code>workspace = rg.Workspace(name=\"my_workspace\")\nworkspace.create()\n</code></pre> <p>To retrieve an existing workspace, use the <code>client.workspaces</code> attribute:</p> <pre><code>workspace = client.workspaces(\"my_workspace\")\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla workspaces. Workspaces are used to organize datasets in the Argilla server.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the workspace.</p> <code>id</code> <code>UUID</code> <p>The ID of the workspace.</p> <code>datasets</code> <code>List[DatasetModel]</code> <p>A list of all datasets in the workspace.</p> Source code in <code>src/argilla_sdk/workspaces/_resource.py</code> <pre><code>class Workspace(Resource):\n    \"\"\"Class for interacting with Argilla workspaces. Workspaces are used to organize datasets in the Argilla server.\n\n    Attributes:\n        name (str): The name of the workspace.\n        id (UUID): The ID of the workspace.\n        datasets (List[DatasetModel]): A list of all datasets in the workspace.\n    \"\"\"\n\n    name: Optional[str]\n    id: Optional[UUID]\n\n    _api: \"WorkspacesAPI\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        id: Optional[UUID] = None,\n        client: Optional[\"Argilla\"] = Argilla(),\n        _model: Optional[WorkspaceModel] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a Workspace object with a client and a name or id\n\n        Parameters:\n            client (Argilla): The client used to interact with Argilla\n            name (str): The name of the workspace\n            id (UUID): The id of the workspace\n            _model (WorkspaceModel): The internal Pydantic model of the workspace from/to the server\n        Returns:\n            Workspace: The initialized workspace object\n        \"\"\"\n        super().__init__(client=client, api=client.api.workspaces)\n        self._sync(model=WorkspaceModel(name=name, id=id) if not _model else _model)\n\n    def __len__(self) -&gt; int:\n        return len(self.datasets)\n\n    def list_datasets(self) -&gt; List[\"DatasetModel\"]:\n        datasets = self._client.api.datasets.list(self.id)\n        self.log(f\"Got {len(datasets)} datasets for workspace {self.id}\")\n        return datasets\n\n    def exists(self) -&gt; bool:\n        return self._api.exists(self.id)\n\n    ############################\n    # Properties\n    ############################\n\n    @property\n    def datasets(self) -&gt; List[\"DatasetModel\"]:\n        \"\"\"List all datasets in the workspace\n\n        Returns:\n            List[DatasetModel]: A list of all datasets in the workspace\n        \"\"\"\n        return self.list_datasets()\n</code></pre>"},{"location":"reference/argilla_sdk/workspaces/#argilla_sdk.workspaces.Workspace.datasets","title":"<code>datasets: List[DatasetModel]</code>  <code>property</code>","text":"<p>List all datasets in the workspace</p> <p>Returns:</p> Type Description <code>List[DatasetModel]</code> <p>List[DatasetModel]: A list of all datasets in the workspace</p>"},{"location":"reference/argilla_sdk/workspaces/#argilla_sdk.workspaces.Workspace.__init__","title":"<code>__init__(name=None, id=None, client=Argilla(), _model=None)</code>","text":"<p>Initializes a Workspace object with a client and a name or id</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Argilla</code> <p>The client used to interact with Argilla</p> <code>Argilla()</code> <code>name</code> <code>str</code> <p>The name of the workspace</p> <code>None</code> <code>id</code> <code>UUID</code> <p>The id of the workspace</p> <code>None</code> <code>_model</code> <code>WorkspaceModel</code> <p>The internal Pydantic model of the workspace from/to the server</p> <code>None</code> <p>Returns:     Workspace: The initialized workspace object</p> Source code in <code>src/argilla_sdk/workspaces/_resource.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    id: Optional[UUID] = None,\n    client: Optional[\"Argilla\"] = Argilla(),\n    _model: Optional[WorkspaceModel] = None,\n) -&gt; None:\n    \"\"\"Initializes a Workspace object with a client and a name or id\n\n    Parameters:\n        client (Argilla): The client used to interact with Argilla\n        name (str): The name of the workspace\n        id (UUID): The id of the workspace\n        _model (WorkspaceModel): The internal Pydantic model of the workspace from/to the server\n    Returns:\n        Workspace: The initialized workspace object\n    \"\"\"\n    super().__init__(client=client, api=client.api.workspaces)\n    self._sync(model=WorkspaceModel(name=name, id=id) if not _model else _model)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/","title":"<code>rg.Dataset.records</code>","text":""},{"location":"reference/argilla_sdk/datasets/dataset_records/#usage-examples","title":"Usage Examples","text":"<p>In most cases, you will not need to create a <code>DatasetRecords</code> object directly. Instead, you can access it via the <code>Dataset</code> object:</p>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#adding-records-to-a-dataset","title":"Adding records to a dataset","text":"<p>To add records to a dataset, use the <code>add</code> method. Records can be added as dictionaries or as <code>Record</code> objects. Single records can also be added as a dictionary or <code>Record</code>.</p> <pre><code>import argilla_sdk as rg\n\n# Create a dataset\ndataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=rg.Settings(\n        fields=[\n            rg.TextField(name=\"question\"),\n        ],\n        questions=[\n            rg.TextQuestion(name=\"answer\"),\n        ],\n    ),\n)\n\n# Publish the dataset to the server\ndataset.publish()\n\n# Add records to a dataset\ndataset.records.add(\n    records=[\n    {\n        \"question\": \"What is the capital of France?\",  # 'question' matches the `rg.TextField` name\n        \"answer\": \"Paris\" # 'answer' matches the `rg.TextQuestion` name\n    },\n    {\n        \"question\": \"What is the capital of Germany?\", \n        \"answer\": \"Berlin\"\n    },\n])\n</code></pre> <p>When adding records from a native datasource, a mapping can be provided to map the keys in the native data structure to the fields and questions in Argilla. The dot notation is used to access suggestions and responses in the records.</p> <pre><code>dataset.records.add(\n    records=[\n        {\"input\": \"What is the capital of France?\", \"output\": \"Paris\"},\n        {\"input\": \"What is the capital of Germany?\", \"output\": \"Berlin\"},\n    ],\n    mapping={\"input\": \"question\", \"output\": \"answer\"}, # Maps 'input' to 'question' and 'output' to 'answer'\n)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#iterating-over-records-in-a-dataset","title":"Iterating over records in a dataset","text":"<p><code>Dataset.records</code> can be used to iterate over records in a dataset from the server. The records will be fetched in batches from the server::</p> <pre><code>for record in dataset.records:\n    print(record)\n\n# Fetch records with suggestions and responses\nfor record in dataset.records(with_suggestions=True, with_responses=True):\n    print(record.suggestions)\n    print(record.responses)\n\n# Filter records by a query and fetch records with vectors\nfor record in dataset.records(query=\"question:capital\", with_vectors=True):\n    print(record.vectors)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#updating-records-in-a-dataset","title":"Updating records in a dataset","text":"<p>Records can also be updated using the <code>id</code> or <code>external_id</code> to identify the records to be updated:</p> <pre><code># Add records to a dataset\ndataset.records.add(\n    records=[\n        {\n            \"id\": \"1\",\n            \"question\": \"What is the capital of France?\",\n            \"answer\": \"F\",\n        },\n        {\n            \"id\": \"2\",\n            \"question\": \"What is the capital of Germany?\",\n            \"answer\": \"Berlin\"\n        },\n    ]\n)\n\n# Update records in a dataset\ndataset.records.update(\n    records=[\n        {\n            \"id\": \"1\",  # matches id used in `Dataset.records.add`\n            \"question\": \"What is the capital of France?\",\n            \"answer\": \"Paris\",\n        }\n    ]\n)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#exporting-records-from-a-dataset","title":"Exporting records from a dataset","text":"<p>Records can also be exported from <code>Dataset.records</code>. Generic python exports include <code>to_dict</code> and <code>to_list</code> methods.</p> <pre><code>dataset.records.to_dict()\n# {\"text\": [\"Hello\", \"World\"], \"label\": [\"greeting\", \"greeting\"]}\n</code></pre> <p>Output the records as a dictionary orientated by index:</p> <pre><code>dataset.records.to_dict(orient=\"index\")\n# {\"uuid\": {\"text\": \"Hello\", \"label\": \"greeting\"}}\n</code></pre> <p>Output the records as a list of dictionaries:</p> <pre><code>dataset.records.to_list()\n# [{\"text\": \"Hello\", \"label\": \"greeting\"}, {\"text\": \"World\", \"label\": \"greeting\"}]\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>Resource</code>, <code>Iterable[Record]</code></p> <p>This class is used to work with records from a dataset and is accessed via <code>Dataset.records</code>. The responsibility of this class is to provide an interface to interact with records in a dataset, by adding, updating, fetching, querying, deleting, and exporting records.</p> <p>Attributes:</p> Name Type Description <code>client</code> <code>Argilla</code> <p>The Argilla client object.</p> <code>dataset</code> <code>Dataset</code> <p>The dataset object.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>class DatasetRecords(Resource, Iterable[Record]):\n    \"\"\"This class is used to work with records from a dataset and is accessed via `Dataset.records`. The responsibility of this class is to provide an interface to interact with records in a dataset, by adding, updating, fetching, querying, deleting, and exporting records.\n\n    Attributes:\n        client (Argilla): The Argilla client object.\n        dataset (Dataset): The dataset object.\n\n\n    \"\"\"\n\n    _api: RecordsAPI\n\n    DEFAULT_BATCH_SIZE = 256\n\n    def __init__(self, client: \"Argilla\", dataset: \"Dataset\"):\n        \"\"\"Initializes a DatasetRecords object with a client and a dataset.\n        Args:\n            client: An Argilla client object.\n            dataset: A Dataset object.\n        \"\"\"\n        self.__client = client\n        self.__dataset = dataset\n        self._api = self.__client.api.records\n\n    def __iter__(self):\n        return DatasetRecordsIterator(self.__dataset, self.__client)\n\n    def __call__(\n        self,\n        query: Optional[Union[str, Query]] = None,\n        batch_size: Optional[int] = DEFAULT_BATCH_SIZE,\n        start_offset: int = 0,\n        with_suggestions: bool = True,\n        with_responses: bool = True,\n        with_vectors: Optional[Union[List, bool, str]] = None,\n    ):\n        \"\"\"Returns an iterator over the records in the dataset on the server.\n\n        Parameters:\n            query: A string or a Query object to filter the records.\n            batch_size: The number of records to fetch in each batch. The default is 256.\n            start_offset: The offset from which to start fetching records. The default is 0.\n            with_suggestions: Whether to include suggestions in the records. The default is True.\n            with_responses: Whether to include responses in the records. The default is True.\n            with_vectors: A list of vector names to include in the records. The default is None.\n                If a list is provided, only the specified vectors will be included.\n                If True is provided, all vectors will be included.\n\n        Returns:\n            An iterator over the records in the dataset on the server.\n\n        \"\"\"\n        if query and isinstance(query, str):\n            query = Query(query=query)\n\n        if with_vectors:\n            self.__validate_vector_names(vector_names=with_vectors)\n\n        return DatasetRecordsIteratorWithExportSupport(\n            self.__dataset,\n            self.__client,\n            query=query,\n            batch_size=batch_size,\n            start_offset=start_offset,\n            with_suggestions=with_suggestions,\n            with_responses=with_responses,\n            with_vectors=with_vectors,\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.__dataset})\"\n\n    ############################\n    # Public methods\n    ############################\n\n    def add(\n        self,\n        records: Union[dict, List[dict], Record, List[Record]],\n        mapping: Optional[Dict[str, str]] = None,\n        user_id: Optional[UUID] = None,\n        batch_size: int = DEFAULT_BATCH_SIZE,\n    ) -&gt; List[Record]:\n        \"\"\"\n        Add new records to a dataset on the server.\n\n        Parameters:\n            records: A dictionary or a list of dictionaries representing the records\n                     to be added to the dataset. Records are defined as dictionaries\n                     with keys corresponding to the fields in the dataset schema.\n            mapping: A dictionary that maps the keys in the records to the fields in the dataset schema.\n            user_id: The user id to be associated with the records. If not provided, the current user id is used.\n            batch_size: The number of records to send in each batch. The default is 256.\n\n        Returns:\n            A list of Record objects representing the added records.\n\n        Examples:\n\n        Add generic records to a dataset as dictionaries:\n\n        \"\"\"\n        record_models = self.__ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n\n        batch_size = self._normalize_batch_size(\n            batch_size=batch_size,\n            records_length=len(record_models),\n            max_value=self._api.MAX_RECORDS_PER_CREATE_BULK,\n        )\n\n        created_records = []\n        for batch in range(0, len(record_models), batch_size):\n            self.log(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n            batch_records = record_models[batch : batch + batch_size]\n            models = self._api.bulk_create(dataset_id=self.__dataset.id, records=batch_records)\n            created_records.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n\n        self.log(\n            message=f\"Added {len(created_records)} records to dataset {self.__dataset.name}\",\n            level=\"info\",\n        )\n\n        return created_records\n\n    def update(\n        self,\n        records: Union[dict, List[dict], Record, List[Record]],\n        mapping: Optional[Dict[str, str]] = None,\n        user_id: Optional[UUID] = None,\n        batch_size: int = DEFAULT_BATCH_SIZE,\n    ) -&gt; List[Record]:\n        \"\"\"Update records in a dataset on the server using the provided records\n            and matching based on the external_id or id.\n\n        Parameters:\n            records: A dictionary or a list of dictionaries representing the records\n                     to be updated in the dataset. Records are defined as dictionaries\n                     with keys corresponding to the fields in the dataset schema. Ids or\n                     external_ids should be provided to identify the records to be updated.\n            mapping: A dictionary that maps the keys in the records to the fields in the dataset schema.\n            user_id: The user id to be associated with the records. If not provided, the current user id is used.\n            batch_size: The number of records to send in each batch. The default is 256.\n\n        Returns:\n            A list of Record objects representing the updated records.\n\n        \"\"\"\n        record_models = self.__ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n        batch_size = self._normalize_batch_size(\n            batch_size=batch_size,\n            records_length=len(record_models),\n            max_value=self._api.MAX_RECORDS_PER_UPSERT_BULK,\n        )\n\n        created_or_updated = []\n        records_updated = 0\n        for batch in range(0, len(records), batch_size):\n            self.log(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n            batch_records = record_models[batch : batch + batch_size]\n            models, updated = self._api.bulk_upsert(dataset_id=self.__dataset.id, records=batch_records)\n            created_or_updated.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n            records_updated += updated\n\n        records_created = len(created_or_updated) - records_updated\n        self.log(\n            message=f\"Updated {records_updated} records and added {records_created} records to dataset {self.__dataset.name}\",\n            level=\"info\",\n        )\n\n        return created_or_updated\n\n    def to_dict(self, flatten: bool = False, orient: str = \"names\") -&gt; Dict[str, Any]:\n        \"\"\"\n        Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().\n\n        Parameters:\n            flatten (bool): Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.\n            orient (str): The structure of the exported dictionary.\n\n        Returns:\n            A dictionary of records.\n\n        \"\"\"\n        return self(with_suggestions=True, with_responses=True).to_dict(flatten=flatten, orient=orient)\n\n    def to_list(self, flatten: bool = False) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().\n\n        Parameters:\n            flatten (bool): Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.\n\n        Returns:\n            A list of dictionaries of records.\n        \"\"\"\n        return self(with_suggestions=True, with_responses=True).to_list(flatten=flatten)\n\n    ############################\n    # Utility methods\n    ############################\n\n    def __ingest_records(\n        self,\n        records: Union[List[Dict[str, Any]], Dict[str, Any], List[Record], Record],\n        mapping: Optional[Dict[str, str]] = None,\n        user_id: Optional[UUID] = None,\n    ) -&gt; List[RecordModel]:\n        if isinstance(records, (Record, dict)):\n            records = [records]\n\n        if all(map(lambda r: isinstance(r, dict), records)):\n            # Records as flat dicts of values to be matched to questions as suggestion or response\n            records = [\n                Record.from_dict(data=r, mapping=mapping, dataset=self.__dataset, user_id=user_id) for r in records\n            ]  # type: ignore\n        elif all(map(lambda r: isinstance(r, Record), records)):\n            for record in records:\n                record.dataset = self.__dataset\n        else:\n            raise ValueError(\n                \"Records should be a dictionary, a list of dictionaries, a Record instance, \"\n                \"or a list of Record instances.\"\n            )\n        return [r._model for r in records]\n\n    def _normalize_batch_size(self, batch_size: int, records_length, max_value: int):\n        norm_batch_size = min(batch_size, records_length, max_value)\n\n        if batch_size != norm_batch_size:\n            self.log(\n                message=f\"The provided batch size {batch_size} was normalized. Using value {norm_batch_size}.\",\n                level=\"warning\",\n            )\n\n        return norm_batch_size\n\n    def __validate_vector_names(self, vector_names: Union[List[str], str]) -&gt; None:\n        if not isinstance(vector_names, list):\n            vector_names = [vector_names]\n        for vector_name in vector_names:\n            if isinstance(vector_name, bool):\n                continue\n            if vector_name not in self.__dataset.schema:\n                raise ValueError(f\"Vector field {vector_name} not found in dataset schema.\")\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.__call__","title":"<code>__call__(query=None, batch_size=DEFAULT_BATCH_SIZE, start_offset=0, with_suggestions=True, with_responses=True, with_vectors=None)</code>","text":"<p>Returns an iterator over the records in the dataset on the server.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[Union[str, Query]]</code> <p>A string or a Query object to filter the records.</p> <code>None</code> <code>batch_size</code> <code>Optional[int]</code> <p>The number of records to fetch in each batch. The default is 256.</p> <code>DEFAULT_BATCH_SIZE</code> <code>start_offset</code> <code>int</code> <p>The offset from which to start fetching records. The default is 0.</p> <code>0</code> <code>with_suggestions</code> <code>bool</code> <p>Whether to include suggestions in the records. The default is True.</p> <code>True</code> <code>with_responses</code> <code>bool</code> <p>Whether to include responses in the records. The default is True.</p> <code>True</code> <code>with_vectors</code> <code>Optional[Union[List, bool, str]]</code> <p>A list of vector names to include in the records. The default is None. If a list is provided, only the specified vectors will be included. If True is provided, all vectors will be included.</p> <code>None</code> <p>Returns:</p> Type Description <p>An iterator over the records in the dataset on the server.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def __call__(\n    self,\n    query: Optional[Union[str, Query]] = None,\n    batch_size: Optional[int] = DEFAULT_BATCH_SIZE,\n    start_offset: int = 0,\n    with_suggestions: bool = True,\n    with_responses: bool = True,\n    with_vectors: Optional[Union[List, bool, str]] = None,\n):\n    \"\"\"Returns an iterator over the records in the dataset on the server.\n\n    Parameters:\n        query: A string or a Query object to filter the records.\n        batch_size: The number of records to fetch in each batch. The default is 256.\n        start_offset: The offset from which to start fetching records. The default is 0.\n        with_suggestions: Whether to include suggestions in the records. The default is True.\n        with_responses: Whether to include responses in the records. The default is True.\n        with_vectors: A list of vector names to include in the records. The default is None.\n            If a list is provided, only the specified vectors will be included.\n            If True is provided, all vectors will be included.\n\n    Returns:\n        An iterator over the records in the dataset on the server.\n\n    \"\"\"\n    if query and isinstance(query, str):\n        query = Query(query=query)\n\n    if with_vectors:\n        self.__validate_vector_names(vector_names=with_vectors)\n\n    return DatasetRecordsIteratorWithExportSupport(\n        self.__dataset,\n        self.__client,\n        query=query,\n        batch_size=batch_size,\n        start_offset=start_offset,\n        with_suggestions=with_suggestions,\n        with_responses=with_responses,\n        with_vectors=with_vectors,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.__init__","title":"<code>__init__(client, dataset)</code>","text":"<p>Initializes a DatasetRecords object with a client and a dataset. Args:     client: An Argilla client object.     dataset: A Dataset object.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def __init__(self, client: \"Argilla\", dataset: \"Dataset\"):\n    \"\"\"Initializes a DatasetRecords object with a client and a dataset.\n    Args:\n        client: An Argilla client object.\n        dataset: A Dataset object.\n    \"\"\"\n    self.__client = client\n    self.__dataset = dataset\n    self._api = self.__client.api.records\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.add","title":"<code>add(records, mapping=None, user_id=None, batch_size=DEFAULT_BATCH_SIZE)</code>","text":"<p>Add new records to a dataset on the server.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Union[dict, List[dict], Record, List[Record]]</code> <p>A dictionary or a list of dictionaries representing the records      to be added to the dataset. Records are defined as dictionaries      with keys corresponding to the fields in the dataset schema.</p> required <code>mapping</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary that maps the keys in the records to the fields in the dataset schema.</p> <code>None</code> <code>user_id</code> <code>Optional[UUID]</code> <p>The user id to be associated with the records. If not provided, the current user id is used.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of records to send in each batch. The default is 256.</p> <code>DEFAULT_BATCH_SIZE</code> <p>Returns:</p> Type Description <code>List[Record]</code> <p>A list of Record objects representing the added records.</p> <p>Examples:</p> <p>Add generic records to a dataset as dictionaries:</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def add(\n    self,\n    records: Union[dict, List[dict], Record, List[Record]],\n    mapping: Optional[Dict[str, str]] = None,\n    user_id: Optional[UUID] = None,\n    batch_size: int = DEFAULT_BATCH_SIZE,\n) -&gt; List[Record]:\n    \"\"\"\n    Add new records to a dataset on the server.\n\n    Parameters:\n        records: A dictionary or a list of dictionaries representing the records\n                 to be added to the dataset. Records are defined as dictionaries\n                 with keys corresponding to the fields in the dataset schema.\n        mapping: A dictionary that maps the keys in the records to the fields in the dataset schema.\n        user_id: The user id to be associated with the records. If not provided, the current user id is used.\n        batch_size: The number of records to send in each batch. The default is 256.\n\n    Returns:\n        A list of Record objects representing the added records.\n\n    Examples:\n\n    Add generic records to a dataset as dictionaries:\n\n    \"\"\"\n    record_models = self.__ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n\n    batch_size = self._normalize_batch_size(\n        batch_size=batch_size,\n        records_length=len(record_models),\n        max_value=self._api.MAX_RECORDS_PER_CREATE_BULK,\n    )\n\n    created_records = []\n    for batch in range(0, len(record_models), batch_size):\n        self.log(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n        batch_records = record_models[batch : batch + batch_size]\n        models = self._api.bulk_create(dataset_id=self.__dataset.id, records=batch_records)\n        created_records.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n\n    self.log(\n        message=f\"Added {len(created_records)} records to dataset {self.__dataset.name}\",\n        level=\"info\",\n    )\n\n    return created_records\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.to_dict","title":"<code>to_dict(flatten=False, orient='names')</code>","text":"<p>Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().</p> <p>Parameters:</p> Name Type Description Default <code>flatten</code> <code>bool</code> <p>Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.</p> <code>False</code> <code>orient</code> <code>str</code> <p>The structure of the exported dictionary.</p> <code>'names'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary of records.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def to_dict(self, flatten: bool = False, orient: str = \"names\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().\n\n    Parameters:\n        flatten (bool): Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.\n        orient (str): The structure of the exported dictionary.\n\n    Returns:\n        A dictionary of records.\n\n    \"\"\"\n    return self(with_suggestions=True, with_responses=True).to_dict(flatten=flatten, orient=orient)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.to_list","title":"<code>to_list(flatten=False)</code>","text":"<p>Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().</p> <p>Parameters:</p> Name Type Description Default <code>flatten</code> <code>bool</code> <p>Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of dictionaries of records.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def to_list(self, flatten: bool = False) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().\n\n    Parameters:\n        flatten (bool): Whether to flatten the dictionary and use dot notation for nested keys like suggestions and responses.\n\n    Returns:\n        A list of dictionaries of records.\n    \"\"\"\n    return self(with_suggestions=True, with_responses=True).to_list(flatten=flatten)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/dataset_records/#argilla_sdk.records.DatasetRecords.update","title":"<code>update(records, mapping=None, user_id=None, batch_size=DEFAULT_BATCH_SIZE)</code>","text":"<p>Update records in a dataset on the server using the provided records     and matching based on the external_id or id.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Union[dict, List[dict], Record, List[Record]]</code> <p>A dictionary or a list of dictionaries representing the records      to be updated in the dataset. Records are defined as dictionaries      with keys corresponding to the fields in the dataset schema. Ids or      external_ids should be provided to identify the records to be updated.</p> required <code>mapping</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary that maps the keys in the records to the fields in the dataset schema.</p> <code>None</code> <code>user_id</code> <code>Optional[UUID]</code> <p>The user id to be associated with the records. If not provided, the current user id is used.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of records to send in each batch. The default is 256.</p> <code>DEFAULT_BATCH_SIZE</code> <p>Returns:</p> Type Description <code>List[Record]</code> <p>A list of Record objects representing the updated records.</p> Source code in <code>src/argilla_sdk/records/_dataset_records.py</code> <pre><code>def update(\n    self,\n    records: Union[dict, List[dict], Record, List[Record]],\n    mapping: Optional[Dict[str, str]] = None,\n    user_id: Optional[UUID] = None,\n    batch_size: int = DEFAULT_BATCH_SIZE,\n) -&gt; List[Record]:\n    \"\"\"Update records in a dataset on the server using the provided records\n        and matching based on the external_id or id.\n\n    Parameters:\n        records: A dictionary or a list of dictionaries representing the records\n                 to be updated in the dataset. Records are defined as dictionaries\n                 with keys corresponding to the fields in the dataset schema. Ids or\n                 external_ids should be provided to identify the records to be updated.\n        mapping: A dictionary that maps the keys in the records to the fields in the dataset schema.\n        user_id: The user id to be associated with the records. If not provided, the current user id is used.\n        batch_size: The number of records to send in each batch. The default is 256.\n\n    Returns:\n        A list of Record objects representing the updated records.\n\n    \"\"\"\n    record_models = self.__ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n    batch_size = self._normalize_batch_size(\n        batch_size=batch_size,\n        records_length=len(record_models),\n        max_value=self._api.MAX_RECORDS_PER_UPSERT_BULK,\n    )\n\n    created_or_updated = []\n    records_updated = 0\n    for batch in range(0, len(records), batch_size):\n        self.log(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n        batch_records = record_models[batch : batch + batch_size]\n        models, updated = self._api.bulk_upsert(dataset_id=self.__dataset.id, records=batch_records)\n        created_or_updated.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n        records_updated += updated\n\n    records_created = len(created_or_updated) - records_updated\n    self.log(\n        message=f\"Updated {records_updated} records and added {records_created} records to dataset {self.__dataset.name}\",\n        level=\"info\",\n    )\n\n    return created_or_updated\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/","title":"<code>rg.Dataset</code>","text":"<p><code>Dataset</code> is a class that represents a collection of records. It is used to store and manage records in Argilla.</p>"},{"location":"reference/argilla_sdk/datasets/datasets/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/datasets/datasets/#creating-a-dataset","title":"Creating a Dataset","text":"<p>To create a new dataset you need to define its name and settings and then publish it to the server.</p> <pre><code>dataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=rg.Settings(\n        fields=[\n            rg.TextField(name=\"text\"),\n        ],\n        questions=[\n            rg.TextQuestion(name=\"response\"),\n        ],\n    ),\n)\ndataset.publish()\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#retrieving-an-existing-dataset","title":"Retrieving an existing Dataset","text":"<p>To retrieve an existing dataset, use <code>client.datasets(\"my_dataset\")</code> instead.</p> <pre><code>dataset = client.datasets(\"my_dataset\")\n</code></pre> <p>To check if a dataset exists on the server, use the <code>exists</code> method.</p> <pre><code>if dataset.exists() == False:\n    dataset.create()\n</code></pre> <p>To connect to an existing workspace refer to the workspace by id or object. For example:</p> <pre><code># Get an existing workspace\nworkspace = client.workspaces(\"my_workspace\")\ndataset = rg.Dataset(name=\"my_dataset\", workspace=workspace)\n\n# Use the workspace id\ndataset = rg.Dataset(name=\"my_dataset\", workspace_id=\"workspace_id\")\n\n# Use the first workspace\ndataset = rg.Dataset(name=\"my_dataset\")\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla Datasets</p> <p>Attributes:</p> Name Type Description <code>records</code> <code>DatasetRecords</code> <p>The records object</p> <code>is_published</code> <code>bool</code> <p>True if the dataset is published, False otherwise</p> <code>settings</code> <code>Settings</code> <p>The settings object</p> <code>fields</code> <code>list</code> <p>The fields of the dataset</p> <code>questions</code> <code>list</code> <p>The questions of the dataset</p> <code>guidelines</code> <code>str</code> <p>The guidelines of the dataset</p> <code>allow_extra_metadata</code> <code>bool</code> <p>True if extra metadata is allowed, False otherwise</p> <code>schema</code> <p>The schema of the dataset</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>class Dataset(Resource):\n    \"\"\"Class for interacting with Argilla Datasets\n\n    Attributes:\n        records (DatasetRecords): The records object\n        is_published (bool): True if the dataset is published, False otherwise\n        settings (Settings): The settings object\n        fields (list): The fields of the dataset\n        questions (list): The questions of the dataset\n        guidelines (str): The guidelines of the dataset\n        allow_extra_metadata (bool): True if extra metadata is allowed, False otherwise\n        schema: The schema of the dataset\n    \"\"\"\n\n    name: str\n    id: Optional[UUID]\n    status: Literal[\"draft\", \"ready\"]\n\n    _api: \"DatasetsAPI\"\n    _model: \"DatasetModel\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        status: Literal[\"draft\", \"ready\"] = \"draft\",\n        workspace: Optional[Union[\"Workspace\", str]] = None,\n        settings: Optional[Settings] = None,\n        client: Optional[\"Argilla\"] = Argilla(),\n        id: Optional[Union[UUID, str]] = None,\n        _model: Optional[DatasetModel] = None,\n    ) -&gt; None:\n        \"\"\"Initalizes a new Argilla Dataset object with the given parameters.\n\n        Parameters:\n            name (str): The name of the dataset\n            status (str): The status of the dataset\n            workspace_id (str): The id of the workspace\n            workspace (Workspace): The workspace object\n            settings (Settings): The settings object\n            client (Argilla): The client object\n            id (str): The id of the dataset\n            _model (DatasetModel): The model object\n\n\n        \"\"\"\n        super().__init__(client=client, api=client.api.datasets)\n        if name is None:\n            name = str(id)\n            self.log(f\"Settings dataset name to unique UUID: {id}\")\n        self.workspace_id = self.__workspace_id_from_name(workspace=workspace)\n        _model = _model or DatasetModel(\n            name=name,\n            status=status,\n            workspace_id=self._convert_optional_uuid(uuid=self.workspace_id),\n            id=self._convert_optional_uuid(uuid=id),\n        )\n        self._model = _model\n        self._settings = self.__configure_settings_for_dataset(settings=settings)\n        self.__records = DatasetRecords(client=self._client, dataset=self)\n        self._sync(model=self._model)\n\n    #####################\n    #  Properties       #\n    #####################\n\n    @property\n    def records(self) -&gt; \"DatasetRecords\":\n        return self.__records\n\n    @property\n    def is_published(self) -&gt; bool:\n        return self.exists() and self._model.status == \"ready\"\n\n    @property\n    def settings(self) -&gt; Settings:\n        if self.is_published and self._settings.is_outdated:\n            self._settings.get()\n        return self._settings\n\n    @settings.setter\n    def settings(self, value: Settings) -&gt; None:\n        self._settings = self.__configure_settings_for_dataset(settings=value)\n\n    @property\n    def fields(self) -&gt; list:\n        return self.settings.fields\n\n    @property\n    def questions(self) -&gt; list:\n        return self.settings.questions\n\n    @property\n    def guidelines(self) -&gt; str:\n        return self.settings.guidelines\n\n    @guidelines.setter\n    def guidelines(self, value: str) -&gt; None:\n        self.settings.guidelines = value\n\n    @property\n    def allow_extra_metadata(self) -&gt; bool:\n        return self.settings.allow_extra_metadata\n\n    @allow_extra_metadata.setter\n    def allow_extra_metadata(self, value: bool) -&gt; None:\n        self.settings.allow_extra_metadata = value\n\n    @property\n    def schema(self):\n        return self.settings.schema\n\n    #####################\n    #  Core methods     #\n    #####################\n\n    def exists(self) -&gt; bool:\n        \"\"\"Checks if the dataset exists on the server\n        Returns:\n            bool: True if the dataset exists, False otherwise\n        \"\"\"\n        return self.id and self._api.exists(self.id)\n\n    def publish(self) -&gt; None:\n        \"\"\"Publishes the dataset on the server with the `Settings` conffiguration\n        Returns:\n            None\n        \"\"\"\n        self._configure(settings=self._settings, publish=True)\n\n    #####################\n    #  CRUD operations  #\n    #####################\n\n    def create(self) -&gt; \"Dataset\":\n        \"\"\"Creates a new dataset on the server without `Settings` configuration and without publishing\n        Returns:\n            Dataset: The created dataset object\n        Examples:\n        \"\"\"\n        return super().create()\n\n    def get(self) -&gt; \"Dataset\":\n        \"\"\"Retrieves the dataset from the server\n        Returns:\n            Dataset: The retrieved dataset object\n        \"\"\"\n        return super().get()\n\n    def update(self) -&gt; \"Dataset\":\n        \"\"\"Updates the dataset on the server\n        Returns:\n            Dataset: The updated dataset object\n        Examples:\n        ```python\n        dataset = rg.Dataset(name=\"my_dataset\")\n        dataset.create()\n        # do something to the dataset configuration locally\n        dataset.update()\n        ```\n        \"\"\"\n        return super().update()\n\n    def delete(self) -&gt; None:\n        \"\"\"Deletes the dataset from the server\"\"\"\n        return super().delete()\n\n    #####################\n    #  Utility methods  #\n    #####################\n\n    # we leave this method as private for now and we use the `ds.publish` one\n    def _configure(self, settings: Settings, publish: bool = False) -&gt; \"Dataset\":\n        if not self.exists():\n            self.__create()\n\n        self._settings = self.__configure_settings_for_dataset(settings=settings)\n        self._settings.create()\n\n        if publish:\n            self.__publish()\n\n        return self.get()  # type: ignore\n\n    def __configure_settings_for_dataset(\n        self,\n        settings: Optional[Settings] = None,\n    ) -&gt; Settings:\n        if settings is None:\n            settings = Settings(_dataset=self)\n            warnings.warn(\n                message=\"Settings not provided. Using empty settings for the dataset. \\\n                    Define the settings before publishing the dataset.\",\n                stacklevel=2,\n            )\n        else:\n            settings.dataset = self\n        return settings\n\n    def __workspace_id_from_name(self, workspace: Optional[Union[\"Workspace\", str]]) -&gt; UUID:\n        available_workspaces = self._client.workspaces\n        available_workspace_names = [ws.name for ws in available_workspaces]\n        if workspace is None:\n            ws = available_workspaces[0]  # type: ignore\n            warnings.warn(f\"Workspace not provided. Using default workspace: {ws.name} id: {ws.id}\")\n        elif isinstance(workspace, str):\n            ws = self._client.workspaces(workspace)\n            if not ws.exists():\n                self.log(\n                    message=f\"Workspace with name {workspace} not found. \\\n                        Available workspaces: {available_workspace_names}\",\n                    level=\"error\",\n                )\n                raise NotFoundError()\n        else:\n            ws = workspace\n        return ws.id\n\n    def __create(self) -&gt; None:\n        response_model = self._api.create(self._model)\n        self._sync(response_model)\n\n    def __publish(self) -&gt; None:\n        self.settings.validate()\n        if not self.is_published:\n            response_model = self._api.publish(dataset_id=self._model.id)\n            self._sync(response_model)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.__init__","title":"<code>__init__(name=None, status='draft', workspace=None, settings=None, client=Argilla(), id=None, _model=None)</code>","text":"<p>Initalizes a new Argilla Dataset object with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset</p> <code>None</code> <code>status</code> <code>str</code> <p>The status of the dataset</p> <code>'draft'</code> <code>workspace_id</code> <code>str</code> <p>The id of the workspace</p> required <code>workspace</code> <code>Workspace</code> <p>The workspace object</p> <code>None</code> <code>settings</code> <code>Settings</code> <p>The settings object</p> <code>None</code> <code>client</code> <code>Argilla</code> <p>The client object</p> <code>Argilla()</code> <code>id</code> <code>str</code> <p>The id of the dataset</p> <code>None</code> <code>_model</code> <code>DatasetModel</code> <p>The model object</p> <code>None</code> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    status: Literal[\"draft\", \"ready\"] = \"draft\",\n    workspace: Optional[Union[\"Workspace\", str]] = None,\n    settings: Optional[Settings] = None,\n    client: Optional[\"Argilla\"] = Argilla(),\n    id: Optional[Union[UUID, str]] = None,\n    _model: Optional[DatasetModel] = None,\n) -&gt; None:\n    \"\"\"Initalizes a new Argilla Dataset object with the given parameters.\n\n    Parameters:\n        name (str): The name of the dataset\n        status (str): The status of the dataset\n        workspace_id (str): The id of the workspace\n        workspace (Workspace): The workspace object\n        settings (Settings): The settings object\n        client (Argilla): The client object\n        id (str): The id of the dataset\n        _model (DatasetModel): The model object\n\n\n    \"\"\"\n    super().__init__(client=client, api=client.api.datasets)\n    if name is None:\n        name = str(id)\n        self.log(f\"Settings dataset name to unique UUID: {id}\")\n    self.workspace_id = self.__workspace_id_from_name(workspace=workspace)\n    _model = _model or DatasetModel(\n        name=name,\n        status=status,\n        workspace_id=self._convert_optional_uuid(uuid=self.workspace_id),\n        id=self._convert_optional_uuid(uuid=id),\n    )\n    self._model = _model\n    self._settings = self.__configure_settings_for_dataset(settings=settings)\n    self.__records = DatasetRecords(client=self._client, dataset=self)\n    self._sync(model=self._model)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.create","title":"<code>create()</code>","text":"<p>Creates a new dataset on the server without <code>Settings</code> configuration and without publishing Returns:     Dataset: The created dataset object Examples:</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def create(self) -&gt; \"Dataset\":\n    \"\"\"Creates a new dataset on the server without `Settings` configuration and without publishing\n    Returns:\n        Dataset: The created dataset object\n    Examples:\n    \"\"\"\n    return super().create()\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.delete","title":"<code>delete()</code>","text":"<p>Deletes the dataset from the server</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Deletes the dataset from the server\"\"\"\n    return super().delete()\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.exists","title":"<code>exists()</code>","text":"<p>Checks if the dataset exists on the server Returns:     bool: True if the dataset exists, False otherwise</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Checks if the dataset exists on the server\n    Returns:\n        bool: True if the dataset exists, False otherwise\n    \"\"\"\n    return self.id and self._api.exists(self.id)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.get","title":"<code>get()</code>","text":"<p>Retrieves the dataset from the server Returns:     Dataset: The retrieved dataset object</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def get(self) -&gt; \"Dataset\":\n    \"\"\"Retrieves the dataset from the server\n    Returns:\n        Dataset: The retrieved dataset object\n    \"\"\"\n    return super().get()\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.publish","title":"<code>publish()</code>","text":"<p>Publishes the dataset on the server with the <code>Settings</code> conffiguration Returns:     None</p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def publish(self) -&gt; None:\n    \"\"\"Publishes the dataset on the server with the `Settings` conffiguration\n    Returns:\n        None\n    \"\"\"\n    self._configure(settings=self._settings, publish=True)\n</code></pre>"},{"location":"reference/argilla_sdk/datasets/datasets/#argilla_sdk.datasets.Dataset.update","title":"<code>update()</code>","text":"<p>Updates the dataset on the server Returns:     Dataset: The updated dataset object Examples: <pre><code>dataset = rg.Dataset(name=\"my_dataset\")\ndataset.create()\n# do something to the dataset configuration locally\ndataset.update()\n</code></pre></p> Source code in <code>src/argilla_sdk/datasets/_resource.py</code> <pre><code>def update(self) -&gt; \"Dataset\":\n    \"\"\"Updates the dataset on the server\n    Returns:\n        Dataset: The updated dataset object\n    Examples:\n    ```python\n    dataset = rg.Dataset(name=\"my_dataset\")\n    dataset.create()\n    # do something to the dataset configuration locally\n    dataset.update()\n    ```\n    \"\"\"\n    return super().update()\n</code></pre>"},{"location":"reference/argilla_sdk/records/metadata/","title":"<code>metadata</code>","text":"<p>Metadata in argilla is a dictionary that can be attached to a record. It is used to store additional information about the record that is not part of the record's fields or responses. For example, the source of the record, the date it was created, or any other information that is relevant to the record. Metadata can be added to a record directly or as valules within a dictionary.</p>"},{"location":"reference/argilla_sdk/records/metadata/#usage-examples","title":"Usage Examples","text":"<p>To use metadata within a dataset, you must define a metadata property in the dataset settings. The metadata property is a list of metadata properties that can be attached to a record. The following example demonstrates how to add metadata to a dataset and how to access metadata from a record object:</p> <pre><code>import argilla_sdk as rg\n\ndataset = Dataset(\n    name=\"dataset_with_metadata\",\n    settings=Settings(\n        fields=[TextField(name=\"text\")],\n        questions=[LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])],\n        metadata=[\n            rg.TermsMetadataProperty(name=\"category\", options=[\"A\", \"B\", \"C\"]),\n        ],\n    ),\n)\ndataset.publish()\n</code></pre> <p>Then, you can add records to the dataset with metadata that corresponds to the metadata property defined in the dataset settings:</p> <pre><code>dataset_with_metadata.records.add(\n    [\n        {\"text\": \"text\", \"label\": \"positive\", \"category\": \"A\"},\n        {\"text\": \"text\", \"label\": \"negative\", \"category\": \"B\"},\n    ]\n)\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/","title":"<code>rg.Record</code>","text":"<p>The <code>Record</code> object is used to represent a single record in Argilla. It contains fields, suggestions, responses, metadata, and vectors.</p>"},{"location":"reference/argilla_sdk/records/records/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/records/records/#creating-a-record","title":"Creating a Record","text":"<p>In most cases the user can add records as dictionaries via the <code>Dataset.records.add</code> method.  Argilla will instantiate the <code>Record</code> class based on the input data and <code>mapping</code> property. </p> <pre><code>dataset.records.add(\n    records=[\n    {\n        \"question\": \"What is the capital of France?\", \n        \"answer\": \"Paris\"\n    },\n])\n</code></pre> <p>However, you can also create <code>Record</code> objects directly and pass them to the same method.</p> <pre><code>records = [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            responses=[rg.Response(\"label\", \"positive\", user_id=user_id)],\n        ),\n    ]\ndataset.records.add(records=records)\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#accessing-record-attributes","title":"Accessing Record Attributes","text":"<p>The <code>Record</code> object has suggestions, responses, metadata, and vectors attributes that can be accessed directly whilst iterating over records in a dataset.</p> <pre><code>for record in dataset.records(\n    with_suggestions=True, \n    with_responses=True, \n    with_metadata=True, \n    with_vectors=True\n    ):\n    print(record.suggestions)\n    print(record.responses)\n    print(record.metadata)\n    print(record.vectors)\n</code></pre> <p>Record properties can also be updated whilst iterating over records in a dataset.</p> <pre><code>for record in dataset.records(with_metadata=True):\n    record.metadata = {\"department\": \"toys\"}\n</code></pre> <p>For changes to take effect, the user must call the <code>update</code> method on the <code>Dataset</code> object.</p>"},{"location":"reference/argilla_sdk/records/records/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>Resource</code></p> <p>The class for interacting with Argilla Records. A <code>Record</code> is a single sample in a dataset. Records receives feedback in the form of responses and suggestions. Records contain fields, metadata, and vectors.</p> <p>Attributes:</p> Name Type Description <code>fields</code> <code>RecordFields</code> <p>The fields of the record.</p> <code>metadata</code> <code>RecordMetadata</code> <p>The metadata of the record.</p> <code>vectors</code> <code>RecordVectors</code> <p>The vectors of the record.</p> <code>responses</code> <code>RecordResponses</code> <p>The responses of the record.</p> <code>suggestions</code> <code>RecordSuggestions</code> <p>The suggestions of the record.</p> <code>external_id</code> <code>str</code> <p>The external id of the record.</p> <code>id</code> <code>str</code> <p>The id of the record.</p> <code>dataset</code> <code>Dataset</code> <p>The dataset to which the record belongs.</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>class Record(Resource):\n    \"\"\"The class for interacting with Argilla Records. A `Record` is a single sample\n    in a dataset. Records receives feedback in the form of responses and suggestions.\n    Records contain fields, metadata, and vectors.\n\n    Attributes:\n        fields (RecordFields): The fields of the record.\n        metadata (RecordMetadata): The metadata of the record.\n        vectors (RecordVectors): The vectors of the record.\n        responses (RecordResponses): The responses of the record.\n        suggestions (RecordSuggestions): The suggestions of the record.\n        external_id (str): The external id of the record.\n        id (str): The id of the record.\n        dataset (Dataset): The dataset to which the record belongs.\n    \"\"\"\n\n    _model: RecordModel\n\n    # TODO: Once the RecordsAPI is implemented, this class could\n    # be adapted to extend a Resource class and\n    # provide mechanisms to update and delete single records.\n    # This record would be used for fetching records in a custom schema.\n    # Let's see this when we tackle the fetch records endpoint\n\n    def __init__(\n        self,\n        fields: Dict[str, Union[str, None]] = None,\n        metadata: Optional[Dict[str, MetadataValue]] = None,\n        vectors: Optional[List[Vector]] = None,\n        responses: Optional[List[Response]] = None,\n        suggestions: Optional[Union[Tuple[Suggestion], List[Suggestion]]] = None,\n        external_id: Optional[str] = None,\n        id: Optional[str] = None,\n        dataset: Optional[\"Dataset\"] = None,\n    ):\n        \"\"\"Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id.\n        Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions\n        and passed to Dataset.DatasetRecords.add() as a list of dictionaries.\n\n        Args:\n            fields: A dictionary of fields for the record.\n            metadata: A dictionary of metadata for the record.\n            vectors: A dictionary of vectors for the record.\n            responses: A list of Response objects for the record.\n            suggestions: A list of Suggestion objects for the record.\n            external_id: An external id for the record.\n            id: An id for the record.\n            dataset: The dataset object to which the record belongs.\n        \"\"\"\n        self._dataset = dataset\n\n        self._model = RecordModel(\n            fields=fields,\n            external_id=external_id or uuid4(),\n            id=id,\n        )\n        # TODO: All this code blocks could be define as property setters\n        # Initialize the fields\n        self.__fields = RecordFields(fields=self._model.fields)\n        # Initialize the vectors\n        self.__vectors = RecordVectors(vectors=vectors, record=self)\n        self._model.vectors = self.__vectors.models\n        # Initialize the metadata\n        self.__metadata = RecordMetadata(metadata=metadata)\n        self._model.metadata = self.__metadata.models\n        # Initialize the responses and suggestions\n        self._set_responses(responses or [])\n        self._set_suggestions(suggestions or [])\n\n    def __repr__(self) -&gt; Generator:\n        yield self.fields\n        yield self.responses\n        yield self.suggestions\n        yield self.metadata\n        yield self.vectors\n\n    ############################\n    # Properties\n    ############################\n\n    @property\n    def dataset(self) -&gt; \"Dataset\":\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, value: \"Dataset\") -&gt; None:\n        self._dataset = value\n        # Update the dataset for the responses and suggestions\n        self._set_responses(self.responses)\n        self._set_suggestions(self.suggestions)\n\n    @property\n    def external_id(self) -&gt; str:\n        return self._model.external_id\n\n    @external_id.setter\n    def external_id(self, value: str) -&gt; None:\n        self._model.external_id = str(value)\n\n    @property\n    def fields(self) -&gt; \"RecordFields\":\n        return self.__fields\n\n    @property\n    def responses(self) -&gt; \"RecordResponses\":\n        return self.__responses\n\n    @property\n    def suggestions(self) -&gt; \"RecordSuggestions\":\n        return self.__suggestions\n\n    @property\n    def metadata(self) -&gt; \"RecordMetadata\":\n        return self.__metadata\n\n    @property\n    def vectors(self) -&gt; \"RecordVectors\":\n        return self.__vectors\n\n    ############################\n    # Public methods\n    ############################\n\n    def serialize(self) -&gt; Dict[str, Any]:\n        \"\"\"Serializes the Record to a dictionary for interaction with the API\"\"\"\n        serialized_model = self._model.model_dump()\n        serialized_suggestions = [suggestion.serialize() for suggestion in self.__suggestions]\n        serialized_responses = [response.serialize() for response in self.__responses]\n        serialized_model[\"responses\"] = serialized_responses\n        serialized_model[\"suggestions\"] = serialized_suggestions\n        return serialized_model\n\n    @classmethod\n    def from_dict(\n        cls,\n        dataset: \"Dataset\",\n        data: dict,\n        mapping: Optional[Dict[str, str]] = None,\n        user_id: Optional[UUID] = None,\n    ) -&gt; \"Record\":\n        \"\"\"Converts a record dictionary to a Record object.\n        Args:\n            dataset: The dataset object to which the record belongs.\n            data: A dictionary representing the record.\n            mapping: A dictionary mapping source data keys to Argilla fields, questions, and ids.\n            user_id: The user id to associate with the record responses.\n        Returns:\n            A Record object.\n        \"\"\"\n\n        fields: Dict[str, str] = {}\n        responses: List[Response] = []\n        record_id: Optional[str] = None\n        suggestion_values = defaultdict(dict)\n        vectors: List[Vector] = []\n        metadata: Dict[str, MetadataValue] = {}\n\n        schema = dataset.schema\n\n        for attribute, value in data.items():\n            schema_item = schema.get(attribute)\n            attribute_type = None\n            sub_attribute = None\n\n            # Map source data keys using the mapping\n            if mapping and attribute in mapping:\n                attribute_mapping = mapping.get(attribute)\n                attribute_mapping = attribute_mapping.split(\".\")\n                attribute = attribute_mapping[0]\n                schema_item = schema.get(attribute)\n                if len(attribute_mapping) &gt; 1:\n                    attribute_type = attribute_mapping[1]\n                if len(attribute_mapping) &gt; 2:\n                    sub_attribute = attribute_mapping[2]\n            elif schema_item is mapping is None:\n                warnings.warn(\n                    message=f\"\"\"Record attribute {attribute} is not in the schema so skipping. \n                        Define a mapping to map source data fields to Argilla Fields, Questions, and ids\n                        \"\"\"\n                )\n                continue\n\n            # Skip if the attribute is an id or external_id\n            if attribute == \"id\":\n                record_id = value\n                continue\n\n            # Add suggestion values to the suggestions\n            if attribute_type == \"suggestion\":\n                if sub_attribute in [\"score\", \"agent\"]:\n                    suggestion_values[attribute][sub_attribute] = value\n\n                elif sub_attribute is None:\n                    suggestion_values[attribute].update(\n                        {\"value\": value, \"question_name\": attribute, \"question_id\": schema_item.id}\n                    )\n                else:\n                    warnings.warn(\n                        message=f\"Record attribute {sub_attribute} is not a valid suggestion sub_attribute so skipping.\"\n                    )\n                continue\n\n            # Assign the value to question, field, or response based on schema item\n            if isinstance(schema_item, TextField):\n                fields[attribute] = value\n            elif isinstance(schema_item, QuestionType) and attribute_type == \"response\":\n                responses.append(Response(question_name=attribute, value=value, user_id=user_id))\n            elif isinstance(schema_item, QuestionType) and attribute_type is None:\n                suggestion_values[attribute].update(\n                    {\"value\": value, \"question_name\": attribute, \"question_id\": schema_item.id}\n                )\n            elif isinstance(schema_item, VectorField):\n                vectors.append(Vector(name=attribute, values=value))\n            elif isinstance(schema_item, MetadataType):\n                metadata[attribute] = value\n            else:\n                warnings.warn(message=f\"\"\"Record attribute {attribute} is not in the schema or mapping so skipping.\"\"\")\n                continue\n\n        suggestions = [Suggestion(**suggestion_dict) for suggestion_dict in suggestion_values.values()]\n\n        return cls(\n            id=record_id,\n            fields=fields,\n            suggestions=suggestions,\n            responses=responses,\n            vectors=vectors,\n            metadata=metadata,\n            external_id=data.get(\"external_id\") or record_id,\n            dataset=dataset,\n        )\n\n    def to_dict(self) -&gt; Dict[str, Dict]:\n        \"\"\"Converts a Record object to a dictionary for export.\n        Returns:\n            A dictionary representing the record where the keys are \"fields\",\n            \"metadata\", \"suggestions\", and \"responses\". Each field and question is\n            represented as a key-value pair in the dictionary of the respective key. i.e.\n            `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},\n        \"\"\"\n        fields = self.fields.to_dict()\n        metadata = self.metadata\n        suggestions = self.suggestions.to_dict()\n        responses = self.responses.to_dict()\n        record_dict = {\n            \"fields\": fields,\n            \"metadata\": metadata,\n            \"suggestions\": suggestions,\n            \"responses\": responses,\n            \"external_id\": self.external_id,\n        }\n        return record_dict\n\n    @classmethod\n    def from_model(cls, model: RecordModel, dataset: Optional[\"Dataset\"] = None) -&gt; \"Record\":\n        \"\"\"Converts a RecordModel object to a Record object.\n        Args:\n            model: A RecordModel object.\n            dataset: The dataset object to which the record belongs.\n        Returns:\n            A Record object.\n        \"\"\"\n        return cls(\n            id=model.id,\n            external_id=model.external_id,\n            fields=model.fields,\n            metadata={meta.name: meta.value for meta in model.metadata},\n            vectors=[Vector.from_model(model=vector) for vector in model.vectors],\n            # Responses and their models are not aligned 1-1.\n            responses=[\n                response\n                for response_model in model.responses\n                for response in UserResponse.from_model(response_model).answers\n            ],\n            suggestions=[Suggestion.from_model(model=suggestion) for suggestion in model.suggestions],\n            dataset=dataset,\n        )\n\n    def _set_responses(self, responses: Iterable[Response]):\n        self.__responses = RecordResponses(responses=[responses for responses in responses], record=self)\n        self._model.responses = self.__responses.models\n\n    def _set_suggestions(self, suggestions: Iterable[Suggestion]) -&gt; None:\n        self.__suggestions = RecordSuggestions(suggestions=[suggestion for suggestion in suggestions], record=self)\n        self._model.suggestions = self.__suggestions.models\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.__init__","title":"<code>__init__(fields=None, metadata=None, vectors=None, responses=None, suggestions=None, external_id=None, id=None, dataset=None)</code>","text":"<p>Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id. Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions and passed to Dataset.DatasetRecords.add() as a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Dict[str, Union[str, None]]</code> <p>A dictionary of fields for the record.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, MetadataValue]]</code> <p>A dictionary of metadata for the record.</p> <code>None</code> <code>vectors</code> <code>Optional[List[Vector]]</code> <p>A dictionary of vectors for the record.</p> <code>None</code> <code>responses</code> <code>Optional[List[Response]]</code> <p>A list of Response objects for the record.</p> <code>None</code> <code>suggestions</code> <code>Optional[Union[Tuple[Suggestion], List[Suggestion]]]</code> <p>A list of Suggestion objects for the record.</p> <code>None</code> <code>external_id</code> <code>Optional[str]</code> <p>An external id for the record.</p> <code>None</code> <code>id</code> <code>Optional[str]</code> <p>An id for the record.</p> <code>None</code> <code>dataset</code> <code>Optional[Dataset]</code> <p>The dataset object to which the record belongs.</p> <code>None</code> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>def __init__(\n    self,\n    fields: Dict[str, Union[str, None]] = None,\n    metadata: Optional[Dict[str, MetadataValue]] = None,\n    vectors: Optional[List[Vector]] = None,\n    responses: Optional[List[Response]] = None,\n    suggestions: Optional[Union[Tuple[Suggestion], List[Suggestion]]] = None,\n    external_id: Optional[str] = None,\n    id: Optional[str] = None,\n    dataset: Optional[\"Dataset\"] = None,\n):\n    \"\"\"Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id.\n    Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions\n    and passed to Dataset.DatasetRecords.add() as a list of dictionaries.\n\n    Args:\n        fields: A dictionary of fields for the record.\n        metadata: A dictionary of metadata for the record.\n        vectors: A dictionary of vectors for the record.\n        responses: A list of Response objects for the record.\n        suggestions: A list of Suggestion objects for the record.\n        external_id: An external id for the record.\n        id: An id for the record.\n        dataset: The dataset object to which the record belongs.\n    \"\"\"\n    self._dataset = dataset\n\n    self._model = RecordModel(\n        fields=fields,\n        external_id=external_id or uuid4(),\n        id=id,\n    )\n    # TODO: All this code blocks could be define as property setters\n    # Initialize the fields\n    self.__fields = RecordFields(fields=self._model.fields)\n    # Initialize the vectors\n    self.__vectors = RecordVectors(vectors=vectors, record=self)\n    self._model.vectors = self.__vectors.models\n    # Initialize the metadata\n    self.__metadata = RecordMetadata(metadata=metadata)\n    self._model.metadata = self.__metadata.models\n    # Initialize the responses and suggestions\n    self._set_responses(responses or [])\n    self._set_suggestions(suggestions or [])\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.from_dict","title":"<code>from_dict(dataset, data, mapping=None, user_id=None)</code>  <code>classmethod</code>","text":"<p>Converts a record dictionary to a Record object. Args:     dataset: The dataset object to which the record belongs.     data: A dictionary representing the record.     mapping: A dictionary mapping source data keys to Argilla fields, questions, and ids.     user_id: The user id to associate with the record responses. Returns:     A Record object.</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls,\n    dataset: \"Dataset\",\n    data: dict,\n    mapping: Optional[Dict[str, str]] = None,\n    user_id: Optional[UUID] = None,\n) -&gt; \"Record\":\n    \"\"\"Converts a record dictionary to a Record object.\n    Args:\n        dataset: The dataset object to which the record belongs.\n        data: A dictionary representing the record.\n        mapping: A dictionary mapping source data keys to Argilla fields, questions, and ids.\n        user_id: The user id to associate with the record responses.\n    Returns:\n        A Record object.\n    \"\"\"\n\n    fields: Dict[str, str] = {}\n    responses: List[Response] = []\n    record_id: Optional[str] = None\n    suggestion_values = defaultdict(dict)\n    vectors: List[Vector] = []\n    metadata: Dict[str, MetadataValue] = {}\n\n    schema = dataset.schema\n\n    for attribute, value in data.items():\n        schema_item = schema.get(attribute)\n        attribute_type = None\n        sub_attribute = None\n\n        # Map source data keys using the mapping\n        if mapping and attribute in mapping:\n            attribute_mapping = mapping.get(attribute)\n            attribute_mapping = attribute_mapping.split(\".\")\n            attribute = attribute_mapping[0]\n            schema_item = schema.get(attribute)\n            if len(attribute_mapping) &gt; 1:\n                attribute_type = attribute_mapping[1]\n            if len(attribute_mapping) &gt; 2:\n                sub_attribute = attribute_mapping[2]\n        elif schema_item is mapping is None:\n            warnings.warn(\n                message=f\"\"\"Record attribute {attribute} is not in the schema so skipping. \n                    Define a mapping to map source data fields to Argilla Fields, Questions, and ids\n                    \"\"\"\n            )\n            continue\n\n        # Skip if the attribute is an id or external_id\n        if attribute == \"id\":\n            record_id = value\n            continue\n\n        # Add suggestion values to the suggestions\n        if attribute_type == \"suggestion\":\n            if sub_attribute in [\"score\", \"agent\"]:\n                suggestion_values[attribute][sub_attribute] = value\n\n            elif sub_attribute is None:\n                suggestion_values[attribute].update(\n                    {\"value\": value, \"question_name\": attribute, \"question_id\": schema_item.id}\n                )\n            else:\n                warnings.warn(\n                    message=f\"Record attribute {sub_attribute} is not a valid suggestion sub_attribute so skipping.\"\n                )\n            continue\n\n        # Assign the value to question, field, or response based on schema item\n        if isinstance(schema_item, TextField):\n            fields[attribute] = value\n        elif isinstance(schema_item, QuestionType) and attribute_type == \"response\":\n            responses.append(Response(question_name=attribute, value=value, user_id=user_id))\n        elif isinstance(schema_item, QuestionType) and attribute_type is None:\n            suggestion_values[attribute].update(\n                {\"value\": value, \"question_name\": attribute, \"question_id\": schema_item.id}\n            )\n        elif isinstance(schema_item, VectorField):\n            vectors.append(Vector(name=attribute, values=value))\n        elif isinstance(schema_item, MetadataType):\n            metadata[attribute] = value\n        else:\n            warnings.warn(message=f\"\"\"Record attribute {attribute} is not in the schema or mapping so skipping.\"\"\")\n            continue\n\n    suggestions = [Suggestion(**suggestion_dict) for suggestion_dict in suggestion_values.values()]\n\n    return cls(\n        id=record_id,\n        fields=fields,\n        suggestions=suggestions,\n        responses=responses,\n        vectors=vectors,\n        metadata=metadata,\n        external_id=data.get(\"external_id\") or record_id,\n        dataset=dataset,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.from_model","title":"<code>from_model(model, dataset=None)</code>  <code>classmethod</code>","text":"<p>Converts a RecordModel object to a Record object. Args:     model: A RecordModel object.     dataset: The dataset object to which the record belongs. Returns:     A Record object.</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>@classmethod\ndef from_model(cls, model: RecordModel, dataset: Optional[\"Dataset\"] = None) -&gt; \"Record\":\n    \"\"\"Converts a RecordModel object to a Record object.\n    Args:\n        model: A RecordModel object.\n        dataset: The dataset object to which the record belongs.\n    Returns:\n        A Record object.\n    \"\"\"\n    return cls(\n        id=model.id,\n        external_id=model.external_id,\n        fields=model.fields,\n        metadata={meta.name: meta.value for meta in model.metadata},\n        vectors=[Vector.from_model(model=vector) for vector in model.vectors],\n        # Responses and their models are not aligned 1-1.\n        responses=[\n            response\n            for response_model in model.responses\n            for response in UserResponse.from_model(response_model).answers\n        ],\n        suggestions=[Suggestion.from_model(model=suggestion) for suggestion in model.suggestions],\n        dataset=dataset,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.serialize","title":"<code>serialize()</code>","text":"<p>Serializes the Record to a dictionary for interaction with the API</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>def serialize(self) -&gt; Dict[str, Any]:\n    \"\"\"Serializes the Record to a dictionary for interaction with the API\"\"\"\n    serialized_model = self._model.model_dump()\n    serialized_suggestions = [suggestion.serialize() for suggestion in self.__suggestions]\n    serialized_responses = [response.serialize() for response in self.__responses]\n    serialized_model[\"responses\"] = serialized_responses\n    serialized_model[\"suggestions\"] = serialized_suggestions\n    return serialized_model\n</code></pre>"},{"location":"reference/argilla_sdk/records/records/#argilla_sdk.records.Record.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts a Record object to a dictionary for export. Returns:     A dictionary representing the record where the keys are \"fields\",     \"metadata\", \"suggestions\", and \"responses\". Each field and question is     represented as a key-value pair in the dictionary of the respective key. i.e.     `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},</p> Source code in <code>src/argilla_sdk/records/_resource.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Dict]:\n    \"\"\"Converts a Record object to a dictionary for export.\n    Returns:\n        A dictionary representing the record where the keys are \"fields\",\n        \"metadata\", \"suggestions\", and \"responses\". Each field and question is\n        represented as a key-value pair in the dictionary of the respective key. i.e.\n        `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},\n    \"\"\"\n    fields = self.fields.to_dict()\n    metadata = self.metadata\n    suggestions = self.suggestions.to_dict()\n    responses = self.responses.to_dict()\n    record_dict = {\n        \"fields\": fields,\n        \"metadata\": metadata,\n        \"suggestions\": suggestions,\n        \"responses\": responses,\n        \"external_id\": self.external_id,\n    }\n    return record_dict\n</code></pre>"},{"location":"reference/argilla_sdk/records/responses/","title":"<code>rg.Response</code>","text":"<p>Class for interacting with Argilla Responses of records. Responses are answers to questions by a user. Therefore, a recod question can have multiple responses, one for each user that has answered the question. A <code>Response</code> is typically created by a user in the UI or consumed from a data source as a label, unlike a <code>Suggestion</code> which is typically created by a model prediction.</p>"},{"location":"reference/argilla_sdk/records/responses/#usage-examples","title":"Usage Examples","text":"<p>Responses can be added to an instantiated <code>Record</code> directly or as a dictionary a dictionary. The following examples demonstrate how to add responses to a record object and how to access responses from a record object:</p> <p>Instantiate the <code>Record</code> and related <code>Response</code> objects:</p> <pre><code>dataset.records.add(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            responses=[rg.Response(\"label\", \"negative\", user_id=user.id)],\n            external_id=str(uuid.uuid4()),\n        )\n    ]\n)\n</code></pre> <p>Or, add a response from a dictionary where key is the question name and value is the response:</p> <pre><code>dataset.records.add(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"label.response\": \"negative\",\n        },\n    ]\n)\n</code></pre> <p>Responses can be accessed from a <code>Record</code> via their question name as an attribute of the record. So if a question is named <code>label</code>, the response can be accessed as <code>record.label</code>. The following example demonstrates how to access responses from a record object:</p> <pre><code># iterate over the records and responses\n\nfor record in dataset.records:\n    for response in record.responses.label:\n        print(response.value)\n        print(response.user_id)\n\n# validate that the record has a response\n\nfor record in dataset.records:\n    if record.responses.label:\n        for response in record.responses.label:\n            print(response.value)\n            print(response.user_id)\n</code></pre>"},{"location":"reference/argilla_sdk/records/responses/#class-reference","title":"Class Reference","text":"<p>Class for interacting with Argilla Responses of records. Responses are answers to questions by a user. Therefore, a recod question can have multiple responses, one for each user that has answered the question. A <code>Response</code> is typically created by a user in the UI or consumed from a data source as a label, unlike a <code>Suggestion</code> which is typically created by a model prediction.</p> Source code in <code>src/argilla_sdk/responses.py</code> <pre><code>class Response:\n    \"\"\"Class for interacting with Argilla Responses of records. Responses are answers to questions by a user.\n    Therefore, a recod question can have multiple responses, one for each user that has answered the question.\n    A `Response` is typically created by a user in the UI or consumed from a data source as a label,\n    unlike a `Suggestion` which is typically created by a model prediction.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        question_name: str,\n        value: Any,\n        user_id: UUID,\n    ) -&gt; None:\n        \"\"\"Initializes a `Response` for a `Record` with a user_id and value\"\"\"\n\n        self.question_name = question_name\n        self.value = value\n        self.user_id = user_id\n\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"Serializes the Response to a dictionary. This is principally used for sending the response to the API, \\\n            but can be used for data wrangling or manual export.\n\n        Returns:\n            dict[str, Any]: The serialized response as a dictionary with keys `question_name`, `value`, and `user_id`.\n\n        Examples:\n\n        ```python\n        response = rg.Response(\"label\", \"negative\", user_id=user.id)\n        response.serialize()\n        ```\n        \"\"\"\n        return {\n            \"question_name\": self.question_name,\n            \"value\": self.value,\n            \"user_id\": self.user_id,\n        }\n</code></pre>"},{"location":"reference/argilla_sdk/records/responses/#argilla_sdk.responses.Response.__init__","title":"<code>__init__(question_name, value, user_id)</code>","text":"<p>Initializes a <code>Response</code> for a <code>Record</code> with a user_id and value</p> Source code in <code>src/argilla_sdk/responses.py</code> <pre><code>def __init__(\n    self,\n    question_name: str,\n    value: Any,\n    user_id: UUID,\n) -&gt; None:\n    \"\"\"Initializes a `Response` for a `Record` with a user_id and value\"\"\"\n\n    self.question_name = question_name\n    self.value = value\n    self.user_id = user_id\n</code></pre>"},{"location":"reference/argilla_sdk/records/responses/#argilla_sdk.responses.Response.serialize","title":"<code>serialize()</code>","text":"<p>Serializes the Response to a dictionary. This is principally used for sending the response to the API,             but can be used for data wrangling or manual export.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The serialized response as a dictionary with keys <code>question_name</code>, <code>value</code>, and <code>user_id</code>.</p> <p>Examples:</p> <pre><code>response = rg.Response(\"label\", \"negative\", user_id=user.id)\nresponse.serialize()\n</code></pre> Source code in <code>src/argilla_sdk/responses.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serializes the Response to a dictionary. This is principally used for sending the response to the API, \\\n        but can be used for data wrangling or manual export.\n\n    Returns:\n        dict[str, Any]: The serialized response as a dictionary with keys `question_name`, `value`, and `user_id`.\n\n    Examples:\n\n    ```python\n    response = rg.Response(\"label\", \"negative\", user_id=user.id)\n    response.serialize()\n    ```\n    \"\"\"\n    return {\n        \"question_name\": self.question_name,\n        \"value\": self.value,\n        \"user_id\": self.user_id,\n    }\n</code></pre>"},{"location":"reference/argilla_sdk/records/suggestions/","title":"<code>rg.Suggestion</code>","text":"<p>Class for interacting with Argilla Suggestions of records. Suggestions are typically created by a model prediction, unlike a <code>Response</code> which is typically created by a user in the UI or consumed from a data source as a label.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/records/suggestions/#adding-records-with-suggestions","title":"Adding records with suggestions","text":"<p>Suggestions can be added to a record directly or via a dictionary structure. The following examples demonstrate how to add suggestions to a record object and how to access suggestions from a record object:</p> <p>Add a response from a dictionary where key is the question name and value is the response:</p> <p><pre><code>dataset.records.add(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"label\": \"negative\",\n            \"label.response\": \"negative\",\n            \"label.score\": 0.9,\n        },\n    ]\n)\n</code></pre> Or, instantiate the <code>Record</code> and related <code>Suggestions</code> objects directly, like this:</p> <pre><code>dataset.records.add(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            suggestions=[rg.Suggestion(\"negative\", \"label\", score=0.9, agent=\"model_name\")],\n        )\n    ]\n)\n</code></pre>"},{"location":"reference/argilla_sdk/records/suggestions/#iterating-over-records-with-suggestions","title":"Iterating over records with suggestions","text":"<p>Just like responses, suggestions can be accessed from a <code>Record</code> via their question name as an attribute of the record. So if a question is named <code>label</code>, the suggestion can be accessed as <code>record.label</code>. The following example demonstrates how to access suggestions from a record object:</p> <pre><code>for record in dataset.records(with_suggestions=True):\n    print(record.suggestions.label)\n</code></pre>"},{"location":"reference/argilla_sdk/records/suggestions/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla Suggestions. Suggestions are typically model predictions for records. Suggestions are rendered in the user interfaces as 'hints' or 'suggestions' for the user to review and accept or reject.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The value of the suggestion.add()</p> <code>question_name</code> <code>str</code> <p>The name of the question that the suggestion is for.</p> <code>type</code> <code>str</code> <p>The type of suggestion, either 'model' or 'human'.</p> <code>score</code> <code>float</code> <p>The score of the suggestion. For example, the probability of the model prediction.</p> <code>agent</code> <code>str</code> <p>The agent that created the suggestion. For example, the model name.</p> <code>question_id</code> <code>UUID</code> <p>The ID of the question that the suggestion is for.</p> Source code in <code>src/argilla_sdk/suggestions.py</code> <pre><code>class Suggestion(Resource):\n    \"\"\"Class for interacting with Argilla Suggestions. Suggestions are typically model predictions for records.\n    Suggestions are rendered in the user interfaces as 'hints' or 'suggestions' for the user to review and accept or reject.\n\n    Attributes:\n        value (str): The value of the suggestion.add()\n        question_name (str): The name of the question that the suggestion is for.\n        type (str): The type of suggestion, either 'model' or 'human'.\n        score (float): The score of the suggestion. For example, the probability of the model prediction.\n        agent (str): The agent that created the suggestion. For example, the model name.\n        question_id (UUID): The ID of the question that the suggestion is for.\n\n    \"\"\"\n\n    _model: SuggestionModel\n\n    def __init__(\n        self,\n        question_name: str,\n        value: Any,\n        score: Union[float, List[float], None] = None,\n        agent: Optional[str] = None,\n        type: Optional[Literal[\"model\", \"human\"]] = None,\n        id: Optional[UUID] = None,\n        question_id: Optional[UUID] = None,\n    ) -&gt; None:\n        super().__init__()\n\n        self._model = SuggestionModel(\n            value=value,\n            question_name=question_name,\n            type=type,\n            score=score,\n            agent=agent,\n            id=id,\n            question_id=question_id,\n        )\n\n\n    ##############################\n    # Properties\n    ##############################\n\n    @property\n    def value(self) -&gt; Any:\n        \"\"\"The value of the suggestion.\"\"\"\n        return self._model.value\n\n    # TODO: Add getter and setter at question type level\n    #  @property\n    #  def question(self) -&gt; Optional[\"QuestionType\"]:\n    #      pass\n    #  @question.setter\n    #  def question(self, value: \"QuestionType\") -&gt; None:\n    #      self._model.question_name = value.name\n    #      self._model.question_id = value.id\n\n    @property\n    def question_name(self) -&gt; Optional[str]:\n        \"\"\"The name of the question that the suggestion is for.\"\"\"\n        return self._model.question_name\n\n    @question_name.setter\n    def question_name(self, value: str) -&gt; None:\n        self._model.question_name = value\n\n    @property\n    def question_id(self) -&gt; Optional[UUID]:\n        \"\"\"The ID of the question that the suggestion is for.\"\"\"\n        return self._model.question_id\n\n    @question_id.setter\n    def question_id(self, value: UUID) -&gt; None:\n        self._model.question_id = value\n\n    @property\n    def type(self) -&gt; Optional[Literal[\"model\", \"human\"]]:\n        \"\"\"The type of suggestion, either 'model' or 'human'.\"\"\"\n        return self._model.type\n\n    @property\n    def score(self) -&gt; Optional[Union[float, List[float]]]:\n        \"\"\"The score of the suggestion.\"\"\"\n        return self._model.score\n\n    @score.setter\n    def score(self, value: float) -&gt; None:\n        self._model.score = value\n\n    @property\n    def agent(self) -&gt; Optional[str]:\n        \"\"\"The agent that created the suggestion.\"\"\"\n        return self._model.agent\n\n    @agent.setter\n    def agent(self, value: str) -&gt; None:\n        self._model.agent = value\n\n    @classmethod\n    def from_model(cls, model: SuggestionModel) -&gt; \"Suggestion\":\n        return cls(**model.model_dump())\n</code></pre>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.agent","title":"<code>agent: Optional[str]</code>  <code>property</code> <code>writable</code>","text":"<p>The agent that created the suggestion.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.question_id","title":"<code>question_id: Optional[UUID]</code>  <code>property</code> <code>writable</code>","text":"<p>The ID of the question that the suggestion is for.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.question_name","title":"<code>question_name: Optional[str]</code>  <code>property</code> <code>writable</code>","text":"<p>The name of the question that the suggestion is for.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.score","title":"<code>score: Optional[Union[float, List[float]]]</code>  <code>property</code> <code>writable</code>","text":"<p>The score of the suggestion.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.type","title":"<code>type: Optional[Literal['model', 'human']]</code>  <code>property</code>","text":"<p>The type of suggestion, either 'model' or 'human'.</p>"},{"location":"reference/argilla_sdk/records/suggestions/#argilla_sdk.suggestions.Suggestion.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The value of the suggestion.</p>"},{"location":"reference/argilla_sdk/records/vectors/","title":"<code>rg.Vector</code>","text":"<p>A vector is a numerical representation of a <code>Record</code> field or attribute, usually the record's text. Vectors can be used to search for similar records via the UI or SDK. Vectors can be added to a record directly or as a dictionary with a key that the matches <code>rg.VectorField</code> name.</p>"},{"location":"reference/argilla_sdk/records/vectors/#usage-examples","title":"Usage Examples","text":"<p>To use vectors within a dataset, you must define a vector field in the dataset settings. The vector field is a list of vector fields that can be attached to a record. The following example demonstrates how to add vectors to a dataset and how to access vectors from a record object:</p> <pre><code>import argilla_sdk as rg\n\ndataset = Dataset(\n    name=\"dataset_with_metadata\",\n    settings=Settings(\n        fields=[TextField(name=\"text\")],\n        questions=[LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])],\n        vectors=[\n            VectorField(name=\"vector_name\"),\n        ],\n    ),\n)\ndataset.publish()\n</code></pre> <p>Then, you can add records to the dataset with vectors that correspond to the vector field defined in the dataset settings:</p> <pre><code>dataset.records.add(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"vector_name\": [0.1, 0.2, 0.3]\n        }\n    ]\n)\n</code></pre> <p>Vectors can be passed using a mapping, where the key is the key in the data source and the value is the name in the dataset's setting's <code>rg.VectorField</code> object. For example, the following code adds a record with a vector using a mapping:</p> <pre><code>dataset.records.add(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"x\": [0.1, 0.2, 0.3]\n        }\n    ],\n    mapping={\"x\": \"vector_name\"}\n)\n</code></pre> <p>Or, vectors can be instantiated and added to a record directly, like this:</p> <pre><code>dataset.records.add(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            vectors=[rg.Vector(\"embedding\", [0.1, 0.2, 0.3])],\n        )\n    ]\n)\n</code></pre>"},{"location":"reference/argilla_sdk/records/vectors/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>Resource</code></p> <p>Class for interacting with Argilla Vectors. Vectors are typically used to represent         embeddings or features of records. The <code>Vector</code> class is used to deliver vectors to the Argilla server.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the vector.</p> <code>values</code> <code>list[float]</code> <p>The values of the vector.</p> Source code in <code>src/argilla_sdk/vectors.py</code> <pre><code>class Vector(Resource):\n    \"\"\" Class for interacting with Argilla Vectors. Vectors are typically used to represent \\\n        embeddings or features of records. The `Vector` class is used to deliver vectors to the Argilla server.\n\n    Attributes:\n        name (str): The name of the vector.\n        values (list[float]): The values of the vector.\n    \"\"\"\n\n    _model: VectorModel\n\n    def __init__(\n        self,\n        name: str,\n        values: list[float],\n    ) -&gt; None:\n        \"\"\"Initializes a Vector with a name and values that can be used to search in the Argilla ui.\n\n        Parameters:\n            name (str): Name of the vector\n            values (list[float]): List of float values\n\n        \"\"\"\n        self._model = VectorModel(\n            name=name,\n            vector_values=values,\n        )\n\n    def __repr__(self) -&gt; str:\n        return repr(f\"{self.__class__.__name__}({self._model})\")\n\n    ##############################\n    # Properties\n    ##############################\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Name of the vector that corresponds to the name of the vector in the dataset's `Settings`\"\"\"\n        return self._model.name\n\n    @property\n    def values(self) -&gt; list[float]:\n        \"\"\"List of float values that represent the vector.\"\"\"\n        return self._model.vector_values\n\n    ##############################\n    # Methods\n    ##############################\n\n    @classmethod\n    def from_model(cls, model: VectorModel) -&gt; \"Vector\":\n        return cls(\n            name=model.name,\n            values=model.vector_values,\n        )\n\n    def serialize(self) -&gt; dict[str, Any]:\n        dumped_model = self._model.model_dump()\n        name = dumped_model.pop(\"name\")\n        values = dumped_model.pop(\"vector_values\")\n        return {name: values}\n</code></pre>"},{"location":"reference/argilla_sdk/records/vectors/#argilla_sdk.vectors.Vector.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Name of the vector that corresponds to the name of the vector in the dataset's <code>Settings</code></p>"},{"location":"reference/argilla_sdk/records/vectors/#argilla_sdk.vectors.Vector.values","title":"<code>values: list[float]</code>  <code>property</code>","text":"<p>List of float values that represent the vector.</p>"},{"location":"reference/argilla_sdk/records/vectors/#argilla_sdk.vectors.Vector.__init__","title":"<code>__init__(name, values)</code>","text":"<p>Initializes a Vector with a name and values that can be used to search in the Argilla ui.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the vector</p> required <code>values</code> <code>list[float]</code> <p>List of float values</p> required Source code in <code>src/argilla_sdk/vectors.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: list[float],\n) -&gt; None:\n    \"\"\"Initializes a Vector with a name and values that can be used to search in the Argilla ui.\n\n    Parameters:\n        name (str): Name of the vector\n        values (list[float]): List of float values\n\n    \"\"\"\n    self._model = VectorModel(\n        name=name,\n        vector_values=values,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/fields/","title":"Fields","text":"<p>Fields in Argilla are define the content of a record that will be reviewed by a user.</p>"},{"location":"reference/argilla_sdk/settings/fields/#usage-examples","title":"Usage Examples","text":"<p>To define a field, instantiate the <code>TextField</code> class and pass it to the <code>fields</code> parameter of the <code>Settings</code> class.</p> <pre><code>text_field = rg.TextField(name=\"text\")\nmarkdown_field = rg.TextField(name=\"text\", use_markdown=True)\n</code></pre> <p>The <code>fields</code> parameter of the <code>Settings</code> class can accept a list of fields, like this:</p> <pre><code>settings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n)\n\ndata = rg.Dataset(\n    name=\"my_dataset\",\n    settings=settings,\n)\n</code></pre> <p>To add records with values for fields, refer to the <code>rg.Dataset.records</code> documentation.</p>"},{"location":"reference/argilla_sdk/settings/fields/#class-references","title":"Class References","text":"<p>             Bases: <code>SettingsPropertyBase</code></p> <p>Text field for use in Argilla <code>Dataset</code> <code>Settings</code></p> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>class TextField(SettingsPropertyBase):\n    \"\"\"Text field for use in Argilla `Dataset` `Settings`\"\"\"\n\n    _model: TextFieldModel\n\n    def __init__(\n        self,\n        name: str,\n        title: Optional[str] = None,\n        use_markdown: Optional[bool] = False,\n        required: Optional[bool] = True,\n        description: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Text field for use in Argilla `Dataset` `Settings`\n        Parameters:\n            name (str): The name of the field\n            title (Optional[str], optional): The title of the field. Defaults to None.\n            use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.\n            required (Optional[bool], optional): Whether the field is required. Defaults to True.\n            description (Optional[str], optional): The description of the field. Defaults to None.\n\n        \"\"\"\n        self._model = TextFieldModel(\n            name=name,\n            title=title,\n            required=required or True,\n            description=description,\n            settings=FieldSettings(type=\"text\", use_markdown=use_markdown),\n        )\n\n    @property\n    def use_markdown(self) -&gt; Optional[bool]:\n        return self._model.settings.use_markdown\n\n    @classmethod\n    def from_model(cls, model: TextFieldModel) -&gt; \"TextField\":\n        instance = cls(name=model.name)\n        instance._model = model\n\n        return instance\n</code></pre> <p>             Bases: <code>SettingsPropertyBase</code></p> <p>Vector field for use in Argilla <code>Dataset</code> <code>Settings</code></p> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>class VectorField(SettingsPropertyBase):\n    \"\"\"Vector field for use in Argilla `Dataset` `Settings`\"\"\"\n\n    _model: VectorFieldModel\n\n    def __init__(\n        self,\n        name: str,\n        dimensions: int,\n        title: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Vector field for use in Argilla `Dataset` `Settings`\n\n        Parameters:\n            name (str): The name of the field\n            dimensions (int): The number of dimensions in the vector\n            title (Optional[str], optional): The title of the field. Defaults to None.\n        \"\"\"\n        self._model = VectorFieldModel(\n            name=name,\n            title=title,\n            dimensions=dimensions,\n        )\n\n    @classmethod\n    def from_model(cls, model: VectorFieldModel) -&gt; \"VectorField\":\n        instance = cls(name=model.name, dimensions=model.dimensions)\n        instance._model = model\n\n        return instance\n\n    @property\n    def dimensions(self) -&gt; int:\n        return self._model.dimensions\n\n    @property\n    def title(self) -&gt; Optional[str]:\n        return self._model.title\n\n    @property\n    def name(self) -&gt; str:\n        return self._model.name\n</code></pre>"},{"location":"reference/argilla_sdk/settings/fields/#argilla_sdk.settings.TextField.__init__","title":"<code>__init__(name, title=None, use_markdown=False, required=True, description=None)</code>","text":"<p>Text field for use in Argilla <code>Dataset</code> <code>Settings</code> Parameters:     name (str): The name of the field     title (Optional[str], optional): The title of the field. Defaults to None.     use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.     required (Optional[bool], optional): Whether the field is required. Defaults to True.     description (Optional[str], optional): The description of the field. Defaults to None.</p> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    title: Optional[str] = None,\n    use_markdown: Optional[bool] = False,\n    required: Optional[bool] = True,\n    description: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Text field for use in Argilla `Dataset` `Settings`\n    Parameters:\n        name (str): The name of the field\n        title (Optional[str], optional): The title of the field. Defaults to None.\n        use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.\n        required (Optional[bool], optional): Whether the field is required. Defaults to True.\n        description (Optional[str], optional): The description of the field. Defaults to None.\n\n    \"\"\"\n    self._model = TextFieldModel(\n        name=name,\n        title=title,\n        required=required or True,\n        description=description,\n        settings=FieldSettings(type=\"text\", use_markdown=use_markdown),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/fields/#argilla_sdk.settings.VectorField.__init__","title":"<code>__init__(name, dimensions, title=None)</code>","text":"<p>Vector field for use in Argilla <code>Dataset</code> <code>Settings</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field</p> required <code>dimensions</code> <code>int</code> <p>The number of dimensions in the vector</p> required <code>title</code> <code>Optional[str]</code> <p>The title of the field. Defaults to None.</p> <code>None</code> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    dimensions: int,\n    title: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Vector field for use in Argilla `Dataset` `Settings`\n\n    Parameters:\n        name (str): The name of the field\n        dimensions (int): The number of dimensions in the vector\n        title (Optional[str], optional): The title of the field. Defaults to None.\n    \"\"\"\n    self._model = VectorFieldModel(\n        name=name,\n        title=title,\n        dimensions=dimensions,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/","title":"Metadata Properties","text":"<p>Metadata properties are used to define metadata fields in a dataset. Metadata fields are used to store additional information about the records in the dataset. For example, the category of a record, the price of a product, or any other information that is relevant to the record.</p>"},{"location":"reference/argilla_sdk/settings/metadata_property/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/settings/metadata_property/#defining-metadata-property-for-a-dataset","title":"Defining Metadata Property for a dataset","text":"<p>We define metadata properties via type specific classes. The following example demonstrates how to define metadata properties as either a float, integer, or terms metadata property:</p> <p><code>TermsMetadataProperty</code> is used to define a metadata field with a list of options. For example, a color field with options red, blue, and green. <code>FloatMetadataProperty</code> and <code>IntegerMetadataProperty</code> is used to define a metadata field with a float value. For example, a price field with a minimum value of 0.0 and a maximum value of 100.0.</p> <pre><code>import argilla_sdk as rg\n\n# Define metadata properties as terms\nmetadata_field = rg.TermsMetadataProperty(\n    name=\"color\",\n    options=[\"red\", \"blue\", \"green\"],\n    title=\"Color\",\n)\n\n# Define metadata properties as float\nfloat_ metadata_field = rg.FloatMetadataProperty(\n    name=\"price\",\n    min=0.0,\n    max=100.0,\n    title=\"Price\",\n)\n\n# Define metadata properties as integer\nint_metadata_field = rg.IntegerMetadataProperty(\n    name=\"quantity\",\n    min=0,\n    max=100,\n    title=\"Quantity\",\n)\n</code></pre> <p>Metadata properties can be added to a dataset settings object and published to the server:</p> <pre><code>dataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=rg.Settings(\n        fields=[\n            rg.TextField(name=\"text\"),\n        ],\n        metadata=[\n            metadata_field,\n            float_metadata_field,\n            int_metadata_field,\n        ],\n    ),\n)\n</code></pre> <p>To add records with metadata, refer to the <code>rg.Metadata</code> class documentation.</p>"},{"location":"reference/argilla_sdk/settings/metadata_property/#class-references","title":"Class References","text":"<p>             Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>class FloatMetadataProperty(MetadataPropertyBase):\n    def __init__(\n        self, name: str, min: Optional[float] = None, max: Optional[float] = None, title: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Create a metadata field with float settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            min (Optional[float]): The minimum value\n            max (Optional[float]): The maximum value\n            title (Optional[str]): The title of the metadata field\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n\n\n        \"\"\"\n        try:\n            settings = FloatMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.float)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.float,\n            title=title,\n            settings=settings,\n        )\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"FloatMetadataProperty\":\n        return FloatMetadataProperty(\n            name=model.name,\n            min=model.settings.min,\n            max=model.settings.max,\n            title=model.title,\n        )\n</code></pre> <p>             Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>class IntegerMetadataProperty(MetadataPropertyBase):\n    def __init__(\n        self, name: str, min: Optional[int] = None, max: Optional[int] = None, title: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Create a metadata field with integer settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            min (Optional[int]): The minimum value\n            max (Optional[int]): The maximum value\n            title (Optional[str]): The title of the metadata field\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n        \"\"\"\n\n        try:\n            settings = IntegerMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.integer)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.integer,\n            title=title,\n            settings=settings,\n        )\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"IntegerMetadataProperty\":\n        return IntegerMetadataProperty(\n            name=model.name,\n            min=model.settings.min,\n            max=model.settings.max,\n            title=model.title,\n        )\n</code></pre> <p>             Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>class TermsMetadataProperty(MetadataPropertyBase):\n    def __init__(self, name: str, options: list[str], title: Optional[str] = None) -&gt; None:\n        \"\"\"Create a metadata field with terms settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            options (list[str]): The list of terms\n            title (Optional[str]): The title of the metadata field\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n        \"\"\"\n\n        try:\n            settings = TermsMetadataPropertySettings(values=options, type=MetadataPropertyType.terms)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.terms,\n            title=title,\n            settings=settings,\n        )\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"TermsMetadataProperty\":\n        return TermsMetadataProperty(\n            name=model.name,\n            options=model.settings.values,\n            title=model.title,\n        )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/#argilla_sdk.settings.FloatMetadataProperty.__init__","title":"<code>__init__(name, min=None, max=None, title=None)</code>","text":"<p>Create a metadata field with float settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>min</code> <code>Optional[float]</code> <p>The minimum value</p> <code>None</code> <code>max</code> <code>Optional[float]</code> <p>The maximum value</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>def __init__(\n    self, name: str, min: Optional[float] = None, max: Optional[float] = None, title: Optional[str] = None\n) -&gt; None:\n    \"\"\"Create a metadata field with float settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        min (Optional[float]): The minimum value\n        max (Optional[float]): The maximum value\n        title (Optional[str]): The title of the metadata field\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n\n\n    \"\"\"\n    try:\n        settings = FloatMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.float)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.float,\n        title=title,\n        settings=settings,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/#argilla_sdk.settings.IntegerMetadataProperty.__init__","title":"<code>__init__(name, min=None, max=None, title=None)</code>","text":"<p>Create a metadata field with integer settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>min</code> <code>Optional[int]</code> <p>The minimum value</p> <code>None</code> <code>max</code> <code>Optional[int]</code> <p>The maximum value</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>def __init__(\n    self, name: str, min: Optional[int] = None, max: Optional[int] = None, title: Optional[str] = None\n) -&gt; None:\n    \"\"\"Create a metadata field with integer settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        min (Optional[int]): The minimum value\n        max (Optional[int]): The maximum value\n        title (Optional[str]): The title of the metadata field\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n    \"\"\"\n\n    try:\n        settings = IntegerMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.integer)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.integer,\n        title=title,\n        settings=settings,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/metadata_property/#argilla_sdk.settings.TermsMetadataProperty.__init__","title":"<code>__init__(name, options, title=None)</code>","text":"<p>Create a metadata field with terms settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>options</code> <code>list[str]</code> <p>The list of terms</p> required <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla_sdk/settings/_metadata.py</code> <pre><code>def __init__(self, name: str, options: list[str], title: Optional[str] = None) -&gt; None:\n    \"\"\"Create a metadata field with terms settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        options (list[str]): The list of terms\n        title (Optional[str]): The title of the metadata field\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n    \"\"\"\n\n    try:\n        settings = TermsMetadataPropertySettings(values=options, type=MetadataPropertyType.terms)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.terms,\n        title=title,\n        settings=settings,\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/","title":"Questions","text":"<p>Questions in Argilla are the questions that will be answered as feedback. They are used to define the questions that will be answered by users or models.</p>"},{"location":"reference/argilla_sdk/settings/questions/#usage-examples","title":"Usage Examples","text":"<p>To define a label question, for example, instantiate the <code>LabelQuestion</code> class and pass it to the <code>Settings</code> class.</p> <pre><code>label_question = rg.LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])\n\nsettings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    questions=[\n        label_question,\n    ],\n)\n</code></pre> <p>Questions can be combined in extensible ways based on the type of feedback you want to collect. For example, you can combine a label question with a text question to collect both a label and a text response.</p> <pre><code>label_question = rg.LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])\ntext_question = rg.TextQuestion(name=\"response\")\n\nsettings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    questions=[\n        label_question,\n        text_question,\n    ],\n)\n\ndataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=settings,\n)\n</code></pre> <p>To add records with responses to questions, refer to the <code>rg.Response</code> class documentation.</p>"},{"location":"reference/argilla_sdk/settings/questions/#class-references","title":"Class References","text":"<p>             Bases: <code>SettingsPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class LabelQuestion(SettingsPropertyBase):\n    _model: LabelQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        labels: List[str],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\" Define a new label question for `Settings` of a `Dataset`. A label \\\n            question is a question where the user can select one label from \\\n            a list of available labels.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            labels: List[str]: The list of available labels for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n        self._model = LabelQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=LabelQuestionSettings(options=_render_values_as_options(labels)),\n        )\n\n    @classmethod\n    def from_model(cls, model: LabelQuestionModel) -&gt; \"LabelQuestion\":\n        instance = cls(name=model.name, labels=_render_options_as_values(model.settings.options))\n        instance._model = model\n        return instance\n\n    ##############################\n    # Public properties\n    ##############################\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return _render_options_as_values(self._model.settings.options)\n\n    @labels.setter\n    def labels(self, labels: List[str]) -&gt; None:\n        self._model.settings.options = _render_values_as_options(labels)\n</code></pre> <p>             Bases: <code>LabelQuestion</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class MultiLabelQuestion(LabelQuestion):\n    _model: MultiLabelQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        labels: List[str],\n        visible_labels: Optional[int] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new multilabel question for `Settings` of a `Dataset`. A \\\n            multilabel question is a question where the user can select multiple \\\n            labels from a list of available labels.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            labels: List[str]: The list of available labels for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n        self._model = MultiLabelQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            visible_labels=visible_labels,\n            settings=MultiLabelQuestionSettings(options=_render_values_as_options(labels)),\n        )\n\n    @classmethod\n    def from_model(cls, model: MultiLabelQuestionModel) -&gt; \"MultiLabelQuestion\":\n        instance = cls(name=model.name, labels=_render_options_as_values(model.settings.options))\n        instance._model = model\n\n        return instance\n\n    @property\n    def visible_labels(self) -&gt; Optional[int]:\n        return self._model.settings.visible_options\n\n    @visible_labels.setter\n    def visible_labels(self, visible_labels: Optional[int]) -&gt; None:\n        self._model.settings.visible_options = visible_labels\n</code></pre> <p>             Bases: <code>SettingsPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class RankingQuestion(SettingsPropertyBase):\n    _model: RankingQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        values: List[str],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new ranking question for `Settings` of a `Dataset`. A ranking question \\\n            is a question where the user can rank a list of options.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            values: List[str]: The list of available values for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n        self._model = RankingQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=RankingQuestionSettings(options=_render_values_as_options(values)),\n        )\n\n    @classmethod\n    def from_model(cls, model: RankingQuestionModel) -&gt; \"RankingQuestion\":\n        instance = cls(name=model.name, values=_render_options_as_values(model.settings.options))\n        instance._model = model\n\n        return instance\n\n    @property\n    def values(self) -&gt; List[str]:\n        return _render_options_as_values(self._model.settings.options)\n\n    @values.setter\n    def values(self, values: List[int]) -&gt; None:\n        self._model.settings.options = _render_values_as_options(values)\n</code></pre> <p>             Bases: <code>SettingsPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class TextQuestion(SettingsPropertyBase):\n    _model: TextQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n        use_markdown: bool = False,\n    ) -&gt; None:\n        \"\"\"Create a new text question for `Settings` of a `Dataset`. A text question \\\n            is a question where the user can input text.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n            use_markdown: bool: If the question should use markdown for the description.\n        \"\"\"\n        self._model = TextQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=TextQuestionSettings(use_markdown=use_markdown),\n        )\n\n    @classmethod\n    def from_model(cls, model: TextQuestionModel) -&gt; \"TextQuestion\":\n        instance = cls(name=model.name)\n        instance._model = model\n\n        return instance\n\n    @property\n    def use_markdown(self) -&gt; bool:\n        return self._model.settings.use_markdown\n\n    @use_markdown.setter\n    def use_markdown(self, use_markdown: bool) -&gt; None:\n        self._model.settings.use_markdown = use_markdown\n</code></pre> <p>             Bases: <code>SettingsPropertyBase</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class RatingQuestion(SettingsPropertyBase):\n    _model: RatingQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        values: List[int],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new rating question for `Settings` of a `Dataset`. A rating question \\\n            is a question where the user can select a value from a sequential list of options.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            values: List[int]: The list of available values for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n        self._model = RatingQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            values=values,\n            settings=RatingQuestionSettings(options=_render_values_as_options(values)),\n        )\n\n    @classmethod\n    def from_model(cls, model: RatingQuestionModel) -&gt; \"RatingQuestion\":\n        instance = cls(name=model.name, values=_render_options_as_values(model.settings.options))\n        instance._model = model\n\n        return instance\n\n    @property\n    def values(self) -&gt; List[int]:\n        return _render_options_as_values(self._model.settings.options)\n\n    @values.setter\n    def values(self, values: List[int]) -&gt; None:\n        self._model.values = _render_values_as_options(values)\n</code></pre> <p>             Bases: <code>MultiLabelQuestion</code></p> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>class SpanQuestion(MultiLabelQuestion):\n    _model: SpanQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        field: str,\n        labels: List[str],\n        allow_overlapping: bool = False,\n        visible_labels: Optional[int] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ):\n        \"\"\" Create a new span question for `Settings` of a `Dataset`. A span question \\\n            is a question where the user can select a section of text within a text field \\\n            and assign it a label.\n\n            Parameters:\n                name: str: The name of the question to be used as a reference.\n                field: str: The name of the text field to apply the span question to.\n                labels: List[str]: The list of available labels for the question.\n                allow_overlapping: bool: If the user can select overlapping spans.\n                visible_labels: Optional[int]: The number of labels to show at once.\n                title: Optional[str]: The title of the question to be shown in the UI.\n                description: Optional[str]: The description of the question to be shown in the UI.\n                required: bool: If the question is required for a record to be valid.\n            \"\"\"\n        self._model = SpanQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=SpanQuestionSettings(\n                field=field,\n                allow_overlapping=allow_overlapping,\n                visible_options=visible_labels,\n                options=_render_values_as_options(labels),\n            ),\n        )\n\n    @property\n    def name(self):\n        return self._model.name\n\n    @property\n    def field(self):\n        return self._model.settings.field\n\n    @field.setter\n    def field(self, field: str):\n        self._model.settings.field = field\n\n    @property\n    def allow_overlapping(self):\n        return self._model.settings.allow_overlapping\n\n    @allow_overlapping.setter\n    def allow_overlapping(self, allow_overlapping: bool):\n        self._model.settings.allow_overlapping = allow_overlapping\n\n    @property\n    def visible_labels(self) -&gt; Optional[int]:\n        return self._model.settings.visible_options\n\n    @visible_labels.setter\n    def visible_labels(self, visible_labels: Optional[int]) -&gt; None:\n        self._model.settings.visible_options = visible_labels\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return _render_options_as_values(self._model.settings.options)\n\n    @labels.setter\n    def labels(self, labels: List[str]) -&gt; None:\n        self._model.settings.options = _render_values_as_options(labels)\n\n    @classmethod\n    def from_model(cls, model: SpanQuestionModel) -&gt; \"SpanQuestion\":\n        instance = cls(\n            name=model.name,\n            field=model.settings.field,\n            labels=_render_options_as_values(model.settings.options),\n        )\n        instance._model = model\n\n        return instance\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.LabelQuestion.__init__","title":"<code>__init__(name, labels, title=None, description=None, required=True)</code>","text":"<p>Define a new label question for <code>Settings</code> of a <code>Dataset</code>. A label             question is a question where the user can select one label from             a list of available labels.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>labels</code> <code>List[str]</code> <p>List[str]: The list of available labels for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    labels: List[str],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\" Define a new label question for `Settings` of a `Dataset`. A label \\\n        question is a question where the user can select one label from \\\n        a list of available labels.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        labels: List[str]: The list of available labels for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n    \"\"\"\n    self._model = LabelQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=LabelQuestionSettings(options=_render_values_as_options(labels)),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.MultiLabelQuestion.__init__","title":"<code>__init__(name, labels, visible_labels=None, title=None, description=None, required=True)</code>","text":"<p>Create a new multilabel question for <code>Settings</code> of a <code>Dataset</code>. A             multilabel question is a question where the user can select multiple             labels from a list of available labels.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>labels</code> <code>List[str]</code> <p>List[str]: The list of available labels for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    labels: List[str],\n    visible_labels: Optional[int] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new multilabel question for `Settings` of a `Dataset`. A \\\n        multilabel question is a question where the user can select multiple \\\n        labels from a list of available labels.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        labels: List[str]: The list of available labels for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n    \"\"\"\n    self._model = MultiLabelQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        visible_labels=visible_labels,\n        settings=MultiLabelQuestionSettings(options=_render_values_as_options(labels)),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.RankingQuestion.__init__","title":"<code>__init__(name, values, title=None, description=None, required=True)</code>","text":"<p>Create a new ranking question for <code>Settings</code> of a <code>Dataset</code>. A ranking question             is a question where the user can rank a list of options.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>values</code> <code>List[str]</code> <p>List[str]: The list of available values for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: List[str],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new ranking question for `Settings` of a `Dataset`. A ranking question \\\n        is a question where the user can rank a list of options.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        values: List[str]: The list of available values for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n    \"\"\"\n    self._model = RankingQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=RankingQuestionSettings(options=_render_values_as_options(values)),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.TextQuestion.__init__","title":"<code>__init__(name, title=None, description=None, required=True, use_markdown=False)</code>","text":"<p>Create a new text question for <code>Settings</code> of a <code>Dataset</code>. A text question             is a question where the user can input text.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> <code>use_markdown</code> <code>bool</code> <p>bool: If the question should use markdown for the description.</p> <code>False</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n    use_markdown: bool = False,\n) -&gt; None:\n    \"\"\"Create a new text question for `Settings` of a `Dataset`. A text question \\\n        is a question where the user can input text.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n        use_markdown: bool: If the question should use markdown for the description.\n    \"\"\"\n    self._model = TextQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=TextQuestionSettings(use_markdown=use_markdown),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.RatingQuestion.__init__","title":"<code>__init__(name, values, title=None, description=None, required=True)</code>","text":"<p>Create a new rating question for <code>Settings</code> of a <code>Dataset</code>. A rating question             is a question where the user can select a value from a sequential list of options.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>values</code> <code>List[int]</code> <p>List[int]: The list of available values for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: List[int],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new rating question for `Settings` of a `Dataset`. A rating question \\\n        is a question where the user can select a value from a sequential list of options.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        values: List[int]: The list of available values for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n    \"\"\"\n    self._model = RatingQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        values=values,\n        settings=RatingQuestionSettings(options=_render_values_as_options(values)),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/questions/#argilla_sdk.settings.SpanQuestion.__init__","title":"<code>__init__(name, field, labels, allow_overlapping=False, visible_labels=None, title=None, description=None, required=True)</code>","text":"<p>Create a new span question for <code>Settings</code> of a <code>Dataset</code>. A span question             is a question where the user can select a section of text within a text field             and assign it a label.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>field</code> <code>str</code> <p>str: The name of the text field to apply the span question to.</p> required <code>labels</code> <code>List[str]</code> <p>List[str]: The list of available labels for the question.</p> required <code>allow_overlapping</code> <code>bool</code> <p>bool: If the user can select overlapping spans.</p> <code>False</code> <code>visible_labels</code> <code>Optional[int]</code> <p>Optional[int]: The number of labels to show at once.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla_sdk/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    field: str,\n    labels: List[str],\n    allow_overlapping: bool = False,\n    visible_labels: Optional[int] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n):\n    \"\"\" Create a new span question for `Settings` of a `Dataset`. A span question \\\n        is a question where the user can select a section of text within a text field \\\n        and assign it a label.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            field: str: The name of the text field to apply the span question to.\n            labels: List[str]: The list of available labels for the question.\n            allow_overlapping: bool: If the user can select overlapping spans.\n            visible_labels: Optional[int]: The number of labels to show at once.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n    self._model = SpanQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=SpanQuestionSettings(\n            field=field,\n            allow_overlapping=allow_overlapping,\n            visible_options=visible_labels,\n            options=_render_values_as_options(labels),\n        ),\n    )\n</code></pre>"},{"location":"reference/argilla_sdk/settings/settings/","title":"<code>rg.Settings</code>","text":"<p><code>rg.Settings</code> is used to define the setttings of an Argilla <code>Dataset</code>. The settings can be used to configure the behavior of the dataset, such as the fields, questions, guidelines, metadata, and vectors. The <code>Settings</code> class is passed to the <code>Dataset</code> class and used to publish the dataset to the server. Once published, the settings of a dataset cannot be changed. </p>"},{"location":"reference/argilla_sdk/settings/settings/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla_sdk/settings/settings/#creating-a-new-dataset-with-settings","title":"Creating a new dataset with settings","text":"<p>To create a new dataset with settings, instantiate the <code>Settings</code> class and pass it to the <code>Dataset</code> class. </p> <pre><code>import argilla_sdk as rg\n\nsettings = rg.Settings(\n    guidelines=\"Select the sentiment of the prompt.\",\n    fields=[rg.TextField(name=\"prompt\", use_markdown=True)],\n    questions=[rg.LabelQuestion(name=\"sentiment\", labels=[\"positive\", \"negative\"])],\n)\n\ndataset = rg.Dataset(\n    name=\"sentiment_analysis\",\n    settings=settings,\n)\n\n# Publish the dataset to the server\ndataset.publish()\n</code></pre> <p>To define the settings for fields, questions, metadata, or vectors, refer to the <code>rg.TextField</code>, <code>rg.LabelQuestion</code>, <code>rg.TermsMetadataProperty</code>, and <code>rg.VectorField</code> class documentation.</p>"},{"location":"reference/argilla_sdk/settings/settings/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>Resource</code></p> <p>Settings class for Argilla Datasets.</p> <p>This class is used to define the representation of a Dataset within the UI.</p> Source code in <code>src/argilla_sdk/settings/_resource.py</code> <pre><code>class Settings(Resource):\n    \"\"\"\n    Settings class for Argilla Datasets.\n\n    This class is used to define the representation of a Dataset within the UI.\n    \"\"\"\n\n    def __init__(\n        self,\n        fields: Optional[List[FieldType]] = None,\n        questions: Optional[List[QuestionType]] = None,\n        vectors: Optional[List[VectorField]] = None,\n        metadata: Optional[List[MetadataType]] = None,\n        guidelines: Optional[str] = None,\n        allow_extra_metadata: bool = False,\n        _dataset: Optional[\"Dataset\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            fields (List[TextField]): A list of TextField objects that represent the fields in the Dataset.\n            questions (List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]): A list of Question objects that represent the questions in the Dataset.\n            vectors (List[VectorField]): A list of VectorField objects that represent the vectors in the Dataset.\n            metadata (List[MetadataField]): A list of MetadataField objects that represent the metadata in the Dataset.\n            guidelines (str): A string containing the guidelines for the Dataset.\n            allow_extra_metadata (bool): A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.\n        \"\"\"\n        super().__init__(client=_dataset._client if _dataset else None)\n\n        self.__questions = questions or []\n        self.__fields = fields or []\n        self.__vectors = vectors or []\n        self.__metadata = metadata or []\n\n        self.__guidelines = self.__process_guidelines(guidelines)\n        self.__allow_extra_metadata = allow_extra_metadata\n\n        self._dataset = _dataset\n\n    #####################\n    # Properties        #\n    #####################\n\n    @property\n    def fields(self) -&gt; List[FieldType]:\n        return self.__fields\n\n    @fields.setter\n    def fields(self, fields: List[FieldType]):\n        self.__fields = fields\n\n    @property\n    def questions(self) -&gt; List[QuestionType]:\n        return self.__questions\n\n    @questions.setter\n    def questions(self, questions: List[QuestionType]):\n        self.__questions = questions\n\n    @property\n    def guidelines(self) -&gt; str:\n        return self.__guidelines\n\n    @guidelines.setter\n    def guidelines(self, guidelines: str):\n        self.__guidelines = self.__process_guidelines(guidelines)\n\n    @property\n    def vectors(self) -&gt; List[VectorField]:\n        return self.__vectors\n\n    @vectors.setter\n    def vectors(self, vectors: List[VectorField]):\n        self.__vectors = vectors\n\n    @property\n    def metadata(self) -&gt; List[MetadataType]:\n        return self.__metadata\n\n    @metadata.setter\n    def metadata(self, metadata: List[MetadataType]):\n        self.__metadata = metadata\n\n    @property\n    def allow_extra_metadata(self) -&gt; bool:\n        return self.__allow_extra_metadata\n\n    @allow_extra_metadata.setter\n    def allow_extra_metadata(self, value: bool):\n        self.__allow_extra_metadata = value\n\n    @property\n    def dataset(self) -&gt; \"Dataset\":\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, dataset: \"Dataset\"):\n        self._dataset = dataset\n        self._client = dataset._client\n\n    @cached_property\n    def schema(self) -&gt; dict:\n        schema_dict = {}\n\n        for field in self.fields:\n            schema_dict[field.name] = field\n\n        for question in self.questions:\n            schema_dict[question.name] = question\n\n        for vector in self.vectors:\n            schema_dict[vector.name] = vector\n\n        for metadata in self.metadata:\n            schema_dict[metadata.name] = metadata\n\n        return schema_dict\n\n    @cached_property\n    def schema_by_id(self) -&gt; Dict[UUID, Union[FieldType, QuestionType]]:\n        return {v.id: v for v in self.schema.values()}\n\n    def validate(self) -&gt; None:\n        if not all([self.fields, self.questions]):\n            message = \"Fields and questions are required\"\n            raise SettingsError(message=message)\n\n    #####################\n    #  Public methods   #\n    #####################\n\n    def get(self) -&gt; \"Settings\":\n        self.__fetch_fields()\n        self.__fetch_questions()\n        self.__fetch_vectors()\n        self.__fetch_metadata()\n        self.__get_dataset_related_attributes()\n\n        self._update_last_api_call()\n        return self\n\n    def create(self) -&gt; \"Settings\":\n        self.__upsert_fields()\n        self.__upsert_questions()\n        self.__upsert_vectors()\n        self.__upsert_metadata()\n        self.__update_dataset_related_attributes()\n\n        self._update_last_api_call()\n        return self\n\n    def question_by_name(self, question_name: str) -&gt; QuestionType:\n        for question in self.questions:\n            if question.name == question_name:\n                return question\n        raise ValueError(f\"Question with name {question_name} not found\")\n\n    def question_by_id(self, question_id: UUID) -&gt; QuestionType:\n        property = self.schema_by_id.get(question_id)\n        if isinstance(property, QuestionType):\n            return property\n        raise ValueError(f\"Question with id {question_id} not found\")\n\n    def __fetch_fields(self) -&gt; List[FieldType]:\n        models = self._client.api.fields.list(dataset_id=self._dataset.id)\n        self.__fields = [field_from_model(model) for model in models]\n\n        return self.__fields\n\n    def __fetch_questions(self) -&gt; List[QuestionType]:\n        models = self._client.api.questions.list(dataset_id=self._dataset.id)\n        self.__questions = [question_from_model(model) for model in models]\n\n        return self.__questions\n\n    def __fetch_vectors(self) -&gt; List[VectorField]:\n        models = self._client.api.vectors.list(dataset_id=self._dataset.id)\n        self.__vectors = [field_from_model(model) for model in models]\n\n        return self.__vectors\n\n    def __fetch_metadata(self) -&gt; List[MetadataType]:\n        models = self._client.api.metadata.list(dataset_id=self._dataset.id)\n        self.__metadata = [field_from_model(model) for model in models]\n\n        return self.__metadata\n\n    def __get_dataset_related_attributes(self):\n        # This flow may be a bit weird, but it's the only way to update the dataset related attributes\n        # Everything is point that we should have several settings-related endpoints in the API to handle this.\n        # POST /api/v1/datasets/{dataset_id}/settings\n        # {\n        #   \"guidelines\": ....,\n        #   \"allow_extra_metadata\": ....,\n        # }\n        # But this is not implemented yet, so we need to update the dataset model directly\n        dataset_model = self._client.api.datasets.get(self._dataset.id)\n\n        self.guidelines = dataset_model.guidelines\n        self.allow_extra_metadata = dataset_model.allow_extra_metadata\n\n    def __update_dataset_related_attributes(self):\n        # This flow may be a bit weird, but it's the only way to update the dataset related attributes\n        # Everything is point that we should have several settings-related endpoints in the API to handle this.\n        # POST /api/v1/datasets/{dataset_id}/settings\n        # {\n        #   \"guidelines\": ....,\n        #   \"allow_extra_metadata\": ....,\n        # }\n        # But this is not implemented yet, so we need to update the dataset model directly\n        dataset_model = DatasetModel(\n            id=self._dataset.id,\n            name=self._dataset.name,\n            guidelines=self.guidelines,\n            allow_extra_metadata=self.allow_extra_metadata,\n        )\n        self._client.api.datasets.update(dataset_model)\n\n    def __upsert_questions(self) -&gt; None:\n        for question in self.__questions:\n            try:\n                question_model = self._client.api.questions.create(\n                    dataset_id=self._dataset.id, question=question._model\n                )\n                question._model = question_model\n            except ArgillaAPIError as e:\n                raise SettingsError(f\"Failed to create question {question.name}\") from e\n\n    def __upsert_fields(self) -&gt; None:\n        for field in self.__fields:\n            try:\n                field_model = self._client.api.fields.create(dataset_id=self._dataset.id, field=field._model)\n                field._model = field_model\n            except ArgillaAPIError as e:\n                raise SettingsError(f\"Failed to create field {field.name}\") from e\n\n    def __upsert_vectors(self) -&gt; None:\n        for vector in self.__vectors:\n            try:\n                vector_model = self._client.api.vectors.create(dataset_id=self._dataset.id, vector=vector._model)\n                vector._model = vector_model\n            except ArgillaAPIError as e:\n                raise SettingsError(f\"Failed to create vector {vector.name}\") from e\n\n    def __upsert_metadata(self) -&gt; None:\n        for metadata in self.__metadata:\n            metadata_model = self._client.api.metadata.create(\n                dataset_id=self._dataset.id, metadata_field=metadata._model\n            )\n            metadata._model = metadata_model\n\n    def serialize(self):\n        try:\n            return {\n                \"guidelines\": self.guidelines,\n                \"fields\": self.__serialize_fields(fields=self.fields),\n                \"questions\": self.__serialize_questions(questions=self.questions),\n                \"allow_extra_metadata\": self.allow_extra_metadata,\n            }\n        except Exception as e:\n            raise ArgillaSerializeError(f\"Failed to serialize the settings. {e.__class__.__name__}\") from e\n\n    #####################\n    #  Utility methods  #\n    #####################\n\n    def __eq__(self, other: \"Settings\") -&gt; bool:\n        return self.serialize() == other.serialize()  # TODO: Create proper __eq__ methods for fields and questions\n\n    def __process_fields(self, fields: List[FieldType]) -&gt; List[\"TextFieldModel\"]:\n        processed_fields = []\n        for field in fields:\n            try:\n                processed_field = field._model\n            except Exception as e:\n                raise SettingsError(f\"Failed to process field {field.name}\") from e\n            processed_fields.append(processed_field)\n        return processed_fields\n\n    def __process_questions(self, questions: List[QuestionType]) -&gt; List[\"TextQuestionModel\"]:\n        processed_questions = []\n        for question in questions:\n            try:\n                processed_question = question._model\n            except Exception as e:\n                raise SettingsError(f\"Failed to process question {question.name}\") from e\n            processed_questions.append(processed_question)\n        return processed_questions\n\n    def __process_guidelines(self, guidelines):\n\n        if guidelines is None:\n            return guidelines\n\n        if not isinstance(guidelines, str):\n            raise SettingsError(\"Guidelines must be a string or a path to a file\")\n\n        if os.path.exists(guidelines):\n            with open(guidelines, \"r\") as file:\n                return file.read()\n\n        return guidelines\n\n    def __serialize_fields(self, fields):\n        return [field.serialize() for field in fields]\n\n    def __serialize_questions(self, questions):\n        return [question.serialize() for question in questions]\n\n    #####################\n    #  Repr Methods     #\n    #####################\n\n    def __repr__(self) -&gt; str:\n        yield \"guidelines\", self.guidelines\n        yield \"allow_extra_metadata\", self.allow_extra_metadata\n        yield \"fields\", self.fields\n        yield \"questions\", self.questions\n        yield \"vectors\", self.vectors\n        yield \"metadata\", self.metadata\n</code></pre>"},{"location":"reference/argilla_sdk/settings/settings/#argilla_sdk.settings.Settings.__init__","title":"<code>__init__(fields=None, questions=None, vectors=None, metadata=None, guidelines=None, allow_extra_metadata=False, _dataset=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>fields</code> <code>List[TextField]</code> <p>A list of TextField objects that represent the fields in the Dataset.</p> <code>None</code> <code>questions</code> <code>List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]</code> <p>A list of Question objects that represent the questions in the Dataset.</p> <code>None</code> <code>vectors</code> <code>List[VectorField]</code> <p>A list of VectorField objects that represent the vectors in the Dataset.</p> <code>None</code> <code>metadata</code> <code>List[MetadataField]</code> <p>A list of MetadataField objects that represent the metadata in the Dataset.</p> <code>None</code> <code>guidelines</code> <code>str</code> <p>A string containing the guidelines for the Dataset.</p> <code>None</code> <code>allow_extra_metadata</code> <code>bool</code> <p>A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.</p> <code>False</code> Source code in <code>src/argilla_sdk/settings/_resource.py</code> <pre><code>def __init__(\n    self,\n    fields: Optional[List[FieldType]] = None,\n    questions: Optional[List[QuestionType]] = None,\n    vectors: Optional[List[VectorField]] = None,\n    metadata: Optional[List[MetadataType]] = None,\n    guidelines: Optional[str] = None,\n    allow_extra_metadata: bool = False,\n    _dataset: Optional[\"Dataset\"] = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        fields (List[TextField]): A list of TextField objects that represent the fields in the Dataset.\n        questions (List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]): A list of Question objects that represent the questions in the Dataset.\n        vectors (List[VectorField]): A list of VectorField objects that represent the vectors in the Dataset.\n        metadata (List[MetadataField]): A list of MetadataField objects that represent the metadata in the Dataset.\n        guidelines (str): A string containing the guidelines for the Dataset.\n        allow_extra_metadata (bool): A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.\n    \"\"\"\n    super().__init__(client=_dataset._client if _dataset else None)\n\n    self.__questions = questions or []\n    self.__fields = fields or []\n    self.__vectors = vectors or []\n    self.__metadata = metadata or []\n\n    self.__guidelines = self.__process_guidelines(guidelines)\n    self.__allow_extra_metadata = allow_extra_metadata\n\n    self._dataset = _dataset\n</code></pre>"},{"location":"reference/argilla_sdk/settings/vectors/","title":"Fields","text":"<p>Vector fields in Argilla are used to define the vector form of a record that will be reviewed by a user. </p>"},{"location":"reference/argilla_sdk/settings/vectors/#usage-examples","title":"Usage Examples","text":"<p>To define a vector field, instantiate the <code>VectorField</code> class and pass it to the <code>fields</code> parameter of the <code>Settings</code> class.</p> <pre><code>vector_field = rg.VectorField(name=\"embedding\", dimension=768)\n</code></pre> <p>The <code>fields</code> parameter of the <code>Settings</code> class can accept a list of fields, like this:</p> <pre><code>settings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    vectors=[\n        rg.VectorField(\n            name=\"my_vector\",\n            dimension=768,\n            title=\"Document Embedding\",\n        ),\n    ],\n)\n</code></pre> <p>To add records with vectors, refer to the <code>rg.Vector</code> class documentation.</p>"},{"location":"reference/argilla_sdk/settings/vectors/#class-reference","title":"Class Reference","text":"<p>             Bases: <code>SettingsPropertyBase</code></p> <p>Vector field for use in Argilla <code>Dataset</code> <code>Settings</code></p> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>class VectorField(SettingsPropertyBase):\n    \"\"\"Vector field for use in Argilla `Dataset` `Settings`\"\"\"\n\n    _model: VectorFieldModel\n\n    def __init__(\n        self,\n        name: str,\n        dimensions: int,\n        title: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Vector field for use in Argilla `Dataset` `Settings`\n\n        Parameters:\n            name (str): The name of the field\n            dimensions (int): The number of dimensions in the vector\n            title (Optional[str], optional): The title of the field. Defaults to None.\n        \"\"\"\n        self._model = VectorFieldModel(\n            name=name,\n            title=title,\n            dimensions=dimensions,\n        )\n\n    @classmethod\n    def from_model(cls, model: VectorFieldModel) -&gt; \"VectorField\":\n        instance = cls(name=model.name, dimensions=model.dimensions)\n        instance._model = model\n\n        return instance\n\n    @property\n    def dimensions(self) -&gt; int:\n        return self._model.dimensions\n\n    @property\n    def title(self) -&gt; Optional[str]:\n        return self._model.title\n\n    @property\n    def name(self) -&gt; str:\n        return self._model.name\n</code></pre>"},{"location":"reference/argilla_sdk/settings/vectors/#argilla_sdk.settings.VectorField.__init__","title":"<code>__init__(name, dimensions, title=None)</code>","text":"<p>Vector field for use in Argilla <code>Dataset</code> <code>Settings</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field</p> required <code>dimensions</code> <code>int</code> <p>The number of dimensions in the vector</p> required <code>title</code> <code>Optional[str]</code> <p>The title of the field. Defaults to None.</p> <code>None</code> Source code in <code>src/argilla_sdk/settings/_field.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    dimensions: int,\n    title: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Vector field for use in Argilla `Dataset` `Settings`\n\n    Parameters:\n        name (str): The name of the field\n        dimensions (int): The number of dimensions in the vector\n        title (Optional[str], optional): The title of the field. Defaults to None.\n    \"\"\"\n    self._model = VectorFieldModel(\n        name=name,\n        title=title,\n        dimensions=dimensions,\n    )\n</code></pre>"},{"location":"tutorials/rag_llm/","title":"RAG: Optimizing LLM for generation","text":"","tags":["level:advanced","type:generative","technique:RAG"]},{"location":"tutorials/rag_rankers_and_retrievers/","title":"Rag rankers and retrievers","text":"<p>description: This tutorial demonstrates how to create a pipeline for the LLM model using the RAG architecture. tags:   - level:intermediate   - type:predictive   - technique:RAG</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>These are the tutorials for the Argilla-python SDK. They provide step-by-step instructions for common scenarios, including detailed explanations and code samples.</p> <ul> <li> <p> Few-shot text classification with SetFit</p> <p>In this tutorial, you will learn how to use bulk labeling with semantic search from <code>sentence-transformers</code> embeddings and how to fine-tune a  <code>SetFit</code> model for classification.</p> <p> Tutorial</p> </li> <li> <p> Zero-shot token classification with GliNER</p> <p>In this tutorial, you will learn how to use zero-shot predictions from <code>GliNER</code> to fine-tune a span classification model with <code>SpanMarker</code>.</p> <p> Tutorial</p> </li> <li> <p> Bootstrap projects using LLMs</p> <p>In this tutorial, you will learn how to use LLMs to bootstrap projects for tasks like text classification, token classification, relationship extraction and summarization using <code>spacy-llm</code></p> <p> Tutorial</p> </li> <li> <p> Multi-modal projects</p> <p>In this tutorial, you will learn how to use Argilla for basic multi-modal projects with PDFs, images, video and audio. We will bulk label using <code>sentence-transformers</code> CLIP embeddings and fine-tune a model with <code>transformers</code>.</p> <p> Tutorial</p> </li> <li> <p> Monitor for data and model drift</p> <p>In this tutorial, you will learn you can keep track of model performance and data quality using <code>BerTopic</code> and <code>text-descriptives</code>.</p> <p> Tutorial</p> </li> <li> <p> RAG: retrievers and reranker</p> <p>In this tutorial, you will learn how to monitor and optimize retrieval and reranking models in a RAG pipeline using <code>haystack</code> and <code>sentence-transformers</code>.</p> <p> Tutorial</p> </li> <li> <p> RAG: LLMs</p> <p>In this tutorial, you will learn how to monitor and optimize generative LLMs in a RAG pipeline using <code>haystack</code> and <code>trl</code>.</p> <p> Tutorial</p> </li> <li> <p> Instruction-tuning an LLM</p> <p>In this tutorial, we will curate data for supervised fine-tuning (SFT) and fine-tune an LLM using <code>trl</code>.</p> <p> Tutorial</p> </li> <li> <p> Preference tuning an LLM</p> <p>In this tutorial, we will curate data for preference alignment of an LLM in order to fine-tune using <code>trl</code> and the DPO algorithm.</p> <p> Tutorial</p> </li> </ul>"},{"location":"tutorials/#leveladvanced","title":"level:advanced","text":"<ul> <li>RAG: Optimizing LLM for generation</li> </ul>"},{"location":"tutorials/#techniquerag","title":"technique:RAG","text":"<ul> <li>RAG: Optimizing LLM for generation</li> </ul>"},{"location":"tutorials/#typegenerative","title":"type:generative","text":"<ul> <li>RAG: Optimizing LLM for generation</li> </ul>"}]}